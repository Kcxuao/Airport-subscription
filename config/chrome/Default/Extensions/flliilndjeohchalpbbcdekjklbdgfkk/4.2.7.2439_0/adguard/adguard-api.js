// Generated by CoffeeScript 1.10.0
(function() {
  var Deferred, PENDING, REJECTED, RESOLVED, VERSION, _when, after, execute, flatten, has, installInto, isArguments, isPromise, wrap,
    slice = [].slice;

  VERSION = '3.1.0';

  PENDING = "pending";

  RESOLVED = "resolved";

  REJECTED = "rejected";

  has = function(obj, prop) {
    return obj != null ? obj.hasOwnProperty(prop) : void 0;
  };

  isArguments = function(obj) {
    return has(obj, 'length') && has(obj, 'callee');
  };

  isPromise = function(obj) {
    return has(obj, 'promise') && typeof (obj != null ? obj.promise : void 0) === 'function';
  };

  flatten = function(array) {
    if (isArguments(array)) {
      return flatten(Array.prototype.slice.call(array));
    }
    if (!Array.isArray(array)) {
      return [array];
    }
    return array.reduce(function(memo, value) {
      if (Array.isArray(value)) {
        return memo.concat(flatten(value));
      }
      memo.push(value);
      return memo;
    }, []);
  };

  after = function(times, func) {
    if (times <= 0) {
      return func();
    }
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  wrap = function(func, wrapper) {
    return function() {
      var args;
      args = [func].concat(Array.prototype.slice.call(arguments, 0));
      return wrapper.apply(this, args);
    };
  };

  execute = function(callbacks, args, context) {
    var callback, i, len, ref, results;
    ref = flatten(callbacks);
    results = [];
    for (i = 0, len = ref.length; i < len; i++) {
      callback = ref[i];
      results.push(callback.call.apply(callback, [context].concat(slice.call(args))));
    }
    return results;
  };

  Deferred = function() {
    var candidate, close, closingArguments, doneCallbacks, failCallbacks, progressCallbacks, state;
    state = PENDING;
    doneCallbacks = [];
    failCallbacks = [];
    progressCallbacks = [];
    closingArguments = {
      'resolved': {},
      'rejected': {},
      'pending': {}
    };
    this.promise = function(candidate) {
      var pipe, storeCallbacks;
      candidate = candidate || {};
      candidate.state = function() {
        return state;
      };
      storeCallbacks = function(shouldExecuteImmediately, holder, holderState) {
        return function() {
          if (state === PENDING) {
            holder.push.apply(holder, flatten(arguments));
          }
          if (shouldExecuteImmediately()) {
            execute(arguments, closingArguments[holderState]);
          }
          return candidate;
        };
      };
      candidate.done = storeCallbacks((function() {
        return state === RESOLVED;
      }), doneCallbacks, RESOLVED);
      candidate.fail = storeCallbacks((function() {
        return state === REJECTED;
      }), failCallbacks, REJECTED);
      candidate.progress = storeCallbacks((function() {
        return state !== PENDING;
      }), progressCallbacks, PENDING);
      candidate.always = function() {
        var ref;
        return (ref = candidate.done.apply(candidate, arguments)).fail.apply(ref, arguments);
      };
      pipe = function(doneFilter, failFilter, progressFilter) {
        var filter, master;
        master = new Deferred();
        filter = function(source, funnel, callback) {
          if (!callback) {
            return candidate[source](master[funnel]);
          }
          return candidate[source](function() {
            var args, value;
            args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
            value = callback.apply(null, args);
            if (isPromise(value)) {
              return value.done(master.resolve).fail(master.reject).progress(master.notify);
            } else {
              return master[funnel](value);
            }
          });
        };
        filter('done', 'resolve', doneFilter);
        filter('fail', 'reject', failFilter);
        filter('progress', 'notify', progressFilter);
        return master;
      };
      candidate.pipe = pipe;
      candidate.then = pipe;
      if (candidate.promise == null) {
        candidate.promise = function() {
          return candidate;
        };
      }
      return candidate;
    };
    this.promise(this);
    candidate = this;
    close = function(finalState, callbacks, context) {
      return function() {
        if (state === PENDING) {
          state = finalState;
          closingArguments[finalState] = arguments;
          execute(callbacks, closingArguments[finalState], context);
          return candidate;
        }
        return this;
      };
    };
    this.resolve = close(RESOLVED, doneCallbacks);
    this.reject = close(REJECTED, failCallbacks);
    this.notify = close(PENDING, progressCallbacks);
    this.resolveWith = function(context, args) {
      return close(RESOLVED, doneCallbacks, context).apply(null, args);
    };
    this.rejectWith = function(context, args) {
      return close(REJECTED, failCallbacks, context).apply(null, args);
    };
    this.notifyWith = function(context, args) {
      return close(PENDING, progressCallbacks, context).apply(null, args);
    };
    return this;
  };

  _when = function() {
    var def, defs, finish, i, len, resolutionArgs, trigger;
    defs = Array.prototype.slice.apply(arguments);
    if (defs.length === 1) {
      if (isPromise(defs[0])) {
        return defs[0];
      } else {
        return (new Deferred()).resolve(defs[0]).promise();
      }
    }
    trigger = new Deferred();
    if (!defs.length) {
      return trigger.resolve().promise();
    }
    resolutionArgs = [];
    finish = after(defs.length, function() {
      return trigger.resolve.apply(trigger, resolutionArgs);
    });
    defs.forEach(function(def, index) {
      if (isPromise(def)) {
        return def.done(function() {
          var args;
          args = 1 <= arguments.length ? slice.call(arguments, 0) : [];
          resolutionArgs[index] = args.length > 1 ? args : args[0];
          return finish();
        });
      } else {
        resolutionArgs[index] = def;
        return finish();
      }
    });
    for (i = 0, len = defs.length; i < len; i++) {
      def = defs[i];
      isPromise(def) && def.fail(trigger.reject);
    }
    return trigger.promise();
  };

  installInto = function(fw) {
    fw.Deferred = function() {
      return new Deferred();
    };
    fw.ajax = wrap(fw.ajax, function(ajax, options) {
      var createWrapper, def, promise, xhr;
      if (options == null) {
        options = {};
      }
      def = new Deferred();
      createWrapper = function(wrapped, finisher) {
        return wrap(wrapped, function() {
          var args, func;
          func = arguments[0], args = 2 <= arguments.length ? slice.call(arguments, 1) : [];
          if (func) {
            func.apply(null, args);
          }
          return finisher.apply(null, args);
        });
      };
      options.success = createWrapper(options.success, def.resolve);
      options.error = createWrapper(options.error, def.reject);
      xhr = ajax(options);
      promise = def.promise();
      promise.abort = function() {
        return xhr.abort();
      };
      return promise;
    });
    return fw.when = _when;
  };

  if (typeof exports !== 'undefined') {
    exports.Deferred = function() {
      return new Deferred();
    };
    exports.when = _when;
    exports.installInto = installInto;
  } else if (typeof define === 'function' && define.amd) {
    define(function() {
      if (typeof Zepto !== 'undefined') {
        return installInto(Zepto);
      } else {
        Deferred.when = _when;
        Deferred.installInto = installInto;
        return Deferred;
      }
    });
  } else if (typeof Zepto !== 'undefined') {
    installInto(Zepto);
  } else {
    this.Deferred = function() {
      return new Deferred();
    };
    this.Deferred.when = _when;
    this.Deferred.installInto = installInto;
  }

}).call(this);

/*** JavaScript SHA-256 hash function. License and copyright free. ***/ 

SHA256 = {};

SHA256.K = [
    0x428a2f98, 0x71374491, 0xb5c0fbcf, 0xe9b5dba5, 0x3956c25b, 
    0x59f111f1, 0x923f82a4, 0xab1c5ed5, 0xd807aa98, 0x12835b01, 
    0x243185be, 0x550c7dc3, 0x72be5d74, 0x80deb1fe, 0x9bdc06a7, 
    0xc19bf174, 0xe49b69c1, 0xefbe4786, 0x0fc19dc6, 0x240ca1cc, 
    0x2de92c6f, 0x4a7484aa, 0x5cb0a9dc, 0x76f988da, 0x983e5152, 
    0xa831c66d, 0xb00327c8, 0xbf597fc7, 0xc6e00bf3, 0xd5a79147, 
    0x06ca6351, 0x14292967, 0x27b70a85, 0x2e1b2138, 0x4d2c6dfc, 
    0x53380d13, 0x650a7354, 0x766a0abb, 0x81c2c92e, 0x92722c85,
    0xa2bfe8a1, 0xa81a664b, 0xc24b8b70, 0xc76c51a3, 0xd192e819, 
    0xd6990624, 0xf40e3585, 0x106aa070, 0x19a4c116, 0x1e376c08, 
    0x2748774c, 0x34b0bcb5, 0x391c0cb3, 0x4ed8aa4a, 0x5b9cca4f, 
    0x682e6ff3, 0x748f82ee, 0x78a5636f, 0x84c87814, 0x8cc70208, 
    0x90befffa, 0xa4506ceb, 0xbef9a3f7, 0xc67178f2];

SHA256.Uint8Array = function(length) {
    if (typeof Uint8Array !== 'undefined') {
        return new Uint8Array(length);
    } else {
        return new Array(length);
    }
};

SHA256.Int32Array = function(length) {
    if (typeof Int32Array !== 'undefined') {
        return new Int32Array(length);
    } else {
        return new Array(length);
    }
};

SHA256.setArray = function(target, source) {
    if (typeof Uint8Array !== 'undefined') {
        target.set(source);
    } else {
        for (var i = 0; i < source.length; i++) {
            target[i] = source[i];
        }
        for (i = source.length; i < target.length; i++) {
            target[i] = 0;
        }
    }
};

// The digest function returns the hash value (digest)
// as a 32 byte (typed) array.
// message: the string or byte array to hash
SHA256.digest = function(message) {
    var h0 = 0x6a09e667;
    var h1 = 0xbb67ae85;
    var h2 = 0x3c6ef372;
    var h3 = 0xa54ff53a;
    var h4 = 0x510e527f;
    var h5 = 0x9b05688c;
    var h6 = 0x1f83d9ab;
    var h7 = 0x5be0cd19;
    var K = SHA256.K;
    if (typeof message == 'string') {
       var s =  unescape(encodeURIComponent(message)); // UTF-8
        message = SHA256.Uint8Array(s.length);
        for (var i = 0; i < s.length; i++) {
            message[i] = s.charCodeAt(i) & 0xff;
        }
    }
    var length = message.length;
    var byteLength = Math.floor((length + 72) / 64) * 64;
    var wordLength = byteLength / 4;
    var bitLength = length * 8;
    var m = SHA256.Uint8Array(byteLength);
    SHA256.setArray(m, message);
    m[length] = 0x80;
    m[byteLength - 4] = bitLength >>> 24;
    m[byteLength - 3] = (bitLength >>> 16) & 0xff;
    m[byteLength - 2] = (bitLength >>> 8) & 0xff;
    m[byteLength - 1] = bitLength & 0xff;
    var words = SHA256.Int32Array(wordLength);
    var byteIndex = 0;
    for (i = 0; i < words.length; i++) {
        var word = m[byteIndex] << 24;
        word |= m[byteIndex + 1] << 16;
        word |= m[byteIndex + 2] << 8;
        word |= m[byteIndex + 3];
        words[i] = word;
        byteIndex += 4;
    }
    var w = SHA256.Int32Array(64);
    for (var j = 0; j < wordLength; j += 16) {
        for (i = 0; i < 16; i++) {
            w[i] = words[j + i];
        }
        for (i = 16; i < 64; i++) {
            var v = w[i - 15];
            var s0 = (v >>> 7) | (v << 25);
            s0 ^= (v >>> 18) | (v << 14);
            s0 ^= (v >>> 3);
            v = w[i - 2];
            var s1 = (v >>> 17) | (v << 15);
            s1 ^= (v >>> 19) | (v << 13);
            s1 ^= (v >>> 10);
            w[i] = (w[i - 16] + s0 + w[i - 7] + s1) & 0xffffffff; 
        }
        var a = h0;
        var b = h1;
        var c = h2;
        var d = h3;
        var e = h4;
        var f = h5;
        var g = h6;
        var h = h7;
        for (i = 0; i < 64; i++) {
            s1 = (e >>> 6) | (e << 26);
            s1 ^= (e >>> 11) | (e << 21);
            s1 ^= (e >>> 25) | (e << 7);
            var ch = (e & f) ^ (~e & g);
            var temp1 = (h + s1 + ch + K[i] + w[i]) & 0xffffffff;
            s0 = (a >>> 2) | (a << 30);
            s0 ^= (a >>> 13) | (a << 19);
            s0 ^= (a >>> 22) | (a << 10);
            var maj = (a & b) ^ (a & c) ^ (b & c);
            var temp2 = (s0 + maj) & 0xffffffff;
            h = g;
            g = f;
            f = e;
            e = (d + temp1) & 0xffffffff;
            d = c;
            c = b;
            b = a;
            a = (temp1 + temp2) & 0xffffffff;
        }
        h0 = (h0 + a) & 0xffffffff;
        h1 = (h1 + b) & 0xffffffff;
        h2 = (h2 + c) & 0xffffffff;
        h3 = (h3 + d) & 0xffffffff;
        h4 = (h4 + e) & 0xffffffff;
        h5 = (h5 + f) & 0xffffffff;
        h6 = (h6 + g) & 0xffffffff;
        h7 = (h7 + h) & 0xffffffff;
    }
    var hash = SHA256.Uint8Array(32);
    for (i = 0; i < 4; i++) {
        hash[i] = (h0 >>> (8 * (3 - i))) & 0xff;
        hash[i + 4] = (h1 >>> (8 * (3 - i))) & 0xff;
        hash[i + 8] = (h2 >>> (8 * (3 - i))) & 0xff;
        hash[i + 12] = (h3 >>> (8 * (3 - i))) & 0xff;
        hash[i + 16] = (h4 >>> (8 * (3 - i))) & 0xff;
        hash[i + 20] = (h5 >>> (8 * (3 - i))) & 0xff;
        hash[i + 24] = (h6 >>> (8 * (3 - i))) & 0xff;
        hash[i + 28] = (h7 >>> (8 * (3 - i))) & 0xff;
    }
    return hash;
};   

// The hash function returns the hash value as a hex string.
// message: the string or byte array to hash
SHA256.hash = function(message) {
    var digest = SHA256.digest(message);
    var hex = '';
	for (i = 0; i < digest.length; i++) {
		var s = '0' + digest[i].toString(16);
        hex += s.length > 2 ? s.substring(1) : s;
	}
    return hex;
};
/**
 * Patched: changed the way punycode is exposed, removed AMD/exports
 */

/*! http://mths.be/punycode v1.3.0 by @mathias */
;(function(root) {

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

		/** Highest positive signed 32-bit float value */
		maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

		/** Bootstring parameters */
		base = 36,
		tMin = 1,
		tMax = 26,
		skew = 38,
		damp = 700,
		initialBias = 72,
		initialN = 128, // 0x80
		delimiter = '-', // '\x2D'

		/** Regular expressions */
		regexPunycode = /^xn--/,
		regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
		regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

		/** Error messages */
		errors = {
			'overflow': 'Overflow: input needs wider integers to process',
			'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
			'invalid-input': 'Invalid input'
		},

		/** Convenience shortcuts */
		baseMinusTMin = base - tMin,
		floor = Math.floor,
		stringFromCharCode = String.fromCharCode,

		/** Temporary variable */
		key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var labels = string.split(regexSeparators);
		// Note: each label could still contain `@` in the case of an email address.
		return map(labels, function(label) {
			var parts = label.split('@');
			return map(parts, fn).join('@');
		}).join('.');
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <http://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
			counter = 0,
			length = string.length,
			value,
			extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * http://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
			inputLength = input.length,
			out,
			i = 0,
			n = initialN,
			bias = initialBias,
			basic,
			j,
			index,
			oldi,
			w,
			k,
			digit,
			t,
			/** Cached calculation results */
			baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
			delta,
			handledCPCount,
			basicLength,
			bias,
			j,
			m,
			q,
			k,
			t,
			currentValue,
			output = [],
			/** `inputLength` will hold the number of code points in `input`. */
			inputLength,
			/** Cached calculation results */
			handledCPCountPlusOne,
			baseMinusT,
			qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.3.0',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <http://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

    // Changed the way punycode is exposed
	root.punycode = punycode;
}(window));
/**
 * filters-downloader - Compiles filters source files
 * @version v1.0.11
 * @link http://adguard.com
 */
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * As it is not possible to use one library in node and browser environments,
 * we have to implementation of simple file download interface.
 * The one for node uses axios, the one for browser XMLHttpRequest.
 *
 * @type {{getLocalFile, getExternalFile}}
 */
let FileDownloadWrapper = (() => {
    'use strict';

    /**
     * If url protocol is not http or https return true, else false
     * @param url
     * @returns {boolean}
     */
    const isLocal = (url) => {
        const parsedUrl = new URL(url);
        const protocols = ['http:', 'https:'];
        return !protocols.includes(parsedUrl.protocol);
    };

    /**
     * Executes async request
     *
     * @param url Url
     * @param contentType Content type
     * @returns {Promise}
     */
    const executeRequestAsync = (url, contentType) => {

        return new Promise((resolve, reject) => {

            const onRequestLoad = (response) => {
                if (response.status !== 200 && response.status !== 0) {
                    reject(new Error('Response status is invalid: ' + response.status));
                }

                const responseText = response.responseText ? response.responseText : response.data;

                if (!responseText) {
                    reject(new Error('Response is empty'));
                }

                // Don't check response headers if url is local,
                // because edge extension doesn't provide headers for such url
                if (!isLocal(response.responseURL)) {
                    const responseContentType = response.getResponseHeader('Content-Type');
                    if (!responseContentType || !responseContentType.includes(contentType)) {
                        reject(new Error(`Response content type should be: "${contentType}"`));
                    }
                }

                const lines = responseText.trim().split(/[\r\n]+/);
                resolve(lines);
            };

            const request = new XMLHttpRequest();

            try {
                request.open('GET', url);
                request.setRequestHeader('Pragma', 'no-cache');
                request.overrideMimeType(contentType);
                request.mozBackgroundRequest = true;
                request.onload = function () {
                    onRequestLoad(request);
                };
                request.onerror = () => reject(new Error(`Request error happened: ${request.statusText || 'status text empty'}`));
                request.onabort = () => reject(new Error(`Request was aborted with status text: ${request.statusText}`));
                request.ontimeout = () => reject(new Error(`Request timed out with status text: ${request.statusText}`));

                request.send(null);
            } catch (ex) {
                reject(ex);
            }
        });
    };

    /**
     * Downloads filter rules from external url
     *
     * @param {string} url Filter file absolute URL or relative path
     * @returns {Promise} A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const getExternalFile = (url) => {
        return executeRequestAsync(url, 'text/plain');
    };

    /**
     * Get filter rules from local path
     *
     * @param {string} url local path
     * @returns {Promise} A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const getLocalFile = (url) => {
        return executeRequestAsync(url, 'text/plain');
    };

    return {
        getLocalFile: getLocalFile,
        getExternalFile: getExternalFile,
    };
})();

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/* global URL, require, FileDownloadWrapper */
/**
 * The utility tool resolves preprocessor directives in filter content.
 *
 * Directives syntax:
 * !#if, !#endif - filters maintainers can use these conditions to supply different rules depending on the ad blocker type.
 * condition - just like in some popular programming languages, pre-processor conditions are based on constants declared by ad blockers. Ad blocker authors define on their own what exact constants do they declare.
 * !#include - this directive allows to include contents of a specified file into the filter.
 *
 * Condition constants should be declared in FilterCompilerConditionsConstants
 *
 * More details:
 * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/917
 */

// Override FileDownload object for node environment
if (typeof FileDownloadWrapper === 'undefined') {
    //noinspection JSAnnotator
    FileDownloadWrapper = require('./node/file-download-wrapper');
}

const FilterDownloader = (() => {
    "use strict";

    const CONDITION_DIRECTIVE_START = "!#if";
    const CONDITION_DIRECTIVE_END = "!#endif";

    const CONDITION_OPERATOR_NOT = "!";
    const CONDITION_OPERATOR_AND = "&&";
    const CONDITION_OPERATOR_OR = "||";
    const CONDITION_BRACKET_OPEN_CHAR = "(";
    const CONDITION_BRACKET_CLOSE_CHAR = ")";

    const INCLUDE_DIRECTIVE = "!#include";

    const REGEXP_ABSOLUTE_URL = /^([a-z]+:\/\/|\/\/)/i;

    /**
     * Checks brackets in string
     *
     * @param str
     */
    const checkBracketsBalance = (str) => {
        let depth = 0;
        for (let i in str) {
            if (str[i] === CONDITION_BRACKET_OPEN_CHAR) {
                // if the char is an opening parenthesis then we increase the depth
                depth++;
            } else if (str[i] === CONDITION_BRACKET_CLOSE_CHAR) {
                // if the char is an closing parenthesis then we decrease the depth
                depth--;
            }
            //  if the depth is negative we have a closing parenthesis
            //  before any matching opening parenthesis
            if (depth < 0) {
                return false;
            }
        }
        // If the depth is not null then a closing parenthesis is missing
        if (depth > 0) {
            return false;
        }

        return true;
    };

    /**
     * Finds end of condition block started with startIndex
     *
     * @param rules
     * @param startIndex
     */
    const findConditionEnd = (rules, startIndex) => {
        const stack = [];
        for (let j = startIndex; j < rules.length; j++) {
            let internalRule = rules[j];

            if (internalRule.startsWith(CONDITION_DIRECTIVE_START)) {
                stack.push(CONDITION_DIRECTIVE_START);

            } else if (internalRule.startsWith(CONDITION_DIRECTIVE_END)) {
                if (stack.length > 0) {
                    stack.pop();
                } else {
                    return j;
                }
            }
        }

        return -1;
    };

    /**
     * Resolves constant expression
     *
     * @param expression
     * @param definedProperties
     */
    const resolveConditionConstant = (expression, definedProperties) => {
        if (!expression) {
            throw new Error('Invalid directives: Empty condition');
        }

        let trim = expression.trim();
        return trim === "true" || definedProperties[trim];
    };

    /**
     * Calculates conditional expression
     *
     * @param expression
     * @param definedProperties
     */
    const resolveExpression = (expression, definedProperties) => {
        if (!expression) {
            throw new Error('Invalid directives: Empty condition');
        }

        expression = expression.trim();

        if (!checkBracketsBalance(expression)) {
            throw new Error('Invalid directives: Incorrect brackets: ' + expression);
        }

        //Replace bracketed expressions
        const openBracketIndex = expression.lastIndexOf(CONDITION_BRACKET_OPEN_CHAR);
        if (openBracketIndex !== -1) {
            const endBracketIndex = expression.indexOf(CONDITION_BRACKET_CLOSE_CHAR, openBracketIndex);
            const innerExpression = expression.substring(openBracketIndex + 1, endBracketIndex);
            const innerResult = resolveExpression(innerExpression, definedProperties);
            const resolvedInner = expression.substring(0, openBracketIndex) +
                    innerResult + expression.substring(endBracketIndex + 1);

            return resolveExpression(resolvedInner, definedProperties);
        }

        let result;

        // Resolve logical operators
        const indexOfAndOperator = expression.indexOf(CONDITION_OPERATOR_AND);
        const indexOfOrOperator = expression.indexOf(CONDITION_OPERATOR_OR);
        const indexOfNotOperator = expression.indexOf(CONDITION_OPERATOR_NOT);

        if (indexOfOrOperator !== -1) {
            result  = resolveExpression(expression.substring(0, indexOfOrOperator - 1), definedProperties) ||
                resolveExpression(expression.substring(indexOfOrOperator + CONDITION_OPERATOR_OR.length, expression.length), definedProperties);
        } else if (indexOfAndOperator !== -1) {
            result  = resolveExpression(expression.substring(0, indexOfAndOperator - 1), definedProperties) &&
                resolveExpression(expression.substring(indexOfAndOperator + CONDITION_OPERATOR_AND.length, expression.length), definedProperties);
        } else if (indexOfNotOperator === 0) {
            result = !resolveExpression(expression.substring(CONDITION_OPERATOR_NOT.length), definedProperties);
        } else {
            result = resolveConditionConstant(expression, definedProperties);
        }

        return result;
    };

    /**
     * Validates and resolves condition directive
     *
     * @param directive
     * @param definedProperties
     */
    const resolveCondition = (directive, definedProperties) => {
        const expression = directive.substring(CONDITION_DIRECTIVE_START.length).trim();

        return resolveExpression(expression, definedProperties);
    };

    /**
     * Resolves conditions directives
     *
     * @param rules
     * @param definedProperties
     */
    const resolveConditions = (rules, definedProperties) => {
        let result = [];

        for (let i = 0; i < rules.length; i++) {
            let rule = rules[i];

            if (rule.indexOf(CONDITION_DIRECTIVE_START) === 0) {
                let endLineIndex = findConditionEnd(rules, i + 1);
                if (endLineIndex === -1) {
                    throw new Error('Invalid directives: Condition end not found: ' + rule);
                }

                let conditionValue = resolveCondition(rule, definedProperties);
                if (conditionValue) {
                    let rulesUnderCondition = rules.slice(i + 1, endLineIndex);
                    // Resolve inner conditions in recursion
                    result = result.concat(resolveConditions(rulesUnderCondition, definedProperties));
                }

                // Skip to the end of block
                i = endLineIndex;
            } else if (rule.indexOf(CONDITION_DIRECTIVE_END) === 0) {
                // Found condition end without start
                throw new Error('Invalid directives: Found unexpected condition end: ' + rule);
            } else {
                result.push(rule);
            }
        }

        return result;
    };

    /**
     * Validates url to be the same origin with original filterUrl
     *
     * @param url
     * @param filterUrlOrigin
     */
    const validateUrl = function (url, filterUrlOrigin) {
        if (filterUrlOrigin) {
            if (REGEXP_ABSOLUTE_URL.test(url)) {

                // Include url is absolute
                const urlOrigin = parseURL(url).origin;
                const filterOrigin = parseURL(filterUrlOrigin).origin;
                if (urlOrigin !== filterOrigin) {
                    throw new Error('Include url is rejected with origin: ' + urlOrigin);
                }
            }
        }
    };

    /**
     * Validates and resolves include directive
     *
     * @param {string} line
     * @param {?string} filterUrlOrigin Filter file URL origin or null
     * @param {?object} definedProperties An object with the defined properties. These properties might be used in pre-processor directives (`#if`, etc)
     * @returns {Promise} A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const resolveInclude = function (line, filterOrigin, definedProperties) {
        if (line.indexOf(INCLUDE_DIRECTIVE) !== 0) {
            return Promise.resolve(line);
        } else {
            const url = decodeURI(line.substring(INCLUDE_DIRECTIVE.length).trim());
            validateUrl(url, filterOrigin);
            return downloadFilterRules(url, filterOrigin, definedProperties);
        }
    };

    /**
     * Resolves include directives
     *
     * @param {Array} rules   array of rules
     * @param {?string} filterUrlOrigin Filter file URL origin or null
     * @param {?object} definedProperties An object with the defined properties. These properties might be used in pre-processor directives (`#if`, etc)
     * @returns {Promise} A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const resolveIncludes = (rules, filterOrigin, definedProperties) => {
        const dfds = [];

        for (let rule of rules) {
            dfds.push(resolveInclude(rule, filterOrigin, definedProperties));
        }

        return Promise.all(dfds).then((values) => {
            let result = [];

            values.forEach(function (v) {
                if (Array.isArray(v)) {
                    result = result.concat(v);
                } else {
                    result.push(v);
                }
            });

            return result;
        });
    };

    /**
     * Compiles filter content
     *
     * @param {Array} rules Array of strings
     * @param {?string} filterUrlOrigin Filter file URL origin or null
     * @param {?object} definedProperties An object with the defined properties. These properties might be used in pre-processor directives (`#if`, etc)
     * @returns {Promise} A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const compile = (rules, filterOrigin, definedProperties) => {
        try {
            // Resolve 'if' conditions
            const resolvedConditionsResult = resolveConditions(rules, definedProperties);

            // Resolve 'includes' directives
            return resolveIncludes(resolvedConditionsResult, filterOrigin, definedProperties);
        } catch (ex) {
            return Promise.reject(ex);
        }
    };

    /**
     * Downloads filter rules from url
     *
     * @param {string} url Filter file URL
     * @param {?string} filterUrlOrigin Filter file URL origin or null
     * @param {?object} definedProperties An object with the defined properties. These properties might be used in pre-processor directives (`#if`, etc)
     * @returns {Promise} A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const downloadFilterRules = (url, filterUrlOrigin, definedProperties) => {
        if (REGEXP_ABSOLUTE_URL.test(url) || REGEXP_ABSOLUTE_URL.test(filterUrlOrigin)) {
            return externalDownload(url, filterUrlOrigin, definedProperties);
        } else {
            return getLocalFile(url, filterUrlOrigin, definedProperties);
        }
    };

    /**
     * Downloads filter rules from external url
     *
     * @param {string} url Filter file absolute URL or relative path
     * @param {?string} filterUrlOrigin Filter file URL origin or null
     * @param {?object} definedProperties An object with the defined properties. These properties might be used in pre-processor directives (`#if`, etc)
     * @returns {Promise} A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const externalDownload = (url, filterUrlOrigin, definedProperties) => {

        // getting absolute url for external file with relative url
        if (!REGEXP_ABSOLUTE_URL.test(url) && REGEXP_ABSOLUTE_URL.test(filterUrlOrigin)) {
            url = `${filterUrlOrigin}/${url}`;
        }

        return FileDownloadWrapper.getExternalFile(url, filterUrlOrigin, definedProperties).then((lines) => {
            // Filter origin could change in case url contains subdirectories
            // https://github.com/AdguardTeam/FiltersRegistry/pull/256
            filterUrlOrigin = getFilterUrlOrigin(url, null);
            return resolveIncludes(lines, filterUrlOrigin, definedProperties);
        });
    };

    /**
     * Get filter rules from local path
     *
     * @param {string} url local path
     * @param {?string} filterUrlOrigin origin path
     * @param {?object} definedProperties An object with the defined properties
     * @returns {Promise} A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const getLocalFile = (url, filterUrlOrigin, definedProperties) => {
        if (filterUrlOrigin) {
            url = `${filterUrlOrigin}/${url}`;
        }

        filterUrlOrigin = getFilterUrlOrigin(url, filterUrlOrigin);

        return FileDownloadWrapper.getLocalFile(url, filterUrlOrigin, definedProperties).then((lines) => {
            filterUrlOrigin = getFilterUrlOrigin(url, null);
            return resolveIncludes(lines, filterUrlOrigin, definedProperties);
        });
    };

    /**
     * Get the `filterUrlOrigin` from url for relative path resolve
     *
     * @param {string} url Filter file URL
     * @param {string|null} filterUrlOrigin  existing origin url
     * @returns {string} valid origin url
     */
    const getFilterUrlOrigin = (url, filterUrlOrigin) => {
        if (filterUrlOrigin) {
            return filterUrlOrigin;
        } else {
            return url.substring(0, url.lastIndexOf('/'));
        }
    };

    /**
     * Downloads a specified filter and interpretes all the pre-processor directives from there.
     *
     * @param {string} url Filter file URL
     * @param {Object} definedProperties An object with the defined properties. These properties might be used in pre-processor directives (`#if`, etc)
     * @returns {Promise} A promise that returns {string} with rules when if resolved and {Error} if rejected.
     */
    const download = (url, definedProperties) => {
        try {
            let filterUrlOrigin;
            if (url && REGEXP_ABSOLUTE_URL.test(url)) {
                filterUrlOrigin = getFilterUrlOrigin(url)
            }

            return downloadFilterRules(url, filterUrlOrigin, definedProperties);
        } catch (ex) {
            return Promise.reject(ex);
        }
    };

    /**
     * Parse url
     *
     * @param {string} url
     * @returns {object}  parsed url data
     */
    const parseURL = (url) => {
        if (typeof URL !== 'undefined') {
            return new URL(url);
        } else {
            let URL = require('url').URL;
            return new URL(url);
        }
    };

    return {
        compile: compile,
        download: download,
        resolveConditions: resolveConditions,
        resolveIncludes: resolveIncludes,
        getFilterUrlOrigin: getFilterUrlOrigin
    };
})();

if (typeof module !== 'undefined' && module.exports) {
    module.exports = FilterDownloader;
}

;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory();
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define([], factory);
	}
	else {
		// Global (browser)
		root.CryptoJS = factory();
	}
}(this, function () {

	/**
	 * CryptoJS core components.
	 */
	var CryptoJS = CryptoJS || (function (Math, undefined) {
	    /*
	     * Local polyfil of Object.create
	     */
	    var create = Object.create || (function () {
	        function F() {};

	        return function (obj) {
	            var subtype;

	            F.prototype = obj;

	            subtype = new F();

	            F.prototype = null;

	            return subtype;
	        };
	    }())

	    /**
	     * CryptoJS namespace.
	     */
	    var C = {};

	    /**
	     * Library namespace.
	     */
	    var C_lib = C.lib = {};

	    /**
	     * Base object for prototypal inheritance.
	     */
	    var Base = C_lib.Base = (function () {


	        return {
	            /**
	             * Creates a new object that inherits from this object.
	             *
	             * @param {Object} overrides Properties to copy into the new object.
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         field: 'value',
	             *
	             *         method: function () {
	             *         }
	             *     });
	             */
	            extend: function (overrides) {
	                // Spawn
	                var subtype = create(this);

	                // Augment
	                if (overrides) {
	                    subtype.mixIn(overrides);
	                }

	                // Create default initializer
	                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {
	                    subtype.init = function () {
	                        subtype.$super.init.apply(this, arguments);
	                    };
	                }

	                // Initializer's prototype is the subtype object
	                subtype.init.prototype = subtype;

	                // Reference supertype
	                subtype.$super = this;

	                return subtype;
	            },

	            /**
	             * Extends this object and runs the init method.
	             * Arguments to create() will be passed to init().
	             *
	             * @return {Object} The new object.
	             *
	             * @static
	             *
	             * @example
	             *
	             *     var instance = MyType.create();
	             */
	            create: function () {
	                var instance = this.extend();
	                instance.init.apply(instance, arguments);

	                return instance;
	            },

	            /**
	             * Initializes a newly created object.
	             * Override this method to add some logic when your objects are created.
	             *
	             * @example
	             *
	             *     var MyType = CryptoJS.lib.Base.extend({
	             *         init: function () {
	             *             // ...
	             *         }
	             *     });
	             */
	            init: function () {
	            },

	            /**
	             * Copies properties into this object.
	             *
	             * @param {Object} properties The properties to mix in.
	             *
	             * @example
	             *
	             *     MyType.mixIn({
	             *         field: 'value'
	             *     });
	             */
	            mixIn: function (properties) {
	                for (var propertyName in properties) {
	                    if (properties.hasOwnProperty(propertyName)) {
	                        this[propertyName] = properties[propertyName];
	                    }
	                }

	                // IE won't copy toString using the loop above
	                if (properties.hasOwnProperty('toString')) {
	                    this.toString = properties.toString;
	                }
	            },

	            /**
	             * Creates a copy of this object.
	             *
	             * @return {Object} The clone.
	             *
	             * @example
	             *
	             *     var clone = instance.clone();
	             */
	            clone: function () {
	                return this.init.prototype.extend(this);
	            }
	        };
	    }());

	    /**
	     * An array of 32-bit words.
	     *
	     * @property {Array} words The array of 32-bit words.
	     * @property {number} sigBytes The number of significant bytes in this word array.
	     */
	    var WordArray = C_lib.WordArray = Base.extend({
	        /**
	         * Initializes a newly created word array.
	         *
	         * @param {Array} words (Optional) An array of 32-bit words.
	         * @param {number} sigBytes (Optional) The number of significant bytes in the words.
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.create();
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);
	         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);
	         */
	        init: function (words, sigBytes) {
	            words = this.words = words || [];

	            if (sigBytes != undefined) {
	                this.sigBytes = sigBytes;
	            } else {
	                this.sigBytes = words.length * 4;
	            }
	        },

	        /**
	         * Converts this word array to a string.
	         *
	         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex
	         *
	         * @return {string} The stringified word array.
	         *
	         * @example
	         *
	         *     var string = wordArray + '';
	         *     var string = wordArray.toString();
	         *     var string = wordArray.toString(CryptoJS.enc.Utf8);
	         */
	        toString: function (encoder) {
	            return (encoder || Hex).stringify(this);
	        },

	        /**
	         * Concatenates a word array to this word array.
	         *
	         * @param {WordArray} wordArray The word array to append.
	         *
	         * @return {WordArray} This word array.
	         *
	         * @example
	         *
	         *     wordArray1.concat(wordArray2);
	         */
	        concat: function (wordArray) {
	            // Shortcuts
	            var thisWords = this.words;
	            var thatWords = wordArray.words;
	            var thisSigBytes = this.sigBytes;
	            var thatSigBytes = wordArray.sigBytes;

	            // Clamp excess bits
	            this.clamp();

	            // Concat
	            if (thisSigBytes % 4) {
	                // Copy one byte at a time
	                for (var i = 0; i < thatSigBytes; i++) {
	                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);
	                }
	            } else {
	                // Copy one word at a time
	                for (var i = 0; i < thatSigBytes; i += 4) {
	                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];
	                }
	            }
	            this.sigBytes += thatSigBytes;

	            // Chainable
	            return this;
	        },

	        /**
	         * Removes insignificant bits.
	         *
	         * @example
	         *
	         *     wordArray.clamp();
	         */
	        clamp: function () {
	            // Shortcuts
	            var words = this.words;
	            var sigBytes = this.sigBytes;

	            // Clamp
	            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);
	            words.length = Math.ceil(sigBytes / 4);
	        },

	        /**
	         * Creates a copy of this word array.
	         *
	         * @return {WordArray} The clone.
	         *
	         * @example
	         *
	         *     var clone = wordArray.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone.words = this.words.slice(0);

	            return clone;
	        },

	        /**
	         * Creates a word array filled with random bytes.
	         *
	         * @param {number} nBytes The number of random bytes to generate.
	         *
	         * @return {WordArray} The random word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.lib.WordArray.random(16);
	         */
	        random: function (nBytes) {
	            var words = [];

	            var r = (function (m_w) {
	                var m_w = m_w;
	                var m_z = 0x3ade68b1;
	                var mask = 0xffffffff;

	                return function () {
	                    m_z = (0x9069 * (m_z & 0xFFFF) + (m_z >> 0x10)) & mask;
	                    m_w = (0x4650 * (m_w & 0xFFFF) + (m_w >> 0x10)) & mask;
	                    var result = ((m_z << 0x10) + m_w) & mask;
	                    result /= 0x100000000;
	                    result += 0.5;
	                    return result * (Math.random() > .5 ? 1 : -1);
	                }
	            });

	            for (var i = 0, rcache; i < nBytes; i += 4) {
	                var _r = r((rcache || Math.random()) * 0x100000000);

	                rcache = _r() * 0x3ade67b7;
	                words.push((_r() * 0x100000000) | 0);
	            }

	            return new WordArray.init(words, nBytes);
	        }
	    });

	    /**
	     * Encoder namespace.
	     */
	    var C_enc = C.enc = {};

	    /**
	     * Hex encoding strategy.
	     */
	    var Hex = C_enc.Hex = {
	        /**
	         * Converts a word array to a hex string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The hex string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var hexChars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                hexChars.push((bite >>> 4).toString(16));
	                hexChars.push((bite & 0x0f).toString(16));
	            }

	            return hexChars.join('');
	        },

	        /**
	         * Converts a hex string to a word array.
	         *
	         * @param {string} hexStr The hex string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);
	         */
	        parse: function (hexStr) {
	            // Shortcut
	            var hexStrLength = hexStr.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < hexStrLength; i += 2) {
	                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);
	            }

	            return new WordArray.init(words, hexStrLength / 2);
	        }
	    };

	    /**
	     * Latin1 encoding strategy.
	     */
	    var Latin1 = C_enc.Latin1 = {
	        /**
	         * Converts a word array to a Latin1 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The Latin1 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            // Shortcuts
	            var words = wordArray.words;
	            var sigBytes = wordArray.sigBytes;

	            // Convert
	            var latin1Chars = [];
	            for (var i = 0; i < sigBytes; i++) {
	                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;
	                latin1Chars.push(String.fromCharCode(bite));
	            }

	            return latin1Chars.join('');
	        },

	        /**
	         * Converts a Latin1 string to a word array.
	         *
	         * @param {string} latin1Str The Latin1 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);
	         */
	        parse: function (latin1Str) {
	            // Shortcut
	            var latin1StrLength = latin1Str.length;

	            // Convert
	            var words = [];
	            for (var i = 0; i < latin1StrLength; i++) {
	                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);
	            }

	            return new WordArray.init(words, latin1StrLength);
	        }
	    };

	    /**
	     * UTF-8 encoding strategy.
	     */
	    var Utf8 = C_enc.Utf8 = {
	        /**
	         * Converts a word array to a UTF-8 string.
	         *
	         * @param {WordArray} wordArray The word array.
	         *
	         * @return {string} The UTF-8 string.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);
	         */
	        stringify: function (wordArray) {
	            try {
	                return decodeURIComponent(escape(Latin1.stringify(wordArray)));
	            } catch (e) {
	                throw new Error('Malformed UTF-8 data');
	            }
	        },

	        /**
	         * Converts a UTF-8 string to a word array.
	         *
	         * @param {string} utf8Str The UTF-8 string.
	         *
	         * @return {WordArray} The word array.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);
	         */
	        parse: function (utf8Str) {
	            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));
	        }
	    };

	    /**
	     * Abstract buffered block algorithm template.
	     *
	     * The property blockSize must be implemented in a concrete subtype.
	     *
	     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0
	     */
	    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({
	        /**
	         * Resets this block algorithm's data buffer to its initial state.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm.reset();
	         */
	        reset: function () {
	            // Initial values
	            this._data = new WordArray.init();
	            this._nDataBytes = 0;
	        },

	        /**
	         * Adds new data to this block algorithm's buffer.
	         *
	         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.
	         *
	         * @example
	         *
	         *     bufferedBlockAlgorithm._append('data');
	         *     bufferedBlockAlgorithm._append(wordArray);
	         */
	        _append: function (data) {
	            // Convert string to WordArray, else assume WordArray already
	            if (typeof data == 'string') {
	                data = Utf8.parse(data);
	            }

	            // Append
	            this._data.concat(data);
	            this._nDataBytes += data.sigBytes;
	        },

	        /**
	         * Processes available data blocks.
	         *
	         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.
	         *
	         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.
	         *
	         * @return {WordArray} The processed data.
	         *
	         * @example
	         *
	         *     var processedData = bufferedBlockAlgorithm._process();
	         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');
	         */
	        _process: function (doFlush) {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;
	            var dataSigBytes = data.sigBytes;
	            var blockSize = this.blockSize;
	            var blockSizeBytes = blockSize * 4;

	            // Count blocks ready
	            var nBlocksReady = dataSigBytes / blockSizeBytes;
	            if (doFlush) {
	                // Round up to include partial blocks
	                nBlocksReady = Math.ceil(nBlocksReady);
	            } else {
	                // Round down to include only full blocks,
	                // less the number of blocks that must remain in the buffer
	                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);
	            }

	            // Count words ready
	            var nWordsReady = nBlocksReady * blockSize;

	            // Count bytes ready
	            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);

	            // Process blocks
	            if (nWordsReady) {
	                for (var offset = 0; offset < nWordsReady; offset += blockSize) {
	                    // Perform concrete-algorithm logic
	                    this._doProcessBlock(dataWords, offset);
	                }

	                // Remove processed words
	                var processedWords = dataWords.splice(0, nWordsReady);
	                data.sigBytes -= nBytesReady;
	            }

	            // Return processed words
	            return new WordArray.init(processedWords, nBytesReady);
	        },

	        /**
	         * Creates a copy of this object.
	         *
	         * @return {Object} The clone.
	         *
	         * @example
	         *
	         *     var clone = bufferedBlockAlgorithm.clone();
	         */
	        clone: function () {
	            var clone = Base.clone.call(this);
	            clone._data = this._data.clone();

	            return clone;
	        },

	        _minBufferSize: 0
	    });

	    /**
	     * Abstract hasher template.
	     *
	     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)
	     */
	    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({
	        /**
	         * Configuration options.
	         */
	        cfg: Base.extend(),

	        /**
	         * Initializes a newly created hasher.
	         *
	         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.
	         *
	         * @example
	         *
	         *     var hasher = CryptoJS.algo.SHA256.create();
	         */
	        init: function (cfg) {
	            // Apply config defaults
	            this.cfg = this.cfg.extend(cfg);

	            // Set initial values
	            this.reset();
	        },

	        /**
	         * Resets this hasher to its initial state.
	         *
	         * @example
	         *
	         *     hasher.reset();
	         */
	        reset: function () {
	            // Reset data buffer
	            BufferedBlockAlgorithm.reset.call(this);

	            // Perform concrete-hasher logic
	            this._doReset();
	        },

	        /**
	         * Updates this hasher with a message.
	         *
	         * @param {WordArray|string} messageUpdate The message to append.
	         *
	         * @return {Hasher} This hasher.
	         *
	         * @example
	         *
	         *     hasher.update('message');
	         *     hasher.update(wordArray);
	         */
	        update: function (messageUpdate) {
	            // Append
	            this._append(messageUpdate);

	            // Update the hash
	            this._process();

	            // Chainable
	            return this;
	        },

	        /**
	         * Finalizes the hash computation.
	         * Note that the finalize operation is effectively a destructive, read-once operation.
	         *
	         * @param {WordArray|string} messageUpdate (Optional) A final message update.
	         *
	         * @return {WordArray} The hash.
	         *
	         * @example
	         *
	         *     var hash = hasher.finalize();
	         *     var hash = hasher.finalize('message');
	         *     var hash = hasher.finalize(wordArray);
	         */
	        finalize: function (messageUpdate) {
	            // Final message update
	            if (messageUpdate) {
	                this._append(messageUpdate);
	            }

	            // Perform concrete-hasher logic
	            var hash = this._doFinalize();

	            return hash;
	        },

	        blockSize: 512/32,

	        /**
	         * Creates a shortcut function to a hasher's object interface.
	         *
	         * @param {Hasher} hasher The hasher to create a helper for.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);
	         */
	        _createHelper: function (hasher) {
	            return function (message, cfg) {
	                return new hasher.init(cfg).finalize(message);
	            };
	        },

	        /**
	         * Creates a shortcut function to the HMAC's object interface.
	         *
	         * @param {Hasher} hasher The hasher to use in this HMAC helper.
	         *
	         * @return {Function} The shortcut function.
	         *
	         * @static
	         *
	         * @example
	         *
	         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);
	         */
	        _createHmacHelper: function (hasher) {
	            return function (message, key) {
	                return new C_algo.HMAC.init(hasher, key).finalize(message);
	            };
	        }
	    });

	    /**
	     * Algorithm namespace.
	     */
	    var C_algo = C.algo = {};

	    return C;
	}(Math));


	return CryptoJS;

}));
;(function (root, factory) {
	if (typeof exports === "object") {
		// CommonJS
		module.exports = exports = factory(require("./core"));
	}
	else if (typeof define === "function" && define.amd) {
		// AMD
		define(["./core"], factory);
	}
	else {
		// Global (browser)
		factory(root.CryptoJS);
	}
}(this, function (CryptoJS) {

	(function (Math) {
	    // Shortcuts
	    var C = CryptoJS;
	    var C_lib = C.lib;
	    var WordArray = C_lib.WordArray;
	    var Hasher = C_lib.Hasher;
	    var C_algo = C.algo;

	    // Constants table
	    var T = [];

	    // Compute constants
	    (function () {
	        for (var i = 0; i < 64; i++) {
	            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;
	        }
	    }());

	    /**
	     * MD5 hash algorithm.
	     */
	    var MD5 = C_algo.MD5 = Hasher.extend({
	        _doReset: function () {
	            this._hash = new WordArray.init([
	                0x67452301, 0xefcdab89,
	                0x98badcfe, 0x10325476
	            ]);
	        },

	        _doProcessBlock: function (M, offset) {
	            // Swap endian
	            for (var i = 0; i < 16; i++) {
	                // Shortcuts
	                var offset_i = offset + i;
	                var M_offset_i = M[offset_i];

	                M[offset_i] = (
	                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |
	                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)
	                );
	            }

	            // Shortcuts
	            var H = this._hash.words;

	            var M_offset_0  = M[offset + 0];
	            var M_offset_1  = M[offset + 1];
	            var M_offset_2  = M[offset + 2];
	            var M_offset_3  = M[offset + 3];
	            var M_offset_4  = M[offset + 4];
	            var M_offset_5  = M[offset + 5];
	            var M_offset_6  = M[offset + 6];
	            var M_offset_7  = M[offset + 7];
	            var M_offset_8  = M[offset + 8];
	            var M_offset_9  = M[offset + 9];
	            var M_offset_10 = M[offset + 10];
	            var M_offset_11 = M[offset + 11];
	            var M_offset_12 = M[offset + 12];
	            var M_offset_13 = M[offset + 13];
	            var M_offset_14 = M[offset + 14];
	            var M_offset_15 = M[offset + 15];

	            // Working varialbes
	            var a = H[0];
	            var b = H[1];
	            var c = H[2];
	            var d = H[3];

	            // Computation
	            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);
	            d = FF(d, a, b, c, M_offset_1,  12, T[1]);
	            c = FF(c, d, a, b, M_offset_2,  17, T[2]);
	            b = FF(b, c, d, a, M_offset_3,  22, T[3]);
	            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);
	            d = FF(d, a, b, c, M_offset_5,  12, T[5]);
	            c = FF(c, d, a, b, M_offset_6,  17, T[6]);
	            b = FF(b, c, d, a, M_offset_7,  22, T[7]);
	            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);
	            d = FF(d, a, b, c, M_offset_9,  12, T[9]);
	            c = FF(c, d, a, b, M_offset_10, 17, T[10]);
	            b = FF(b, c, d, a, M_offset_11, 22, T[11]);
	            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);
	            d = FF(d, a, b, c, M_offset_13, 12, T[13]);
	            c = FF(c, d, a, b, M_offset_14, 17, T[14]);
	            b = FF(b, c, d, a, M_offset_15, 22, T[15]);

	            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);
	            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);
	            c = GG(c, d, a, b, M_offset_11, 14, T[18]);
	            b = GG(b, c, d, a, M_offset_0,  20, T[19]);
	            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);
	            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);
	            c = GG(c, d, a, b, M_offset_15, 14, T[22]);
	            b = GG(b, c, d, a, M_offset_4,  20, T[23]);
	            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);
	            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);
	            c = GG(c, d, a, b, M_offset_3,  14, T[26]);
	            b = GG(b, c, d, a, M_offset_8,  20, T[27]);
	            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);
	            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);
	            c = GG(c, d, a, b, M_offset_7,  14, T[30]);
	            b = GG(b, c, d, a, M_offset_12, 20, T[31]);

	            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);
	            d = HH(d, a, b, c, M_offset_8,  11, T[33]);
	            c = HH(c, d, a, b, M_offset_11, 16, T[34]);
	            b = HH(b, c, d, a, M_offset_14, 23, T[35]);
	            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);
	            d = HH(d, a, b, c, M_offset_4,  11, T[37]);
	            c = HH(c, d, a, b, M_offset_7,  16, T[38]);
	            b = HH(b, c, d, a, M_offset_10, 23, T[39]);
	            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);
	            d = HH(d, a, b, c, M_offset_0,  11, T[41]);
	            c = HH(c, d, a, b, M_offset_3,  16, T[42]);
	            b = HH(b, c, d, a, M_offset_6,  23, T[43]);
	            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);
	            d = HH(d, a, b, c, M_offset_12, 11, T[45]);
	            c = HH(c, d, a, b, M_offset_15, 16, T[46]);
	            b = HH(b, c, d, a, M_offset_2,  23, T[47]);

	            a = II(a, b, c, d, M_offset_0,  6,  T[48]);
	            d = II(d, a, b, c, M_offset_7,  10, T[49]);
	            c = II(c, d, a, b, M_offset_14, 15, T[50]);
	            b = II(b, c, d, a, M_offset_5,  21, T[51]);
	            a = II(a, b, c, d, M_offset_12, 6,  T[52]);
	            d = II(d, a, b, c, M_offset_3,  10, T[53]);
	            c = II(c, d, a, b, M_offset_10, 15, T[54]);
	            b = II(b, c, d, a, M_offset_1,  21, T[55]);
	            a = II(a, b, c, d, M_offset_8,  6,  T[56]);
	            d = II(d, a, b, c, M_offset_15, 10, T[57]);
	            c = II(c, d, a, b, M_offset_6,  15, T[58]);
	            b = II(b, c, d, a, M_offset_13, 21, T[59]);
	            a = II(a, b, c, d, M_offset_4,  6,  T[60]);
	            d = II(d, a, b, c, M_offset_11, 10, T[61]);
	            c = II(c, d, a, b, M_offset_2,  15, T[62]);
	            b = II(b, c, d, a, M_offset_9,  21, T[63]);

	            // Intermediate hash value
	            H[0] = (H[0] + a) | 0;
	            H[1] = (H[1] + b) | 0;
	            H[2] = (H[2] + c) | 0;
	            H[3] = (H[3] + d) | 0;
	        },

	        _doFinalize: function () {
	            // Shortcuts
	            var data = this._data;
	            var dataWords = data.words;

	            var nBitsTotal = this._nDataBytes * 8;
	            var nBitsLeft = data.sigBytes * 8;

	            // Add padding
	            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);

	            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);
	            var nBitsTotalL = nBitsTotal;
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (
	                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)
	            );
	            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (
	                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |
	                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)
	            );

	            data.sigBytes = (dataWords.length + 1) * 4;

	            // Hash final blocks
	            this._process();

	            // Shortcuts
	            var hash = this._hash;
	            var H = hash.words;

	            // Swap endian
	            for (var i = 0; i < 4; i++) {
	                // Shortcut
	                var H_i = H[i];

	                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |
	                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);
	            }

	            // Return final computed hash
	            return hash;
	        },

	        clone: function () {
	            var clone = Hasher.clone.call(this);
	            clone._hash = this._hash.clone();

	            return clone;
	        }
	    });

	    function FF(a, b, c, d, x, s, t) {
	        var n = a + ((b & c) | (~b & d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function GG(a, b, c, d, x, s, t) {
	        var n = a + ((b & d) | (c & ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function HH(a, b, c, d, x, s, t) {
	        var n = a + (b ^ c ^ d) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    function II(a, b, c, d, x, s, t) {
	        var n = a + (c ^ (b | ~d)) + x + t;
	        return ((n << s) | (n >>> (32 - s))) + b;
	    }

	    /**
	     * Shortcut function to the hasher's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     *
	     * @return {WordArray} The hash.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hash = CryptoJS.MD5('message');
	     *     var hash = CryptoJS.MD5(wordArray);
	     */
	    C.MD5 = Hasher._createHelper(MD5);

	    /**
	     * Shortcut function to the HMAC's object interface.
	     *
	     * @param {WordArray|string} message The message to hash.
	     * @param {WordArray|string} key The secret key.
	     *
	     * @return {WordArray} The HMAC.
	     *
	     * @static
	     *
	     * @example
	     *
	     *     var hmac = CryptoJS.HmacMD5(message, key);
	     */
	    C.HmacMD5 = Hasher._createHmacHelper(MD5);
	}(Math));


	return CryptoJS.MD5;

}));

/**
 * AdGuard Scriptlets
 * Version 1.3.0
 */

var Redirects = (function () {
  function _defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  }

  var defineProperty = _defineProperty;

  function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  }

  var classCallCheck = _classCallCheck;

  function _defineProperties(target, props) {
    for (var i = 0; i < props.length; i++) {
      var descriptor = props[i];
      descriptor.enumerable = descriptor.enumerable || false;
      descriptor.configurable = true;
      if ("value" in descriptor) descriptor.writable = true;
      Object.defineProperty(target, descriptor.key, descriptor);
    }
  }

  function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    return Constructor;
  }

  var createClass = _createClass;

  function isNothing(subject) {
    return typeof subject === 'undefined' || subject === null;
  }

  function isObject(subject) {
    return typeof subject === 'object' && subject !== null;
  }

  function toArray(sequence) {
    if (Array.isArray(sequence)) return sequence;else if (isNothing(sequence)) return [];
    return [sequence];
  }

  function extend(target, source) {
    var index, length, key, sourceKeys;

    if (source) {
      sourceKeys = Object.keys(source);

      for (index = 0, length = sourceKeys.length; index < length; index += 1) {
        key = sourceKeys[index];
        target[key] = source[key];
      }
    }

    return target;
  }

  function repeat(string, count) {
    var result = '',
        cycle;

    for (cycle = 0; cycle < count; cycle += 1) {
      result += string;
    }

    return result;
  }

  function isNegativeZero(number) {
    return number === 0 && Number.NEGATIVE_INFINITY === 1 / number;
  }

  var isNothing_1 = isNothing;
  var isObject_1 = isObject;
  var toArray_1 = toArray;
  var repeat_1 = repeat;
  var isNegativeZero_1 = isNegativeZero;
  var extend_1 = extend;
  var common = {
    isNothing: isNothing_1,
    isObject: isObject_1,
    toArray: toArray_1,
    repeat: repeat_1,
    isNegativeZero: isNegativeZero_1,
    extend: extend_1
  };

  // YAML error class. http://stackoverflow.com/questions/8458984

  function YAMLException(reason, mark) {
    // Super constructor
    Error.call(this);
    this.name = 'YAMLException';
    this.reason = reason;
    this.mark = mark;
    this.message = (this.reason || '(unknown reason)') + (this.mark ? ' ' + this.mark.toString() : ''); // Include stack trace in error object

    if (Error.captureStackTrace) {
      // Chrome and NodeJS
      Error.captureStackTrace(this, this.constructor);
    } else {
      // FF, IE 10+ and Safari 6+. Fallback for others
      this.stack = new Error().stack || '';
    }
  } // Inherit from Error


  YAMLException.prototype = Object.create(Error.prototype);
  YAMLException.prototype.constructor = YAMLException;

  YAMLException.prototype.toString = function toString(compact) {
    var result = this.name + ': ';
    result += this.reason || '(unknown reason)';

    if (!compact && this.mark) {
      result += ' ' + this.mark.toString();
    }

    return result;
  };

  var exception = YAMLException;

  function Mark(name, buffer, position, line, column) {
    this.name = name;
    this.buffer = buffer;
    this.position = position;
    this.line = line;
    this.column = column;
  }

  Mark.prototype.getSnippet = function getSnippet(indent, maxLength) {
    var head, start, tail, end, snippet;
    if (!this.buffer) return null;
    indent = indent || 4;
    maxLength = maxLength || 75;
    head = '';
    start = this.position;

    while (start > 0 && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(start - 1)) === -1) {
      start -= 1;

      if (this.position - start > maxLength / 2 - 1) {
        head = ' ... ';
        start += 5;
        break;
      }
    }

    tail = '';
    end = this.position;

    while (end < this.buffer.length && "\0\r\n\x85\u2028\u2029".indexOf(this.buffer.charAt(end)) === -1) {
      end += 1;

      if (end - this.position > maxLength / 2 - 1) {
        tail = ' ... ';
        end -= 5;
        break;
      }
    }

    snippet = this.buffer.slice(start, end);
    return common.repeat(' ', indent) + head + snippet + tail + '\n' + common.repeat(' ', indent + this.position - start + head.length) + '^';
  };

  Mark.prototype.toString = function toString(compact) {
    var snippet,
        where = '';

    if (this.name) {
      where += 'in "' + this.name + '" ';
    }

    where += 'at line ' + (this.line + 1) + ', column ' + (this.column + 1);

    if (!compact) {
      snippet = this.getSnippet();

      if (snippet) {
        where += ':\n' + snippet;
      }
    }

    return where;
  };

  var mark = Mark;

  var TYPE_CONSTRUCTOR_OPTIONS = ['kind', 'resolve', 'construct', 'instanceOf', 'predicate', 'represent', 'defaultStyle', 'styleAliases'];
  var YAML_NODE_KINDS = ['scalar', 'sequence', 'mapping'];

  function compileStyleAliases(map) {
    var result = {};

    if (map !== null) {
      Object.keys(map).forEach(function (style) {
        map[style].forEach(function (alias) {
          result[String(alias)] = style;
        });
      });
    }

    return result;
  }

  function Type(tag, options) {
    options = options || {};
    Object.keys(options).forEach(function (name) {
      if (TYPE_CONSTRUCTOR_OPTIONS.indexOf(name) === -1) {
        throw new exception('Unknown option "' + name + '" is met in definition of "' + tag + '" YAML type.');
      }
    }); // TODO: Add tag format check.

    this.tag = tag;
    this.kind = options['kind'] || null;

    this.resolve = options['resolve'] || function () {
      return true;
    };

    this.construct = options['construct'] || function (data) {
      return data;
    };

    this.instanceOf = options['instanceOf'] || null;
    this.predicate = options['predicate'] || null;
    this.represent = options['represent'] || null;
    this.defaultStyle = options['defaultStyle'] || null;
    this.styleAliases = compileStyleAliases(options['styleAliases'] || null);

    if (YAML_NODE_KINDS.indexOf(this.kind) === -1) {
      throw new exception('Unknown kind "' + this.kind + '" is specified for "' + tag + '" YAML type.');
    }
  }

  var type = Type;

  /*eslint-disable max-len*/


  function compileList(schema, name, result) {
    var exclude = [];
    schema.include.forEach(function (includedSchema) {
      result = compileList(includedSchema, name, result);
    });
    schema[name].forEach(function (currentType) {
      result.forEach(function (previousType, previousIndex) {
        if (previousType.tag === currentType.tag && previousType.kind === currentType.kind) {
          exclude.push(previousIndex);
        }
      });
      result.push(currentType);
    });
    return result.filter(function (type, index) {
      return exclude.indexOf(index) === -1;
    });
  }

  function compileMap()
  /* lists... */
  {
    var result = {
      scalar: {},
      sequence: {},
      mapping: {},
      fallback: {}
    },
        index,
        length;

    function collectType(type) {
      result[type.kind][type.tag] = result['fallback'][type.tag] = type;
    }

    for (index = 0, length = arguments.length; index < length; index += 1) {
      arguments[index].forEach(collectType);
    }

    return result;
  }

  function Schema(definition) {
    this.include = definition.include || [];
    this.implicit = definition.implicit || [];
    this.explicit = definition.explicit || [];
    this.implicit.forEach(function (type) {
      if (type.loadKind && type.loadKind !== 'scalar') {
        throw new exception('There is a non-scalar type in the implicit list of a schema. Implicit resolving of such types is not supported.');
      }
    });
    this.compiledImplicit = compileList(this, 'implicit', []);
    this.compiledExplicit = compileList(this, 'explicit', []);
    this.compiledTypeMap = compileMap(this.compiledImplicit, this.compiledExplicit);
  }

  Schema.DEFAULT = null;

  Schema.create = function createSchema() {
    var schemas, types;

    switch (arguments.length) {
      case 1:
        schemas = Schema.DEFAULT;
        types = arguments[0];
        break;

      case 2:
        schemas = arguments[0];
        types = arguments[1];
        break;

      default:
        throw new exception('Wrong number of arguments for Schema.create function');
    }

    schemas = common.toArray(schemas);
    types = common.toArray(types);

    if (!schemas.every(function (schema) {
      return schema instanceof Schema;
    })) {
      throw new exception('Specified list of super schemas (or a single Schema object) contains a non-Schema object.');
    }

    if (!types.every(function (type$1) {
      return type$1 instanceof type;
    })) {
      throw new exception('Specified list of YAML types (or a single Type object) contains a non-Type object.');
    }

    return new Schema({
      include: schemas,
      explicit: types
    });
  };

  var schema = Schema;

  var str = new type('tag:yaml.org,2002:str', {
    kind: 'scalar',
    construct: function construct(data) {
      return data !== null ? data : '';
    }
  });

  var seq = new type('tag:yaml.org,2002:seq', {
    kind: 'sequence',
    construct: function construct(data) {
      return data !== null ? data : [];
    }
  });

  var map = new type('tag:yaml.org,2002:map', {
    kind: 'mapping',
    construct: function construct(data) {
      return data !== null ? data : {};
    }
  });

  var failsafe = new schema({
    explicit: [str, seq, map]
  });

  function resolveYamlNull(data) {
    if (data === null) return true;
    var max = data.length;
    return max === 1 && data === '~' || max === 4 && (data === 'null' || data === 'Null' || data === 'NULL');
  }

  function constructYamlNull() {
    return null;
  }

  function isNull(object) {
    return object === null;
  }

  var _null = new type('tag:yaml.org,2002:null', {
    kind: 'scalar',
    resolve: resolveYamlNull,
    construct: constructYamlNull,
    predicate: isNull,
    represent: {
      canonical: function canonical() {
        return '~';
      },
      lowercase: function lowercase() {
        return 'null';
      },
      uppercase: function uppercase() {
        return 'NULL';
      },
      camelcase: function camelcase() {
        return 'Null';
      }
    },
    defaultStyle: 'lowercase'
  });

  function resolveYamlBoolean(data) {
    if (data === null) return false;
    var max = data.length;
    return max === 4 && (data === 'true' || data === 'True' || data === 'TRUE') || max === 5 && (data === 'false' || data === 'False' || data === 'FALSE');
  }

  function constructYamlBoolean(data) {
    return data === 'true' || data === 'True' || data === 'TRUE';
  }

  function isBoolean(object) {
    return Object.prototype.toString.call(object) === '[object Boolean]';
  }

  var bool = new type('tag:yaml.org,2002:bool', {
    kind: 'scalar',
    resolve: resolveYamlBoolean,
    construct: constructYamlBoolean,
    predicate: isBoolean,
    represent: {
      lowercase: function lowercase(object) {
        return object ? 'true' : 'false';
      },
      uppercase: function uppercase(object) {
        return object ? 'TRUE' : 'FALSE';
      },
      camelcase: function camelcase(object) {
        return object ? 'True' : 'False';
      }
    },
    defaultStyle: 'lowercase'
  });

  function isHexCode(c) {
    return 0x30
    /* 0 */
    <= c && c <= 0x39
    /* 9 */
    || 0x41
    /* A */
    <= c && c <= 0x46
    /* F */
    || 0x61
    /* a */
    <= c && c <= 0x66
    /* f */
    ;
  }

  function isOctCode(c) {
    return 0x30
    /* 0 */
    <= c && c <= 0x37
    /* 7 */
    ;
  }

  function isDecCode(c) {
    return 0x30
    /* 0 */
    <= c && c <= 0x39
    /* 9 */
    ;
  }

  function resolveYamlInteger(data) {
    if (data === null) return false;
    var max = data.length,
        index = 0,
        hasDigits = false,
        ch;
    if (!max) return false;
    ch = data[index]; // sign

    if (ch === '-' || ch === '+') {
      ch = data[++index];
    }

    if (ch === '0') {
      // 0
      if (index + 1 === max) return true;
      ch = data[++index]; // base 2, base 8, base 16

      if (ch === 'b') {
        // base 2
        index++;

        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (ch !== '0' && ch !== '1') return false;
          hasDigits = true;
        }

        return hasDigits && ch !== '_';
      }

      if (ch === 'x') {
        // base 16
        index++;

        for (; index < max; index++) {
          ch = data[index];
          if (ch === '_') continue;
          if (!isHexCode(data.charCodeAt(index))) return false;
          hasDigits = true;
        }

        return hasDigits && ch !== '_';
      } // base 8


      for (; index < max; index++) {
        ch = data[index];
        if (ch === '_') continue;
        if (!isOctCode(data.charCodeAt(index))) return false;
        hasDigits = true;
      }

      return hasDigits && ch !== '_';
    } // base 10 (except 0) or base 60
    // value should not start with `_`;


    if (ch === '_') return false;

    for (; index < max; index++) {
      ch = data[index];
      if (ch === '_') continue;
      if (ch === ':') break;

      if (!isDecCode(data.charCodeAt(index))) {
        return false;
      }

      hasDigits = true;
    } // Should have digits and should not end with `_`


    if (!hasDigits || ch === '_') return false; // if !base60 - done;

    if (ch !== ':') return true; // base60 almost not used, no needs to optimize

    return /^(:[0-5]?[0-9])+$/.test(data.slice(index));
  }

  function constructYamlInteger(data) {
    var value = data,
        sign = 1,
        ch,
        base,
        digits = [];

    if (value.indexOf('_') !== -1) {
      value = value.replace(/_/g, '');
    }

    ch = value[0];

    if (ch === '-' || ch === '+') {
      if (ch === '-') sign = -1;
      value = value.slice(1);
      ch = value[0];
    }

    if (value === '0') return 0;

    if (ch === '0') {
      if (value[1] === 'b') return sign * parseInt(value.slice(2), 2);
      if (value[1] === 'x') return sign * parseInt(value, 16);
      return sign * parseInt(value, 8);
    }

    if (value.indexOf(':') !== -1) {
      value.split(':').forEach(function (v) {
        digits.unshift(parseInt(v, 10));
      });
      value = 0;
      base = 1;
      digits.forEach(function (d) {
        value += d * base;
        base *= 60;
      });
      return sign * value;
    }

    return sign * parseInt(value, 10);
  }

  function isInteger(object) {
    return Object.prototype.toString.call(object) === '[object Number]' && object % 1 === 0 && !common.isNegativeZero(object);
  }

  var int_1 = new type('tag:yaml.org,2002:int', {
    kind: 'scalar',
    resolve: resolveYamlInteger,
    construct: constructYamlInteger,
    predicate: isInteger,
    represent: {
      binary: function binary(obj) {
        return obj >= 0 ? '0b' + obj.toString(2) : '-0b' + obj.toString(2).slice(1);
      },
      octal: function octal(obj) {
        return obj >= 0 ? '0' + obj.toString(8) : '-0' + obj.toString(8).slice(1);
      },
      decimal: function decimal(obj) {
        return obj.toString(10);
      },

      /* eslint-disable max-len */
      hexadecimal: function hexadecimal(obj) {
        return obj >= 0 ? '0x' + obj.toString(16).toUpperCase() : '-0x' + obj.toString(16).toUpperCase().slice(1);
      }
    },
    defaultStyle: 'decimal',
    styleAliases: {
      binary: [2, 'bin'],
      octal: [8, 'oct'],
      decimal: [10, 'dec'],
      hexadecimal: [16, 'hex']
    }
  });

  var YAML_FLOAT_PATTERN = new RegExp( // 2.5e4, 2.5 and integers
  '^(?:[-+]?(?:0|[1-9][0-9_]*)(?:\\.[0-9_]*)?(?:[eE][-+]?[0-9]+)?' + // .2e4, .2
  // special case, seems not from spec
  '|\\.[0-9_]+(?:[eE][-+]?[0-9]+)?' + // 20:59
  '|[-+]?[0-9][0-9_]*(?::[0-5]?[0-9])+\\.[0-9_]*' + // .inf
  '|[-+]?\\.(?:inf|Inf|INF)' + // .nan
  '|\\.(?:nan|NaN|NAN))$');

  function resolveYamlFloat(data) {
    if (data === null) return false;

    if (!YAML_FLOAT_PATTERN.test(data) || // Quick hack to not allow integers end with `_`
    // Probably should update regexp & check speed
    data[data.length - 1] === '_') {
      return false;
    }

    return true;
  }

  function constructYamlFloat(data) {
    var value, sign, base, digits;
    value = data.replace(/_/g, '').toLowerCase();
    sign = value[0] === '-' ? -1 : 1;
    digits = [];

    if ('+-'.indexOf(value[0]) >= 0) {
      value = value.slice(1);
    }

    if (value === '.inf') {
      return sign === 1 ? Number.POSITIVE_INFINITY : Number.NEGATIVE_INFINITY;
    } else if (value === '.nan') {
      return NaN;
    } else if (value.indexOf(':') >= 0) {
      value.split(':').forEach(function (v) {
        digits.unshift(parseFloat(v, 10));
      });
      value = 0.0;
      base = 1;
      digits.forEach(function (d) {
        value += d * base;
        base *= 60;
      });
      return sign * value;
    }

    return sign * parseFloat(value, 10);
  }

  var SCIENTIFIC_WITHOUT_DOT = /^[-+]?[0-9]+e/;

  function representYamlFloat(object, style) {
    var res;

    if (isNaN(object)) {
      switch (style) {
        case 'lowercase':
          return '.nan';

        case 'uppercase':
          return '.NAN';

        case 'camelcase':
          return '.NaN';
      }
    } else if (Number.POSITIVE_INFINITY === object) {
      switch (style) {
        case 'lowercase':
          return '.inf';

        case 'uppercase':
          return '.INF';

        case 'camelcase':
          return '.Inf';
      }
    } else if (Number.NEGATIVE_INFINITY === object) {
      switch (style) {
        case 'lowercase':
          return '-.inf';

        case 'uppercase':
          return '-.INF';

        case 'camelcase':
          return '-.Inf';
      }
    } else if (common.isNegativeZero(object)) {
      return '-0.0';
    }

    res = object.toString(10); // JS stringifier can build scientific format without dots: 5e-100,
    // while YAML requres dot: 5.e-100. Fix it with simple hack

    return SCIENTIFIC_WITHOUT_DOT.test(res) ? res.replace('e', '.e') : res;
  }

  function isFloat(object) {
    return Object.prototype.toString.call(object) === '[object Number]' && (object % 1 !== 0 || common.isNegativeZero(object));
  }

  var float_1 = new type('tag:yaml.org,2002:float', {
    kind: 'scalar',
    resolve: resolveYamlFloat,
    construct: constructYamlFloat,
    predicate: isFloat,
    represent: representYamlFloat,
    defaultStyle: 'lowercase'
  });

  var json = new schema({
    include: [failsafe],
    implicit: [_null, bool, int_1, float_1]
  });

  var core = new schema({
    include: [json]
  });

  var YAML_DATE_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year
  '-([0-9][0-9])' + // [2] month
  '-([0-9][0-9])$'); // [3] day

  var YAML_TIMESTAMP_REGEXP = new RegExp('^([0-9][0-9][0-9][0-9])' + // [1] year
  '-([0-9][0-9]?)' + // [2] month
  '-([0-9][0-9]?)' + // [3] day
  '(?:[Tt]|[ \\t]+)' + // ...
  '([0-9][0-9]?)' + // [4] hour
  ':([0-9][0-9])' + // [5] minute
  ':([0-9][0-9])' + // [6] second
  '(?:\\.([0-9]*))?' + // [7] fraction
  '(?:[ \\t]*(Z|([-+])([0-9][0-9]?)' + // [8] tz [9] tz_sign [10] tz_hour
  '(?::([0-9][0-9]))?))?$'); // [11] tz_minute

  function resolveYamlTimestamp(data) {
    if (data === null) return false;
    if (YAML_DATE_REGEXP.exec(data) !== null) return true;
    if (YAML_TIMESTAMP_REGEXP.exec(data) !== null) return true;
    return false;
  }

  function constructYamlTimestamp(data) {
    var match,
        year,
        month,
        day,
        hour,
        minute,
        second,
        fraction = 0,
        delta = null,
        tz_hour,
        tz_minute,
        date;
    match = YAML_DATE_REGEXP.exec(data);
    if (match === null) match = YAML_TIMESTAMP_REGEXP.exec(data);
    if (match === null) throw new Error('Date resolve error'); // match: [1] year [2] month [3] day

    year = +match[1];
    month = +match[2] - 1; // JS month starts with 0

    day = +match[3];

    if (!match[4]) {
      // no hour
      return new Date(Date.UTC(year, month, day));
    } // match: [4] hour [5] minute [6] second [7] fraction


    hour = +match[4];
    minute = +match[5];
    second = +match[6];

    if (match[7]) {
      fraction = match[7].slice(0, 3);

      while (fraction.length < 3) {
        // milli-seconds
        fraction += '0';
      }

      fraction = +fraction;
    } // match: [8] tz [9] tz_sign [10] tz_hour [11] tz_minute


    if (match[9]) {
      tz_hour = +match[10];
      tz_minute = +(match[11] || 0);
      delta = (tz_hour * 60 + tz_minute) * 60000; // delta in mili-seconds

      if (match[9] === '-') delta = -delta;
    }

    date = new Date(Date.UTC(year, month, day, hour, minute, second, fraction));
    if (delta) date.setTime(date.getTime() - delta);
    return date;
  }

  function representYamlTimestamp(object
  /*, style*/
  ) {
    return object.toISOString();
  }

  var timestamp = new type('tag:yaml.org,2002:timestamp', {
    kind: 'scalar',
    resolve: resolveYamlTimestamp,
    construct: constructYamlTimestamp,
    instanceOf: Date,
    represent: representYamlTimestamp
  });

  function resolveYamlMerge(data) {
    return data === '<<' || data === null;
  }

  var merge = new type('tag:yaml.org,2002:merge', {
    kind: 'scalar',
    resolve: resolveYamlMerge
  });

  function commonjsRequire () {
  	throw new Error('Dynamic requires are not currently supported by @rollup/plugin-commonjs');
  }

  /*eslint-disable no-bitwise*/


  var NodeBuffer;

  try {
    // A trick for browserified version, to not include `Buffer` shim
    var _require = commonjsRequire;
    NodeBuffer = _require('buffer').Buffer;
  } catch (__) {} // [ 64, 65, 66 ] -> [ padding, CR, LF ]


  var BASE64_MAP = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=\n\r';

  function resolveYamlBinary(data) {
    if (data === null) return false;
    var code,
        idx,
        bitlen = 0,
        max = data.length,
        map = BASE64_MAP; // Convert one by one.

    for (idx = 0; idx < max; idx++) {
      code = map.indexOf(data.charAt(idx)); // Skip CR/LF

      if (code > 64) continue; // Fail on illegal characters

      if (code < 0) return false;
      bitlen += 6;
    } // If there are any bits left, source was corrupted


    return bitlen % 8 === 0;
  }

  function constructYamlBinary(data) {
    var idx,
        tailbits,
        input = data.replace(/[\r\n=]/g, ''),
        // remove CR/LF & padding to simplify scan
    max = input.length,
        map = BASE64_MAP,
        bits = 0,
        result = []; // Collect by 6*4 bits (3 bytes)

    for (idx = 0; idx < max; idx++) {
      if (idx % 4 === 0 && idx) {
        result.push(bits >> 16 & 0xFF);
        result.push(bits >> 8 & 0xFF);
        result.push(bits & 0xFF);
      }

      bits = bits << 6 | map.indexOf(input.charAt(idx));
    } // Dump tail


    tailbits = max % 4 * 6;

    if (tailbits === 0) {
      result.push(bits >> 16 & 0xFF);
      result.push(bits >> 8 & 0xFF);
      result.push(bits & 0xFF);
    } else if (tailbits === 18) {
      result.push(bits >> 10 & 0xFF);
      result.push(bits >> 2 & 0xFF);
    } else if (tailbits === 12) {
      result.push(bits >> 4 & 0xFF);
    } // Wrap into Buffer for NodeJS and leave Array for browser


    if (NodeBuffer) {
      // Support node 6.+ Buffer API when available
      return NodeBuffer.from ? NodeBuffer.from(result) : new NodeBuffer(result);
    }

    return result;
  }

  function representYamlBinary(object
  /*, style*/
  ) {
    var result = '',
        bits = 0,
        idx,
        tail,
        max = object.length,
        map = BASE64_MAP; // Convert every three bytes to 4 ASCII characters.

    for (idx = 0; idx < max; idx++) {
      if (idx % 3 === 0 && idx) {
        result += map[bits >> 18 & 0x3F];
        result += map[bits >> 12 & 0x3F];
        result += map[bits >> 6 & 0x3F];
        result += map[bits & 0x3F];
      }

      bits = (bits << 8) + object[idx];
    } // Dump tail


    tail = max % 3;

    if (tail === 0) {
      result += map[bits >> 18 & 0x3F];
      result += map[bits >> 12 & 0x3F];
      result += map[bits >> 6 & 0x3F];
      result += map[bits & 0x3F];
    } else if (tail === 2) {
      result += map[bits >> 10 & 0x3F];
      result += map[bits >> 4 & 0x3F];
      result += map[bits << 2 & 0x3F];
      result += map[64];
    } else if (tail === 1) {
      result += map[bits >> 2 & 0x3F];
      result += map[bits << 4 & 0x3F];
      result += map[64];
      result += map[64];
    }

    return result;
  }

  function isBinary(object) {
    return NodeBuffer && NodeBuffer.isBuffer(object);
  }

  var binary = new type('tag:yaml.org,2002:binary', {
    kind: 'scalar',
    resolve: resolveYamlBinary,
    construct: constructYamlBinary,
    predicate: isBinary,
    represent: representYamlBinary
  });

  var _hasOwnProperty = Object.prototype.hasOwnProperty;
  var _toString = Object.prototype.toString;

  function resolveYamlOmap(data) {
    if (data === null) return true;
    var objectKeys = [],
        index,
        length,
        pair,
        pairKey,
        pairHasKey,
        object = data;

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      pairHasKey = false;
      if (_toString.call(pair) !== '[object Object]') return false;

      for (pairKey in pair) {
        if (_hasOwnProperty.call(pair, pairKey)) {
          if (!pairHasKey) pairHasKey = true;else return false;
        }
      }

      if (!pairHasKey) return false;
      if (objectKeys.indexOf(pairKey) === -1) objectKeys.push(pairKey);else return false;
    }

    return true;
  }

  function constructYamlOmap(data) {
    return data !== null ? data : [];
  }

  var omap = new type('tag:yaml.org,2002:omap', {
    kind: 'sequence',
    resolve: resolveYamlOmap,
    construct: constructYamlOmap
  });

  var _toString$1 = Object.prototype.toString;

  function resolveYamlPairs(data) {
    if (data === null) return true;
    var index,
        length,
        pair,
        keys,
        result,
        object = data;
    result = new Array(object.length);

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      if (_toString$1.call(pair) !== '[object Object]') return false;
      keys = Object.keys(pair);
      if (keys.length !== 1) return false;
      result[index] = [keys[0], pair[keys[0]]];
    }

    return true;
  }

  function constructYamlPairs(data) {
    if (data === null) return [];
    var index,
        length,
        pair,
        keys,
        result,
        object = data;
    result = new Array(object.length);

    for (index = 0, length = object.length; index < length; index += 1) {
      pair = object[index];
      keys = Object.keys(pair);
      result[index] = [keys[0], pair[keys[0]]];
    }

    return result;
  }

  var pairs = new type('tag:yaml.org,2002:pairs', {
    kind: 'sequence',
    resolve: resolveYamlPairs,
    construct: constructYamlPairs
  });

  var _hasOwnProperty$1 = Object.prototype.hasOwnProperty;

  function resolveYamlSet(data) {
    if (data === null) return true;
    var key,
        object = data;

    for (key in object) {
      if (_hasOwnProperty$1.call(object, key)) {
        if (object[key] !== null) return false;
      }
    }

    return true;
  }

  function constructYamlSet(data) {
    return data !== null ? data : {};
  }

  var set = new type('tag:yaml.org,2002:set', {
    kind: 'mapping',
    resolve: resolveYamlSet,
    construct: constructYamlSet
  });

  var default_safe = new schema({
    include: [core],
    implicit: [timestamp, merge],
    explicit: [binary, omap, pairs, set]
  });

  function resolveJavascriptUndefined() {
    return true;
  }

  function constructJavascriptUndefined() {
    /*eslint-disable no-undefined*/
    return undefined;
  }

  function representJavascriptUndefined() {
    return '';
  }

  function isUndefined(object) {
    return typeof object === 'undefined';
  }

  var _undefined = new type('tag:yaml.org,2002:js/undefined', {
    kind: 'scalar',
    resolve: resolveJavascriptUndefined,
    construct: constructJavascriptUndefined,
    predicate: isUndefined,
    represent: representJavascriptUndefined
  });

  function resolveJavascriptRegExp(data) {
    if (data === null) return false;
    if (data.length === 0) return false;
    var regexp = data,
        tail = /\/([gim]*)$/.exec(data),
        modifiers = ''; // if regexp starts with '/' it can have modifiers and must be properly closed
    // `/foo/gim` - modifiers tail can be maximum 3 chars

    if (regexp[0] === '/') {
      if (tail) modifiers = tail[1];
      if (modifiers.length > 3) return false; // if expression starts with /, is should be properly terminated

      if (regexp[regexp.length - modifiers.length - 1] !== '/') return false;
    }

    return true;
  }

  function constructJavascriptRegExp(data) {
    var regexp = data,
        tail = /\/([gim]*)$/.exec(data),
        modifiers = ''; // `/foo/gim` - tail can be maximum 4 chars

    if (regexp[0] === '/') {
      if (tail) modifiers = tail[1];
      regexp = regexp.slice(1, regexp.length - modifiers.length - 1);
    }

    return new RegExp(regexp, modifiers);
  }

  function representJavascriptRegExp(object
  /*, style*/
  ) {
    var result = '/' + object.source + '/';
    if (object.global) result += 'g';
    if (object.multiline) result += 'm';
    if (object.ignoreCase) result += 'i';
    return result;
  }

  function isRegExp(object) {
    return Object.prototype.toString.call(object) === '[object RegExp]';
  }

  var regexp = new type('tag:yaml.org,2002:js/regexp', {
    kind: 'scalar',
    resolve: resolveJavascriptRegExp,
    construct: constructJavascriptRegExp,
    predicate: isRegExp,
    represent: representJavascriptRegExp
  });

  var esprima; // Browserified version does not have esprima
  //
  // 1. For node.js just require module as deps
  // 2. For browser try to require mudule via external AMD system.
  //    If not found - try to fallback to window.esprima. If not
  //    found too - then fail to parse.
  //

  try {
    // workaround to exclude package from browserify list.
    var _require$1 = commonjsRequire;
    esprima = _require$1('esprima');
  } catch (_) {
    /* eslint-disable no-redeclare */

    /* global window */
    if (typeof window !== 'undefined') esprima = window.esprima;
  }

  function resolveJavascriptFunction(data) {
    if (data === null) return false;

    try {
      var source = '(' + data + ')',
          ast = esprima.parse(source, {
        range: true
      });

      if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {
        return false;
      }

      return true;
    } catch (err) {
      return false;
    }
  }

  function constructJavascriptFunction(data) {
    /*jslint evil:true*/
    var source = '(' + data + ')',
        ast = esprima.parse(source, {
      range: true
    }),
        params = [],
        body;

    if (ast.type !== 'Program' || ast.body.length !== 1 || ast.body[0].type !== 'ExpressionStatement' || ast.body[0].expression.type !== 'ArrowFunctionExpression' && ast.body[0].expression.type !== 'FunctionExpression') {
      throw new Error('Failed to resolve function');
    }

    ast.body[0].expression.params.forEach(function (param) {
      params.push(param.name);
    });
    body = ast.body[0].expression.body.range; // Esprima's ranges include the first '{' and the last '}' characters on
    // function expressions. So cut them out.

    if (ast.body[0].expression.body.type === 'BlockStatement') {
      /*eslint-disable no-new-func*/
      return new Function(params, source.slice(body[0] + 1, body[1] - 1));
    } // ES6 arrow functions can omit the BlockStatement. In that case, just return
    // the body.

    /*eslint-disable no-new-func*/


    return new Function(params, 'return ' + source.slice(body[0], body[1]));
  }

  function representJavascriptFunction(object
  /*, style*/
  ) {
    return object.toString();
  }

  function isFunction(object) {
    return Object.prototype.toString.call(object) === '[object Function]';
  }

  var _function = new type('tag:yaml.org,2002:js/function', {
    kind: 'scalar',
    resolve: resolveJavascriptFunction,
    construct: constructJavascriptFunction,
    predicate: isFunction,
    represent: representJavascriptFunction
  });

  var default_full = schema.DEFAULT = new schema({
    include: [default_safe],
    explicit: [_undefined, regexp, _function]
  });

  /*eslint-disable max-len,no-use-before-define*/


  var _hasOwnProperty$2 = Object.prototype.hasOwnProperty;
  var CONTEXT_FLOW_IN = 1;
  var CONTEXT_FLOW_OUT = 2;
  var CONTEXT_BLOCK_IN = 3;
  var CONTEXT_BLOCK_OUT = 4;
  var CHOMPING_CLIP = 1;
  var CHOMPING_STRIP = 2;
  var CHOMPING_KEEP = 3;
  var PATTERN_NON_PRINTABLE = /[\x00-\x08\x0B\x0C\x0E-\x1F\x7F-\x84\x86-\x9F\uFFFE\uFFFF]|[\uD800-\uDBFF](?![\uDC00-\uDFFF])|(?:[^\uD800-\uDBFF]|^)[\uDC00-\uDFFF]/;
  var PATTERN_NON_ASCII_LINE_BREAKS = /[\x85\u2028\u2029]/;
  var PATTERN_FLOW_INDICATORS = /[,\[\]\{\}]/;
  var PATTERN_TAG_HANDLE = /^(?:!|!!|![a-z\-]+!)$/i;
  var PATTERN_TAG_URI = /^(?:!|[^,\[\]\{\}])(?:%[0-9a-f]{2}|[0-9a-z\-#;\/\?:@&=\+\$,_\.!~\*'\(\)\[\]])*$/i;

  function _class(obj) {
    return Object.prototype.toString.call(obj);
  }

  function is_EOL(c) {
    return c === 0x0A
    /* LF */
    || c === 0x0D
    /* CR */
    ;
  }

  function is_WHITE_SPACE(c) {
    return c === 0x09
    /* Tab */
    || c === 0x20
    /* Space */
    ;
  }

  function is_WS_OR_EOL(c) {
    return c === 0x09
    /* Tab */
    || c === 0x20
    /* Space */
    || c === 0x0A
    /* LF */
    || c === 0x0D
    /* CR */
    ;
  }

  function is_FLOW_INDICATOR(c) {
    return c === 0x2C
    /* , */
    || c === 0x5B
    /* [ */
    || c === 0x5D
    /* ] */
    || c === 0x7B
    /* { */
    || c === 0x7D
    /* } */
    ;
  }

  function fromHexCode(c) {
    var lc;

    if (0x30
    /* 0 */
    <= c && c <= 0x39
    /* 9 */
    ) {
      return c - 0x30;
    }
    /*eslint-disable no-bitwise*/


    lc = c | 0x20;

    if (0x61
    /* a */
    <= lc && lc <= 0x66
    /* f */
    ) {
      return lc - 0x61 + 10;
    }

    return -1;
  }

  function escapedHexLen(c) {
    if (c === 0x78
    /* x */
    ) {
        return 2;
      }

    if (c === 0x75
    /* u */
    ) {
        return 4;
      }

    if (c === 0x55
    /* U */
    ) {
        return 8;
      }

    return 0;
  }

  function fromDecimalCode(c) {
    if (0x30
    /* 0 */
    <= c && c <= 0x39
    /* 9 */
    ) {
      return c - 0x30;
    }

    return -1;
  }

  function simpleEscapeSequence(c) {
    /* eslint-disable indent */
    return c === 0x30
    /* 0 */
    ? '\x00' : c === 0x61
    /* a */
    ? '\x07' : c === 0x62
    /* b */
    ? '\x08' : c === 0x74
    /* t */
    ? '\x09' : c === 0x09
    /* Tab */
    ? '\x09' : c === 0x6E
    /* n */
    ? '\x0A' : c === 0x76
    /* v */
    ? '\x0B' : c === 0x66
    /* f */
    ? '\x0C' : c === 0x72
    /* r */
    ? '\x0D' : c === 0x65
    /* e */
    ? '\x1B' : c === 0x20
    /* Space */
    ? ' ' : c === 0x22
    /* " */
    ? '\x22' : c === 0x2F
    /* / */
    ? '/' : c === 0x5C
    /* \ */
    ? '\x5C' : c === 0x4E
    /* N */
    ? '\x85' : c === 0x5F
    /* _ */
    ? '\xA0' : c === 0x4C
    /* L */
    ? "\u2028" : c === 0x50
    /* P */
    ? "\u2029" : '';
  }

  function charFromCodepoint(c) {
    if (c <= 0xFFFF) {
      return String.fromCharCode(c);
    } // Encode UTF-16 surrogate pair
    // https://en.wikipedia.org/wiki/UTF-16#Code_points_U.2B010000_to_U.2B10FFFF


    return String.fromCharCode((c - 0x010000 >> 10) + 0xD800, (c - 0x010000 & 0x03FF) + 0xDC00);
  }

  var simpleEscapeCheck = new Array(256); // integer, for fast access

  var simpleEscapeMap = new Array(256);

  for (var i = 0; i < 256; i++) {
    simpleEscapeCheck[i] = simpleEscapeSequence(i) ? 1 : 0;
    simpleEscapeMap[i] = simpleEscapeSequence(i);
  }

  function State(input, options) {
    this.input = input;
    this.filename = options['filename'] || null;
    this.schema = options['schema'] || default_full;
    this.onWarning = options['onWarning'] || null;
    this.legacy = options['legacy'] || false;
    this.json = options['json'] || false;
    this.listener = options['listener'] || null;
    this.implicitTypes = this.schema.compiledImplicit;
    this.typeMap = this.schema.compiledTypeMap;
    this.length = input.length;
    this.position = 0;
    this.line = 0;
    this.lineStart = 0;
    this.lineIndent = 0;
    this.documents = [];
    /*
    this.version;
    this.checkLineBreaks;
    this.tagMap;
    this.anchorMap;
    this.tag;
    this.anchor;
    this.kind;
    this.result;*/
  }

  function generateError(state, message) {
    return new exception(message, new mark(state.filename, state.input, state.position, state.line, state.position - state.lineStart));
  }

  function throwError(state, message) {
    throw generateError(state, message);
  }

  function throwWarning(state, message) {
    if (state.onWarning) {
      state.onWarning.call(null, generateError(state, message));
    }
  }

  var directiveHandlers = {
    YAML: function handleYamlDirective(state, name, args) {
      var match, major, minor;

      if (state.version !== null) {
        throwError(state, 'duplication of %YAML directive');
      }

      if (args.length !== 1) {
        throwError(state, 'YAML directive accepts exactly one argument');
      }

      match = /^([0-9]+)\.([0-9]+)$/.exec(args[0]);

      if (match === null) {
        throwError(state, 'ill-formed argument of the YAML directive');
      }

      major = parseInt(match[1], 10);
      minor = parseInt(match[2], 10);

      if (major !== 1) {
        throwError(state, 'unacceptable YAML version of the document');
      }

      state.version = args[0];
      state.checkLineBreaks = minor < 2;

      if (minor !== 1 && minor !== 2) {
        throwWarning(state, 'unsupported YAML version of the document');
      }
    },
    TAG: function handleTagDirective(state, name, args) {
      var handle, prefix;

      if (args.length !== 2) {
        throwError(state, 'TAG directive accepts exactly two arguments');
      }

      handle = args[0];
      prefix = args[1];

      if (!PATTERN_TAG_HANDLE.test(handle)) {
        throwError(state, 'ill-formed tag handle (first argument) of the TAG directive');
      }

      if (_hasOwnProperty$2.call(state.tagMap, handle)) {
        throwError(state, 'there is a previously declared suffix for "' + handle + '" tag handle');
      }

      if (!PATTERN_TAG_URI.test(prefix)) {
        throwError(state, 'ill-formed tag prefix (second argument) of the TAG directive');
      }

      state.tagMap[handle] = prefix;
    }
  };

  function captureSegment(state, start, end, checkJson) {
    var _position, _length, _character, _result;

    if (start < end) {
      _result = state.input.slice(start, end);

      if (checkJson) {
        for (_position = 0, _length = _result.length; _position < _length; _position += 1) {
          _character = _result.charCodeAt(_position);

          if (!(_character === 0x09 || 0x20 <= _character && _character <= 0x10FFFF)) {
            throwError(state, 'expected valid JSON character');
          }
        }
      } else if (PATTERN_NON_PRINTABLE.test(_result)) {
        throwError(state, 'the stream contains non-printable characters');
      }

      state.result += _result;
    }
  }

  function mergeMappings(state, destination, source, overridableKeys) {
    var sourceKeys, key, index, quantity;

    if (!common.isObject(source)) {
      throwError(state, 'cannot merge mappings; the provided source object is unacceptable');
    }

    sourceKeys = Object.keys(source);

    for (index = 0, quantity = sourceKeys.length; index < quantity; index += 1) {
      key = sourceKeys[index];

      if (!_hasOwnProperty$2.call(destination, key)) {
        destination[key] = source[key];
        overridableKeys[key] = true;
      }
    }
  }

  function storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, startLine, startPos) {
    var index, quantity; // The output is a plain object here, so keys can only be strings.
    // We need to convert keyNode to a string, but doing so can hang the process
    // (deeply nested arrays that explode exponentially using aliases).

    if (Array.isArray(keyNode)) {
      keyNode = Array.prototype.slice.call(keyNode);

      for (index = 0, quantity = keyNode.length; index < quantity; index += 1) {
        if (Array.isArray(keyNode[index])) {
          throwError(state, 'nested arrays are not supported inside keys');
        }

        if (typeof keyNode === 'object' && _class(keyNode[index]) === '[object Object]') {
          keyNode[index] = '[object Object]';
        }
      }
    } // Avoid code execution in load() via toString property
    // (still use its own toString for arrays, timestamps,
    // and whatever user schema extensions happen to have @@toStringTag)


    if (typeof keyNode === 'object' && _class(keyNode) === '[object Object]') {
      keyNode = '[object Object]';
    }

    keyNode = String(keyNode);

    if (_result === null) {
      _result = {};
    }

    if (keyTag === 'tag:yaml.org,2002:merge') {
      if (Array.isArray(valueNode)) {
        for (index = 0, quantity = valueNode.length; index < quantity; index += 1) {
          mergeMappings(state, _result, valueNode[index], overridableKeys);
        }
      } else {
        mergeMappings(state, _result, valueNode, overridableKeys);
      }
    } else {
      if (!state.json && !_hasOwnProperty$2.call(overridableKeys, keyNode) && _hasOwnProperty$2.call(_result, keyNode)) {
        state.line = startLine || state.line;
        state.position = startPos || state.position;
        throwError(state, 'duplicated mapping key');
      }

      _result[keyNode] = valueNode;
      delete overridableKeys[keyNode];
    }

    return _result;
  }

  function readLineBreak(state) {
    var ch;
    ch = state.input.charCodeAt(state.position);

    if (ch === 0x0A
    /* LF */
    ) {
        state.position++;
      } else if (ch === 0x0D
    /* CR */
    ) {
        state.position++;

        if (state.input.charCodeAt(state.position) === 0x0A
        /* LF */
        ) {
            state.position++;
          }
      } else {
      throwError(state, 'a line break is expected');
    }

    state.line += 1;
    state.lineStart = state.position;
  }

  function skipSeparationSpace(state, allowComments, checkIndent) {
    var lineBreaks = 0,
        ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      while (is_WHITE_SPACE(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      if (allowComments && ch === 0x23
      /* # */
      ) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (ch !== 0x0A
          /* LF */
          && ch !== 0x0D
          /* CR */
          && ch !== 0);
        }

      if (is_EOL(ch)) {
        readLineBreak(state);
        ch = state.input.charCodeAt(state.position);
        lineBreaks++;
        state.lineIndent = 0;

        while (ch === 0x20
        /* Space */
        ) {
          state.lineIndent++;
          ch = state.input.charCodeAt(++state.position);
        }
      } else {
        break;
      }
    }

    if (checkIndent !== -1 && lineBreaks !== 0 && state.lineIndent < checkIndent) {
      throwWarning(state, 'deficient indentation');
    }

    return lineBreaks;
  }

  function testDocumentSeparator(state) {
    var _position = state.position,
        ch;
    ch = state.input.charCodeAt(_position); // Condition state.position === state.lineStart is tested
    // in parent on each call, for efficiency. No needs to test here again.

    if ((ch === 0x2D
    /* - */
    || ch === 0x2E
    /* . */
    ) && ch === state.input.charCodeAt(_position + 1) && ch === state.input.charCodeAt(_position + 2)) {
      _position += 3;
      ch = state.input.charCodeAt(_position);

      if (ch === 0 || is_WS_OR_EOL(ch)) {
        return true;
      }
    }

    return false;
  }

  function writeFoldedLines(state, count) {
    if (count === 1) {
      state.result += ' ';
    } else if (count > 1) {
      state.result += common.repeat('\n', count - 1);
    }
  }

  function readPlainScalar(state, nodeIndent, withinFlowCollection) {
    var preceding,
        following,
        captureStart,
        captureEnd,
        hasPendingContent,
        _line,
        _lineStart,
        _lineIndent,
        _kind = state.kind,
        _result = state.result,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (is_WS_OR_EOL(ch) || is_FLOW_INDICATOR(ch) || ch === 0x23
    /* # */
    || ch === 0x26
    /* & */
    || ch === 0x2A
    /* * */
    || ch === 0x21
    /* ! */
    || ch === 0x7C
    /* | */
    || ch === 0x3E
    /* > */
    || ch === 0x27
    /* ' */
    || ch === 0x22
    /* " */
    || ch === 0x25
    /* % */
    || ch === 0x40
    /* @ */
    || ch === 0x60
    /* ` */
    ) {
        return false;
      }

    if (ch === 0x3F
    /* ? */
    || ch === 0x2D
    /* - */
    ) {
        following = state.input.charCodeAt(state.position + 1);

        if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
          return false;
        }
      }

    state.kind = 'scalar';
    state.result = '';
    captureStart = captureEnd = state.position;
    hasPendingContent = false;

    while (ch !== 0) {
      if (ch === 0x3A
      /* : */
      ) {
          following = state.input.charCodeAt(state.position + 1);

          if (is_WS_OR_EOL(following) || withinFlowCollection && is_FLOW_INDICATOR(following)) {
            break;
          }
        } else if (ch === 0x23
      /* # */
      ) {
          preceding = state.input.charCodeAt(state.position - 1);

          if (is_WS_OR_EOL(preceding)) {
            break;
          }
        } else if (state.position === state.lineStart && testDocumentSeparator(state) || withinFlowCollection && is_FLOW_INDICATOR(ch)) {
        break;
      } else if (is_EOL(ch)) {
        _line = state.line;
        _lineStart = state.lineStart;
        _lineIndent = state.lineIndent;
        skipSeparationSpace(state, false, -1);

        if (state.lineIndent >= nodeIndent) {
          hasPendingContent = true;
          ch = state.input.charCodeAt(state.position);
          continue;
        } else {
          state.position = captureEnd;
          state.line = _line;
          state.lineStart = _lineStart;
          state.lineIndent = _lineIndent;
          break;
        }
      }

      if (hasPendingContent) {
        captureSegment(state, captureStart, captureEnd, false);
        writeFoldedLines(state, state.line - _line);
        captureStart = captureEnd = state.position;
        hasPendingContent = false;
      }

      if (!is_WHITE_SPACE(ch)) {
        captureEnd = state.position + 1;
      }

      ch = state.input.charCodeAt(++state.position);
    }

    captureSegment(state, captureStart, captureEnd, false);

    if (state.result) {
      return true;
    }

    state.kind = _kind;
    state.result = _result;
    return false;
  }

  function readSingleQuotedScalar(state, nodeIndent) {
    var ch, captureStart, captureEnd;
    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x27
    /* ' */
    ) {
        return false;
      }

    state.kind = 'scalar';
    state.result = '';
    state.position++;
    captureStart = captureEnd = state.position;

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 0x27
      /* ' */
      ) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);

          if (ch === 0x27
          /* ' */
          ) {
              captureStart = state.position;
              state.position++;
              captureEnd = state.position;
            } else {
            return true;
          }
        } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, 'unexpected end of the document within a single quoted scalar');
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }

    throwError(state, 'unexpected end of the stream within a single quoted scalar');
  }

  function readDoubleQuotedScalar(state, nodeIndent) {
    var captureStart, captureEnd, hexLength, hexResult, tmp, ch;
    ch = state.input.charCodeAt(state.position);

    if (ch !== 0x22
    /* " */
    ) {
        return false;
      }

    state.kind = 'scalar';
    state.result = '';
    state.position++;
    captureStart = captureEnd = state.position;

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      if (ch === 0x22
      /* " */
      ) {
          captureSegment(state, captureStart, state.position, true);
          state.position++;
          return true;
        } else if (ch === 0x5C
      /* \ */
      ) {
          captureSegment(state, captureStart, state.position, true);
          ch = state.input.charCodeAt(++state.position);

          if (is_EOL(ch)) {
            skipSeparationSpace(state, false, nodeIndent); // TODO: rework to inline fn with no type cast?
          } else if (ch < 256 && simpleEscapeCheck[ch]) {
            state.result += simpleEscapeMap[ch];
            state.position++;
          } else if ((tmp = escapedHexLen(ch)) > 0) {
            hexLength = tmp;
            hexResult = 0;

            for (; hexLength > 0; hexLength--) {
              ch = state.input.charCodeAt(++state.position);

              if ((tmp = fromHexCode(ch)) >= 0) {
                hexResult = (hexResult << 4) + tmp;
              } else {
                throwError(state, 'expected hexadecimal character');
              }
            }

            state.result += charFromCodepoint(hexResult);
            state.position++;
          } else {
            throwError(state, 'unknown escape sequence');
          }

          captureStart = captureEnd = state.position;
        } else if (is_EOL(ch)) {
        captureSegment(state, captureStart, captureEnd, true);
        writeFoldedLines(state, skipSeparationSpace(state, false, nodeIndent));
        captureStart = captureEnd = state.position;
      } else if (state.position === state.lineStart && testDocumentSeparator(state)) {
        throwError(state, 'unexpected end of the document within a double quoted scalar');
      } else {
        state.position++;
        captureEnd = state.position;
      }
    }

    throwError(state, 'unexpected end of the stream within a double quoted scalar');
  }

  function readFlowCollection(state, nodeIndent) {
    var readNext = true,
        _line,
        _tag = state.tag,
        _result,
        _anchor = state.anchor,
        following,
        terminator,
        isPair,
        isExplicitPair,
        isMapping,
        overridableKeys = {},
        keyNode,
        keyTag,
        valueNode,
        ch;

    ch = state.input.charCodeAt(state.position);

    if (ch === 0x5B
    /* [ */
    ) {
        terminator = 0x5D;
        /* ] */

        isMapping = false;
        _result = [];
      } else if (ch === 0x7B
    /* { */
    ) {
        terminator = 0x7D;
        /* } */

        isMapping = true;
        _result = {};
      } else {
      return false;
    }

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(++state.position);

    while (ch !== 0) {
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);

      if (ch === terminator) {
        state.position++;
        state.tag = _tag;
        state.anchor = _anchor;
        state.kind = isMapping ? 'mapping' : 'sequence';
        state.result = _result;
        return true;
      } else if (!readNext) {
        throwError(state, 'missed comma between flow collection entries');
      }

      keyTag = keyNode = valueNode = null;
      isPair = isExplicitPair = false;

      if (ch === 0x3F
      /* ? */
      ) {
          following = state.input.charCodeAt(state.position + 1);

          if (is_WS_OR_EOL(following)) {
            isPair = isExplicitPair = true;
            state.position++;
            skipSeparationSpace(state, true, nodeIndent);
          }
        }

      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
      keyTag = state.tag;
      keyNode = state.result;
      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);

      if ((isExplicitPair || state.line === _line) && ch === 0x3A
      /* : */
      ) {
          isPair = true;
          ch = state.input.charCodeAt(++state.position);
          skipSeparationSpace(state, true, nodeIndent);
          composeNode(state, nodeIndent, CONTEXT_FLOW_IN, false, true);
          valueNode = state.result;
        }

      if (isMapping) {
        storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode);
      } else if (isPair) {
        _result.push(storeMappingPair(state, null, overridableKeys, keyTag, keyNode, valueNode));
      } else {
        _result.push(keyNode);
      }

      skipSeparationSpace(state, true, nodeIndent);
      ch = state.input.charCodeAt(state.position);

      if (ch === 0x2C
      /* , */
      ) {
          readNext = true;
          ch = state.input.charCodeAt(++state.position);
        } else {
        readNext = false;
      }
    }

    throwError(state, 'unexpected end of the stream within a flow collection');
  }

  function readBlockScalar(state, nodeIndent) {
    var captureStart,
        folding,
        chomping = CHOMPING_CLIP,
        didReadContent = false,
        detectedIndent = false,
        textIndent = nodeIndent,
        emptyLines = 0,
        atMoreIndented = false,
        tmp,
        ch;
    ch = state.input.charCodeAt(state.position);

    if (ch === 0x7C
    /* | */
    ) {
        folding = false;
      } else if (ch === 0x3E
    /* > */
    ) {
        folding = true;
      } else {
      return false;
    }

    state.kind = 'scalar';
    state.result = '';

    while (ch !== 0) {
      ch = state.input.charCodeAt(++state.position);

      if (ch === 0x2B
      /* + */
      || ch === 0x2D
      /* - */
      ) {
          if (CHOMPING_CLIP === chomping) {
            chomping = ch === 0x2B
            /* + */
            ? CHOMPING_KEEP : CHOMPING_STRIP;
          } else {
            throwError(state, 'repeat of a chomping mode identifier');
          }
        } else if ((tmp = fromDecimalCode(ch)) >= 0) {
        if (tmp === 0) {
          throwError(state, 'bad explicit indentation width of a block scalar; it cannot be less than one');
        } else if (!detectedIndent) {
          textIndent = nodeIndent + tmp - 1;
          detectedIndent = true;
        } else {
          throwError(state, 'repeat of an indentation width identifier');
        }
      } else {
        break;
      }
    }

    if (is_WHITE_SPACE(ch)) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (is_WHITE_SPACE(ch));

      if (ch === 0x23
      /* # */
      ) {
          do {
            ch = state.input.charCodeAt(++state.position);
          } while (!is_EOL(ch) && ch !== 0);
        }
    }

    while (ch !== 0) {
      readLineBreak(state);
      state.lineIndent = 0;
      ch = state.input.charCodeAt(state.position);

      while ((!detectedIndent || state.lineIndent < textIndent) && ch === 0x20
      /* Space */
      ) {
        state.lineIndent++;
        ch = state.input.charCodeAt(++state.position);
      }

      if (!detectedIndent && state.lineIndent > textIndent) {
        textIndent = state.lineIndent;
      }

      if (is_EOL(ch)) {
        emptyLines++;
        continue;
      } // End of the scalar.


      if (state.lineIndent < textIndent) {
        // Perform the chomping.
        if (chomping === CHOMPING_KEEP) {
          state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
        } else if (chomping === CHOMPING_CLIP) {
          if (didReadContent) {
            // i.e. only if the scalar is not empty.
            state.result += '\n';
          }
        } // Break this `while` cycle and go to the funciton's epilogue.


        break;
      } // Folded style: use fancy rules to handle line breaks.


      if (folding) {
        // Lines starting with white space characters (more-indented lines) are not folded.
        if (is_WHITE_SPACE(ch)) {
          atMoreIndented = true; // except for the first content line (cf. Example 8.1)

          state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines); // End of more-indented block.
        } else if (atMoreIndented) {
          atMoreIndented = false;
          state.result += common.repeat('\n', emptyLines + 1); // Just one line break - perceive as the same line.
        } else if (emptyLines === 0) {
          if (didReadContent) {
            // i.e. only if we have already read some scalar content.
            state.result += ' ';
          } // Several line breaks - perceive as different lines.

        } else {
          state.result += common.repeat('\n', emptyLines);
        } // Literal style: just add exact number of line breaks between content lines.

      } else {
        // Keep all line breaks except the header line break.
        state.result += common.repeat('\n', didReadContent ? 1 + emptyLines : emptyLines);
      }

      didReadContent = true;
      detectedIndent = true;
      emptyLines = 0;
      captureStart = state.position;

      while (!is_EOL(ch) && ch !== 0) {
        ch = state.input.charCodeAt(++state.position);
      }

      captureSegment(state, captureStart, state.position, false);
    }

    return true;
  }

  function readBlockSequence(state, nodeIndent) {
    var _line,
        _tag = state.tag,
        _anchor = state.anchor,
        _result = [],
        following,
        detected = false,
        ch;

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      if (ch !== 0x2D
      /* - */
      ) {
          break;
        }

      following = state.input.charCodeAt(state.position + 1);

      if (!is_WS_OR_EOL(following)) {
        break;
      }

      detected = true;
      state.position++;

      if (skipSeparationSpace(state, true, -1)) {
        if (state.lineIndent <= nodeIndent) {
          _result.push(null);

          ch = state.input.charCodeAt(state.position);
          continue;
        }
      }

      _line = state.line;
      composeNode(state, nodeIndent, CONTEXT_BLOCK_IN, false, true);

      _result.push(state.result);

      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);

      if ((state.line === _line || state.lineIndent > nodeIndent) && ch !== 0) {
        throwError(state, 'bad indentation of a sequence entry');
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    }

    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = 'sequence';
      state.result = _result;
      return true;
    }

    return false;
  }

  function readBlockMapping(state, nodeIndent, flowIndent) {
    var following,
        allowCompact,
        _line,
        _pos,
        _tag = state.tag,
        _anchor = state.anchor,
        _result = {},
        overridableKeys = {},
        keyTag = null,
        keyNode = null,
        valueNode = null,
        atExplicitKey = false,
        detected = false,
        ch;

    if (state.anchor !== null) {
      state.anchorMap[state.anchor] = _result;
    }

    ch = state.input.charCodeAt(state.position);

    while (ch !== 0) {
      following = state.input.charCodeAt(state.position + 1);
      _line = state.line; // Save the current line.

      _pos = state.position; //
      // Explicit notation case. There are two separate blocks:
      // first for the key (denoted by "?") and second for the value (denoted by ":")
      //

      if ((ch === 0x3F
      /* ? */
      || ch === 0x3A
      /* : */
      ) && is_WS_OR_EOL(following)) {
        if (ch === 0x3F
        /* ? */
        ) {
            if (atExplicitKey) {
              storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
              keyTag = keyNode = valueNode = null;
            }

            detected = true;
            atExplicitKey = true;
            allowCompact = true;
          } else if (atExplicitKey) {
          // i.e. 0x3A/* : */ === character after the explicit key.
          atExplicitKey = false;
          allowCompact = true;
        } else {
          throwError(state, 'incomplete explicit mapping pair; a key node is missed; or followed by a non-tabulated empty line');
        }

        state.position += 1;
        ch = following; //
        // Implicit notation case. Flow-style node as the key first, then ":", and the value.
        //
      } else if (composeNode(state, flowIndent, CONTEXT_FLOW_OUT, false, true)) {
        if (state.line === _line) {
          ch = state.input.charCodeAt(state.position);

          while (is_WHITE_SPACE(ch)) {
            ch = state.input.charCodeAt(++state.position);
          }

          if (ch === 0x3A
          /* : */
          ) {
              ch = state.input.charCodeAt(++state.position);

              if (!is_WS_OR_EOL(ch)) {
                throwError(state, 'a whitespace character is expected after the key-value separator within a block mapping');
              }

              if (atExplicitKey) {
                storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
                keyTag = keyNode = valueNode = null;
              }

              detected = true;
              atExplicitKey = false;
              allowCompact = false;
              keyTag = state.tag;
              keyNode = state.result;
            } else if (detected) {
            throwError(state, 'can not read an implicit mapping pair; a colon is missed');
          } else {
            state.tag = _tag;
            state.anchor = _anchor;
            return true; // Keep the result of `composeNode`.
          }
        } else if (detected) {
          throwError(state, 'can not read a block mapping entry; a multiline key may not be an implicit key');
        } else {
          state.tag = _tag;
          state.anchor = _anchor;
          return true; // Keep the result of `composeNode`.
        }
      } else {
          break; // Reading is done. Go to the epilogue.
        } //
      // Common reading code for both explicit and implicit notations.
      //


      if (state.line === _line || state.lineIndent > nodeIndent) {
        if (composeNode(state, nodeIndent, CONTEXT_BLOCK_OUT, true, allowCompact)) {
          if (atExplicitKey) {
            keyNode = state.result;
          } else {
            valueNode = state.result;
          }
        }

        if (!atExplicitKey) {
          storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, valueNode, _line, _pos);
          keyTag = keyNode = valueNode = null;
        }

        skipSeparationSpace(state, true, -1);
        ch = state.input.charCodeAt(state.position);
      }

      if (state.lineIndent > nodeIndent && ch !== 0) {
        throwError(state, 'bad indentation of a mapping entry');
      } else if (state.lineIndent < nodeIndent) {
        break;
      }
    } //
    // Epilogue.
    //
    // Special case: last mapping's node contains only the key in explicit notation.


    if (atExplicitKey) {
      storeMappingPair(state, _result, overridableKeys, keyTag, keyNode, null);
    } // Expose the resulting mapping.


    if (detected) {
      state.tag = _tag;
      state.anchor = _anchor;
      state.kind = 'mapping';
      state.result = _result;
    }

    return detected;
  }

  function readTagProperty(state) {
    var _position,
        isVerbatim = false,
        isNamed = false,
        tagHandle,
        tagName,
        ch;

    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x21
    /* ! */
    ) return false;

    if (state.tag !== null) {
      throwError(state, 'duplication of a tag property');
    }

    ch = state.input.charCodeAt(++state.position);

    if (ch === 0x3C
    /* < */
    ) {
        isVerbatim = true;
        ch = state.input.charCodeAt(++state.position);
      } else if (ch === 0x21
    /* ! */
    ) {
        isNamed = true;
        tagHandle = '!!';
        ch = state.input.charCodeAt(++state.position);
      } else {
      tagHandle = '!';
    }

    _position = state.position;

    if (isVerbatim) {
      do {
        ch = state.input.charCodeAt(++state.position);
      } while (ch !== 0 && ch !== 0x3E
      /* > */
      );

      if (state.position < state.length) {
        tagName = state.input.slice(_position, state.position);
        ch = state.input.charCodeAt(++state.position);
      } else {
        throwError(state, 'unexpected end of the stream within a verbatim tag');
      }
    } else {
      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        if (ch === 0x21
        /* ! */
        ) {
            if (!isNamed) {
              tagHandle = state.input.slice(_position - 1, state.position + 1);

              if (!PATTERN_TAG_HANDLE.test(tagHandle)) {
                throwError(state, 'named tag handle cannot contain such characters');
              }

              isNamed = true;
              _position = state.position + 1;
            } else {
              throwError(state, 'tag suffix cannot contain exclamation marks');
            }
          }

        ch = state.input.charCodeAt(++state.position);
      }

      tagName = state.input.slice(_position, state.position);

      if (PATTERN_FLOW_INDICATORS.test(tagName)) {
        throwError(state, 'tag suffix cannot contain flow indicator characters');
      }
    }

    if (tagName && !PATTERN_TAG_URI.test(tagName)) {
      throwError(state, 'tag name cannot contain such characters: ' + tagName);
    }

    if (isVerbatim) {
      state.tag = tagName;
    } else if (_hasOwnProperty$2.call(state.tagMap, tagHandle)) {
      state.tag = state.tagMap[tagHandle] + tagName;
    } else if (tagHandle === '!') {
      state.tag = '!' + tagName;
    } else if (tagHandle === '!!') {
      state.tag = 'tag:yaml.org,2002:' + tagName;
    } else {
      throwError(state, 'undeclared tag handle "' + tagHandle + '"');
    }

    return true;
  }

  function readAnchorProperty(state) {
    var _position, ch;

    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x26
    /* & */
    ) return false;

    if (state.anchor !== null) {
      throwError(state, 'duplication of an anchor property');
    }

    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (state.position === _position) {
      throwError(state, 'name of an anchor node must contain at least one character');
    }

    state.anchor = state.input.slice(_position, state.position);
    return true;
  }

  function readAlias(state) {
    var _position, alias, ch;

    ch = state.input.charCodeAt(state.position);
    if (ch !== 0x2A
    /* * */
    ) return false;
    ch = state.input.charCodeAt(++state.position);
    _position = state.position;

    while (ch !== 0 && !is_WS_OR_EOL(ch) && !is_FLOW_INDICATOR(ch)) {
      ch = state.input.charCodeAt(++state.position);
    }

    if (state.position === _position) {
      throwError(state, 'name of an alias node must contain at least one character');
    }

    alias = state.input.slice(_position, state.position);

    if (!state.anchorMap.hasOwnProperty(alias)) {
      throwError(state, 'unidentified alias "' + alias + '"');
    }

    state.result = state.anchorMap[alias];
    skipSeparationSpace(state, true, -1);
    return true;
  }

  function composeNode(state, parentIndent, nodeContext, allowToSeek, allowCompact) {
    var allowBlockStyles,
        allowBlockScalars,
        allowBlockCollections,
        indentStatus = 1,
        // 1: this>parent, 0: this=parent, -1: this<parent
    atNewLine = false,
        hasContent = false,
        typeIndex,
        typeQuantity,
        type,
        flowIndent,
        blockIndent;

    if (state.listener !== null) {
      state.listener('open', state);
    }

    state.tag = null;
    state.anchor = null;
    state.kind = null;
    state.result = null;
    allowBlockStyles = allowBlockScalars = allowBlockCollections = CONTEXT_BLOCK_OUT === nodeContext || CONTEXT_BLOCK_IN === nodeContext;

    if (allowToSeek) {
      if (skipSeparationSpace(state, true, -1)) {
        atNewLine = true;

        if (state.lineIndent > parentIndent) {
          indentStatus = 1;
        } else if (state.lineIndent === parentIndent) {
          indentStatus = 0;
        } else if (state.lineIndent < parentIndent) {
          indentStatus = -1;
        }
      }
    }

    if (indentStatus === 1) {
      while (readTagProperty(state) || readAnchorProperty(state)) {
        if (skipSeparationSpace(state, true, -1)) {
          atNewLine = true;
          allowBlockCollections = allowBlockStyles;

          if (state.lineIndent > parentIndent) {
            indentStatus = 1;
          } else if (state.lineIndent === parentIndent) {
            indentStatus = 0;
          } else if (state.lineIndent < parentIndent) {
            indentStatus = -1;
          }
        } else {
          allowBlockCollections = false;
        }
      }
    }

    if (allowBlockCollections) {
      allowBlockCollections = atNewLine || allowCompact;
    }

    if (indentStatus === 1 || CONTEXT_BLOCK_OUT === nodeContext) {
      if (CONTEXT_FLOW_IN === nodeContext || CONTEXT_FLOW_OUT === nodeContext) {
        flowIndent = parentIndent;
      } else {
        flowIndent = parentIndent + 1;
      }

      blockIndent = state.position - state.lineStart;

      if (indentStatus === 1) {
        if (allowBlockCollections && (readBlockSequence(state, blockIndent) || readBlockMapping(state, blockIndent, flowIndent)) || readFlowCollection(state, flowIndent)) {
          hasContent = true;
        } else {
          if (allowBlockScalars && readBlockScalar(state, flowIndent) || readSingleQuotedScalar(state, flowIndent) || readDoubleQuotedScalar(state, flowIndent)) {
            hasContent = true;
          } else if (readAlias(state)) {
            hasContent = true;

            if (state.tag !== null || state.anchor !== null) {
              throwError(state, 'alias node should not have any properties');
            }
          } else if (readPlainScalar(state, flowIndent, CONTEXT_FLOW_IN === nodeContext)) {
            hasContent = true;

            if (state.tag === null) {
              state.tag = '?';
            }
          }

          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else if (indentStatus === 0) {
        // Special case: block sequences are allowed to have same indentation level as the parent.
        // http://www.yaml.org/spec/1.2/spec.html#id2799784
        hasContent = allowBlockCollections && readBlockSequence(state, blockIndent);
      }
    }

    if (state.tag !== null && state.tag !== '!') {
      if (state.tag === '?') {
        // Implicit resolving is not allowed for non-scalar types, and '?'
        // non-specific tag is only automatically assigned to plain scalars.
        //
        // We only need to check kind conformity in case user explicitly assigns '?'
        // tag, for example like this: "!<?> [0]"
        //
        if (state.result !== null && state.kind !== 'scalar') {
          throwError(state, 'unacceptable node kind for !<?> tag; it should be "scalar", not "' + state.kind + '"');
        }

        for (typeIndex = 0, typeQuantity = state.implicitTypes.length; typeIndex < typeQuantity; typeIndex += 1) {
          type = state.implicitTypes[typeIndex];

          if (type.resolve(state.result)) {
            // `state.result` updated in resolver if matched
            state.result = type.construct(state.result);
            state.tag = type.tag;

            if (state.anchor !== null) {
              state.anchorMap[state.anchor] = state.result;
            }

            break;
          }
        }
      } else if (_hasOwnProperty$2.call(state.typeMap[state.kind || 'fallback'], state.tag)) {
        type = state.typeMap[state.kind || 'fallback'][state.tag];

        if (state.result !== null && type.kind !== state.kind) {
          throwError(state, 'unacceptable node kind for !<' + state.tag + '> tag; it should be "' + type.kind + '", not "' + state.kind + '"');
        }

        if (!type.resolve(state.result)) {
          // `state.result` updated in resolver if matched
          throwError(state, 'cannot resolve a node with !<' + state.tag + '> explicit tag');
        } else {
          state.result = type.construct(state.result);

          if (state.anchor !== null) {
            state.anchorMap[state.anchor] = state.result;
          }
        }
      } else {
        throwError(state, 'unknown tag !<' + state.tag + '>');
      }
    }

    if (state.listener !== null) {
      state.listener('close', state);
    }

    return state.tag !== null || state.anchor !== null || hasContent;
  }

  function readDocument(state) {
    var documentStart = state.position,
        _position,
        directiveName,
        directiveArgs,
        hasDirectives = false,
        ch;

    state.version = null;
    state.checkLineBreaks = state.legacy;
    state.tagMap = {};
    state.anchorMap = {};

    while ((ch = state.input.charCodeAt(state.position)) !== 0) {
      skipSeparationSpace(state, true, -1);
      ch = state.input.charCodeAt(state.position);

      if (state.lineIndent > 0 || ch !== 0x25
      /* % */
      ) {
          break;
        }

      hasDirectives = true;
      ch = state.input.charCodeAt(++state.position);
      _position = state.position;

      while (ch !== 0 && !is_WS_OR_EOL(ch)) {
        ch = state.input.charCodeAt(++state.position);
      }

      directiveName = state.input.slice(_position, state.position);
      directiveArgs = [];

      if (directiveName.length < 1) {
        throwError(state, 'directive name must not be less than one character in length');
      }

      while (ch !== 0) {
        while (is_WHITE_SPACE(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        if (ch === 0x23
        /* # */
        ) {
            do {
              ch = state.input.charCodeAt(++state.position);
            } while (ch !== 0 && !is_EOL(ch));

            break;
          }

        if (is_EOL(ch)) break;
        _position = state.position;

        while (ch !== 0 && !is_WS_OR_EOL(ch)) {
          ch = state.input.charCodeAt(++state.position);
        }

        directiveArgs.push(state.input.slice(_position, state.position));
      }

      if (ch !== 0) readLineBreak(state);

      if (_hasOwnProperty$2.call(directiveHandlers, directiveName)) {
        directiveHandlers[directiveName](state, directiveName, directiveArgs);
      } else {
        throwWarning(state, 'unknown document directive "' + directiveName + '"');
      }
    }

    skipSeparationSpace(state, true, -1);

    if (state.lineIndent === 0 && state.input.charCodeAt(state.position) === 0x2D
    /* - */
    && state.input.charCodeAt(state.position + 1) === 0x2D
    /* - */
    && state.input.charCodeAt(state.position + 2) === 0x2D
    /* - */
    ) {
        state.position += 3;
        skipSeparationSpace(state, true, -1);
      } else if (hasDirectives) {
      throwError(state, 'directives end mark is expected');
    }

    composeNode(state, state.lineIndent - 1, CONTEXT_BLOCK_OUT, false, true);
    skipSeparationSpace(state, true, -1);

    if (state.checkLineBreaks && PATTERN_NON_ASCII_LINE_BREAKS.test(state.input.slice(documentStart, state.position))) {
      throwWarning(state, 'non-ASCII line breaks are interpreted as content');
    }

    state.documents.push(state.result);

    if (state.position === state.lineStart && testDocumentSeparator(state)) {
      if (state.input.charCodeAt(state.position) === 0x2E
      /* . */
      ) {
          state.position += 3;
          skipSeparationSpace(state, true, -1);
        }

      return;
    }

    if (state.position < state.length - 1) {
      throwError(state, 'end of the stream or a document separator is expected');
    } else {
      return;
    }
  }

  function loadDocuments(input, options) {
    input = String(input);
    options = options || {};

    if (input.length !== 0) {
      // Add tailing `\n` if not exists
      if (input.charCodeAt(input.length - 1) !== 0x0A
      /* LF */
      && input.charCodeAt(input.length - 1) !== 0x0D
      /* CR */
      ) {
          input += '\n';
        } // Strip BOM


      if (input.charCodeAt(0) === 0xFEFF) {
        input = input.slice(1);
      }
    }

    var state = new State(input, options);
    var nullpos = input.indexOf('\0');

    if (nullpos !== -1) {
      state.position = nullpos;
      throwError(state, 'null byte is not allowed in input');
    } // Use 0 as string terminator. That significantly simplifies bounds check.


    state.input += '\0';

    while (state.input.charCodeAt(state.position) === 0x20
    /* Space */
    ) {
      state.lineIndent += 1;
      state.position += 1;
    }

    while (state.position < state.length - 1) {
      readDocument(state);
    }

    return state.documents;
  }

  function loadAll(input, iterator, options) {
    if (iterator !== null && typeof iterator === 'object' && typeof options === 'undefined') {
      options = iterator;
      iterator = null;
    }

    var documents = loadDocuments(input, options);

    if (typeof iterator !== 'function') {
      return documents;
    }

    for (var index = 0, length = documents.length; index < length; index += 1) {
      iterator(documents[index]);
    }
  }

  function load(input, options) {
    var documents = loadDocuments(input, options);

    if (documents.length === 0) {
      /*eslint-disable no-undefined*/
      return undefined;
    } else if (documents.length === 1) {
      return documents[0];
    }

    throw new exception('expected a single document in the stream, but found more');
  }

  function safeLoadAll(input, iterator, options) {
    if (typeof iterator === 'object' && iterator !== null && typeof options === 'undefined') {
      options = iterator;
      iterator = null;
    }

    return loadAll(input, iterator, common.extend({
      schema: default_safe
    }, options));
  }

  function safeLoad(input, options) {
    return load(input, common.extend({
      schema: default_safe
    }, options));
  }

  var loadAll_1 = loadAll;
  var load_1 = load;
  var safeLoadAll_1 = safeLoadAll;
  var safeLoad_1 = safeLoad;
  var loader = {
    loadAll: loadAll_1,
    load: load_1,
    safeLoadAll: safeLoadAll_1,
    safeLoad: safeLoad_1
  };

  /*eslint-disable no-use-before-define*/


  var _toString$2 = Object.prototype.toString;
  var _hasOwnProperty$3 = Object.prototype.hasOwnProperty;
  var CHAR_TAB = 0x09;
  /* Tab */

  var CHAR_LINE_FEED = 0x0A;
  /* LF */

  var CHAR_CARRIAGE_RETURN = 0x0D;
  /* CR */

  var CHAR_SPACE = 0x20;
  /* Space */

  var CHAR_EXCLAMATION = 0x21;
  /* ! */

  var CHAR_DOUBLE_QUOTE = 0x22;
  /* " */

  var CHAR_SHARP = 0x23;
  /* # */

  var CHAR_PERCENT = 0x25;
  /* % */

  var CHAR_AMPERSAND = 0x26;
  /* & */

  var CHAR_SINGLE_QUOTE = 0x27;
  /* ' */

  var CHAR_ASTERISK = 0x2A;
  /* * */

  var CHAR_COMMA = 0x2C;
  /* , */

  var CHAR_MINUS = 0x2D;
  /* - */

  var CHAR_COLON = 0x3A;
  /* : */

  var CHAR_EQUALS = 0x3D;
  /* = */

  var CHAR_GREATER_THAN = 0x3E;
  /* > */

  var CHAR_QUESTION = 0x3F;
  /* ? */

  var CHAR_COMMERCIAL_AT = 0x40;
  /* @ */

  var CHAR_LEFT_SQUARE_BRACKET = 0x5B;
  /* [ */

  var CHAR_RIGHT_SQUARE_BRACKET = 0x5D;
  /* ] */

  var CHAR_GRAVE_ACCENT = 0x60;
  /* ` */

  var CHAR_LEFT_CURLY_BRACKET = 0x7B;
  /* { */

  var CHAR_VERTICAL_LINE = 0x7C;
  /* | */

  var CHAR_RIGHT_CURLY_BRACKET = 0x7D;
  /* } */

  var ESCAPE_SEQUENCES = {};
  ESCAPE_SEQUENCES[0x00] = '\\0';
  ESCAPE_SEQUENCES[0x07] = '\\a';
  ESCAPE_SEQUENCES[0x08] = '\\b';
  ESCAPE_SEQUENCES[0x09] = '\\t';
  ESCAPE_SEQUENCES[0x0A] = '\\n';
  ESCAPE_SEQUENCES[0x0B] = '\\v';
  ESCAPE_SEQUENCES[0x0C] = '\\f';
  ESCAPE_SEQUENCES[0x0D] = '\\r';
  ESCAPE_SEQUENCES[0x1B] = '\\e';
  ESCAPE_SEQUENCES[0x22] = '\\"';
  ESCAPE_SEQUENCES[0x5C] = '\\\\';
  ESCAPE_SEQUENCES[0x85] = '\\N';
  ESCAPE_SEQUENCES[0xA0] = '\\_';
  ESCAPE_SEQUENCES[0x2028] = '\\L';
  ESCAPE_SEQUENCES[0x2029] = '\\P';
  var DEPRECATED_BOOLEANS_SYNTAX = ['y', 'Y', 'yes', 'Yes', 'YES', 'on', 'On', 'ON', 'n', 'N', 'no', 'No', 'NO', 'off', 'Off', 'OFF'];

  function compileStyleMap(schema, map) {
    var result, keys, index, length, tag, style, type;
    if (map === null) return {};
    result = {};
    keys = Object.keys(map);

    for (index = 0, length = keys.length; index < length; index += 1) {
      tag = keys[index];
      style = String(map[tag]);

      if (tag.slice(0, 2) === '!!') {
        tag = 'tag:yaml.org,2002:' + tag.slice(2);
      }

      type = schema.compiledTypeMap['fallback'][tag];

      if (type && _hasOwnProperty$3.call(type.styleAliases, style)) {
        style = type.styleAliases[style];
      }

      result[tag] = style;
    }

    return result;
  }

  function encodeHex(character) {
    var string, handle, length;
    string = character.toString(16).toUpperCase();

    if (character <= 0xFF) {
      handle = 'x';
      length = 2;
    } else if (character <= 0xFFFF) {
      handle = 'u';
      length = 4;
    } else if (character <= 0xFFFFFFFF) {
      handle = 'U';
      length = 8;
    } else {
      throw new exception('code point within a string may not be greater than 0xFFFFFFFF');
    }

    return '\\' + handle + common.repeat('0', length - string.length) + string;
  }

  function State$1(options) {
    this.schema = options['schema'] || default_full;
    this.indent = Math.max(1, options['indent'] || 2);
    this.noArrayIndent = options['noArrayIndent'] || false;
    this.skipInvalid = options['skipInvalid'] || false;
    this.flowLevel = common.isNothing(options['flowLevel']) ? -1 : options['flowLevel'];
    this.styleMap = compileStyleMap(this.schema, options['styles'] || null);
    this.sortKeys = options['sortKeys'] || false;
    this.lineWidth = options['lineWidth'] || 80;
    this.noRefs = options['noRefs'] || false;
    this.noCompatMode = options['noCompatMode'] || false;
    this.condenseFlow = options['condenseFlow'] || false;
    this.implicitTypes = this.schema.compiledImplicit;
    this.explicitTypes = this.schema.compiledExplicit;
    this.tag = null;
    this.result = '';
    this.duplicates = [];
    this.usedDuplicates = null;
  } // Indents every line in a string. Empty lines (\n only) are not indented.


  function indentString(string, spaces) {
    var ind = common.repeat(' ', spaces),
        position = 0,
        next = -1,
        result = '',
        line,
        length = string.length;

    while (position < length) {
      next = string.indexOf('\n', position);

      if (next === -1) {
        line = string.slice(position);
        position = length;
      } else {
        line = string.slice(position, next + 1);
        position = next + 1;
      }

      if (line.length && line !== '\n') result += ind;
      result += line;
    }

    return result;
  }

  function generateNextLine(state, level) {
    return '\n' + common.repeat(' ', state.indent * level);
  }

  function testImplicitResolving(state, str) {
    var index, length, type;

    for (index = 0, length = state.implicitTypes.length; index < length; index += 1) {
      type = state.implicitTypes[index];

      if (type.resolve(str)) {
        return true;
      }
    }

    return false;
  } // [33] s-white ::= s-space | s-tab


  function isWhitespace(c) {
    return c === CHAR_SPACE || c === CHAR_TAB;
  } // Returns true if the character can be printed without escaping.
  // From YAML 1.2: "any allowed characters known to be non-printable
  // should also be escaped. [However,] This isnt mandatory"
  // Derived from nb-char - \t - #x85 - #xA0 - #x2028 - #x2029.


  function isPrintable(c) {
    return 0x00020 <= c && c <= 0x00007E || 0x000A1 <= c && c <= 0x00D7FF && c !== 0x2028 && c !== 0x2029 || 0x0E000 <= c && c <= 0x00FFFD && c !== 0xFEFF
    /* BOM */
    || 0x10000 <= c && c <= 0x10FFFF;
  } // [34] ns-char ::= nb-char - s-white
  // [27] nb-char ::= c-printable - b-char - c-byte-order-mark
  // [26] b-char  ::= b-line-feed | b-carriage-return
  // [24] b-line-feed       ::=     #xA    /* LF */
  // [25] b-carriage-return ::=     #xD    /* CR */
  // [3]  c-byte-order-mark ::=     #xFEFF


  function isNsChar(c) {
    return isPrintable(c) && !isWhitespace(c) // byte-order-mark
    && c !== 0xFEFF // b-char
    && c !== CHAR_CARRIAGE_RETURN && c !== CHAR_LINE_FEED;
  } // Simplified test for values allowed after the first character in plain style.


  function isPlainSafe(c, prev) {
    // Uses a subset of nb-char - c-flow-indicator - ":" - "#"
    // where nb-char ::= c-printable - b-char - c-byte-order-mark.
    return isPrintable(c) && c !== 0xFEFF // - c-flow-indicator
    && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // - ":" - "#"
    // /* An ns-char preceding */ "#"
    && c !== CHAR_COLON && (c !== CHAR_SHARP || prev && isNsChar(prev));
  } // Simplified test for values allowed as the first character in plain style.


  function isPlainSafeFirst(c) {
    // Uses a subset of ns-char - c-indicator
    // where ns-char = nb-char - s-white.
    return isPrintable(c) && c !== 0xFEFF && !isWhitespace(c) // - s-white
    // - (c-indicator ::=
    // - | ? | : | , | [ | ] | { | }
    && c !== CHAR_MINUS && c !== CHAR_QUESTION && c !== CHAR_COLON && c !== CHAR_COMMA && c !== CHAR_LEFT_SQUARE_BRACKET && c !== CHAR_RIGHT_SQUARE_BRACKET && c !== CHAR_LEFT_CURLY_BRACKET && c !== CHAR_RIGHT_CURLY_BRACKET // | # | & | * | ! | | | = | > | ' | "
    && c !== CHAR_SHARP && c !== CHAR_AMPERSAND && c !== CHAR_ASTERISK && c !== CHAR_EXCLAMATION && c !== CHAR_VERTICAL_LINE && c !== CHAR_EQUALS && c !== CHAR_GREATER_THAN && c !== CHAR_SINGLE_QUOTE && c !== CHAR_DOUBLE_QUOTE // | % | @ | `)
    && c !== CHAR_PERCENT && c !== CHAR_COMMERCIAL_AT && c !== CHAR_GRAVE_ACCENT;
  } // Determines whether block indentation indicator is required.


  function needIndentIndicator(string) {
    var leadingSpaceRe = /^\n* /;
    return leadingSpaceRe.test(string);
  }

  var STYLE_PLAIN = 1,
      STYLE_SINGLE = 2,
      STYLE_LITERAL = 3,
      STYLE_FOLDED = 4,
      STYLE_DOUBLE = 5; // Determines which scalar styles are possible and returns the preferred style.
  // lineWidth = -1 => no limit.
  // Pre-conditions: str.length > 0.
  // Post-conditions:
  //    STYLE_PLAIN or STYLE_SINGLE => no \n are in the string.
  //    STYLE_LITERAL => no lines are suitable for folding (or lineWidth is -1).
  //    STYLE_FOLDED => a line > lineWidth and can be folded (and lineWidth != -1).

  function chooseScalarStyle(string, singleLineOnly, indentPerLevel, lineWidth, testAmbiguousType) {
    var i;
    var char, prev_char;
    var hasLineBreak = false;
    var hasFoldableLine = false; // only checked if shouldTrackWidth

    var shouldTrackWidth = lineWidth !== -1;
    var previousLineBreak = -1; // count the first line correctly

    var plain = isPlainSafeFirst(string.charCodeAt(0)) && !isWhitespace(string.charCodeAt(string.length - 1));

    if (singleLineOnly) {
      // Case: no block styles.
      // Check for disallowed characters to rule out plain and single.
      for (i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);

        if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }

        prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
        plain = plain && isPlainSafe(char, prev_char);
      }
    } else {
      // Case: block styles permitted.
      for (i = 0; i < string.length; i++) {
        char = string.charCodeAt(i);

        if (char === CHAR_LINE_FEED) {
          hasLineBreak = true; // Check if any line can be folded.

          if (shouldTrackWidth) {
            hasFoldableLine = hasFoldableLine || // Foldable line = too long, and not more-indented.
            i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
            previousLineBreak = i;
          }
        } else if (!isPrintable(char)) {
          return STYLE_DOUBLE;
        }

        prev_char = i > 0 ? string.charCodeAt(i - 1) : null;
        plain = plain && isPlainSafe(char, prev_char);
      } // in case the end is missing a \n


      hasFoldableLine = hasFoldableLine || shouldTrackWidth && i - previousLineBreak - 1 > lineWidth && string[previousLineBreak + 1] !== ' ';
    } // Although every style can represent \n without escaping, prefer block styles
    // for multiline, since they're more readable and they don't add empty lines.
    // Also prefer folding a super-long line.


    if (!hasLineBreak && !hasFoldableLine) {
      // Strings interpretable as another type have to be quoted;
      // e.g. the string 'true' vs. the boolean true.
      return plain && !testAmbiguousType(string) ? STYLE_PLAIN : STYLE_SINGLE;
    } // Edge case: block indentation indicator can only have one digit.


    if (indentPerLevel > 9 && needIndentIndicator(string)) {
      return STYLE_DOUBLE;
    } // At this point we know block styles are valid.
    // Prefer literal style unless we want to fold.


    return hasFoldableLine ? STYLE_FOLDED : STYLE_LITERAL;
  } // Note: line breaking/folding is implemented for only the folded style.
  // NB. We drop the last trailing newline (if any) of a returned block scalar
  //  since the dumper adds its own newline. This always works:
  //     No ending newline => unaffected; already using strip "-" chomping.
  //     Ending newline    => removed then restored.
  //  Importantly, this keeps the "+" chomp indicator from gaining an extra line.


  function writeScalar(state, string, level, iskey) {
    state.dump = function () {
      if (string.length === 0) {
        return "''";
      }

      if (!state.noCompatMode && DEPRECATED_BOOLEANS_SYNTAX.indexOf(string) !== -1) {
        return "'" + string + "'";
      }

      var indent = state.indent * Math.max(1, level); // no 0-indent scalars
      // As indentation gets deeper, let the width decrease monotonically
      // to the lower bound min(state.lineWidth, 40).
      // Note that this implies
      //  state.lineWidth  40 + state.indent: width is fixed at the lower bound.
      //  state.lineWidth > 40 + state.indent: width decreases until the lower bound.
      // This behaves better than a constant minimum width which disallows narrower options,
      // or an indent threshold which causes the width to suddenly increase.

      var lineWidth = state.lineWidth === -1 ? -1 : Math.max(Math.min(state.lineWidth, 40), state.lineWidth - indent); // Without knowing if keys are implicit/explicit, assume implicit for safety.

      var singleLineOnly = iskey // No block styles in flow mode.
      || state.flowLevel > -1 && level >= state.flowLevel;

      function testAmbiguity(string) {
        return testImplicitResolving(state, string);
      }

      switch (chooseScalarStyle(string, singleLineOnly, state.indent, lineWidth, testAmbiguity)) {
        case STYLE_PLAIN:
          return string;

        case STYLE_SINGLE:
          return "'" + string.replace(/'/g, "''") + "'";

        case STYLE_LITERAL:
          return '|' + blockHeader(string, state.indent) + dropEndingNewline(indentString(string, indent));

        case STYLE_FOLDED:
          return '>' + blockHeader(string, state.indent) + dropEndingNewline(indentString(foldString(string, lineWidth), indent));

        case STYLE_DOUBLE:
          return '"' + escapeString(string) + '"';

        default:
          throw new exception('impossible error: invalid scalar style');
      }
    }();
  } // Pre-conditions: string is valid for a block scalar, 1 <= indentPerLevel <= 9.


  function blockHeader(string, indentPerLevel) {
    var indentIndicator = needIndentIndicator(string) ? String(indentPerLevel) : ''; // note the special case: the string '\n' counts as a "trailing" empty line.

    var clip = string[string.length - 1] === '\n';
    var keep = clip && (string[string.length - 2] === '\n' || string === '\n');
    var chomp = keep ? '+' : clip ? '' : '-';
    return indentIndicator + chomp + '\n';
  } // (See the note for writeScalar.)


  function dropEndingNewline(string) {
    return string[string.length - 1] === '\n' ? string.slice(0, -1) : string;
  } // Note: a long line without a suitable break point will exceed the width limit.
  // Pre-conditions: every char in str isPrintable, str.length > 0, width > 0.


  function foldString(string, width) {
    // In folded style, $k$ consecutive newlines output as $k+1$ newlines
    // unless they're before or after a more-indented line, or at the very
    // beginning or end, in which case $k$ maps to $k$.
    // Therefore, parse each chunk as newline(s) followed by a content line.
    var lineRe = /(\n+)([^\n]*)/g; // first line (possibly an empty line)

    var result = function () {
      var nextLF = string.indexOf('\n');
      nextLF = nextLF !== -1 ? nextLF : string.length;
      lineRe.lastIndex = nextLF;
      return foldLine(string.slice(0, nextLF), width);
    }(); // If we haven't reached the first content line yet, don't add an extra \n.


    var prevMoreIndented = string[0] === '\n' || string[0] === ' ';
    var moreIndented; // rest of the lines

    var match;

    while (match = lineRe.exec(string)) {
      var prefix = match[1],
          line = match[2];
      moreIndented = line[0] === ' ';
      result += prefix + (!prevMoreIndented && !moreIndented && line !== '' ? '\n' : '') + foldLine(line, width);
      prevMoreIndented = moreIndented;
    }

    return result;
  } // Greedy line breaking.
  // Picks the longest line under the limit each time,
  // otherwise settles for the shortest line over the limit.
  // NB. More-indented lines *cannot* be folded, as that would add an extra \n.


  function foldLine(line, width) {
    if (line === '' || line[0] === ' ') return line; // Since a more-indented line adds a \n, breaks can't be followed by a space.

    var breakRe = / [^ ]/g; // note: the match index will always be <= length-2.

    var match; // start is an inclusive index. end, curr, and next are exclusive.

    var start = 0,
        end,
        curr = 0,
        next = 0;
    var result = ''; // Invariants: 0 <= start <= length-1.
    //   0 <= curr <= next <= max(0, length-2). curr - start <= width.
    // Inside the loop:
    //   A match implies length >= 2, so curr and next are <= length-2.

    while (match = breakRe.exec(line)) {
      next = match.index; // maintain invariant: curr - start <= width

      if (next - start > width) {
        end = curr > start ? curr : next; // derive end <= length-2

        result += '\n' + line.slice(start, end); // skip the space that was output as \n

        start = end + 1; // derive start <= length-1
      }

      curr = next;
    } // By the invariants, start <= length-1, so there is something left over.
    // It is either the whole string or a part starting from non-whitespace.


    result += '\n'; // Insert a break if the remainder is too long and there is a break available.

    if (line.length - start > width && curr > start) {
      result += line.slice(start, curr) + '\n' + line.slice(curr + 1);
    } else {
      result += line.slice(start);
    }

    return result.slice(1); // drop extra \n joiner
  } // Escapes a double-quoted string.


  function escapeString(string) {
    var result = '';
    var char, nextChar;
    var escapeSeq;

    for (var i = 0; i < string.length; i++) {
      char = string.charCodeAt(i); // Check for surrogate pairs (reference Unicode 3.0 section "3.7 Surrogates").

      if (char >= 0xD800 && char <= 0xDBFF
      /* high surrogate */
      ) {
          nextChar = string.charCodeAt(i + 1);

          if (nextChar >= 0xDC00 && nextChar <= 0xDFFF
          /* low surrogate */
          ) {
              // Combine the surrogate pair and store it escaped.
              result += encodeHex((char - 0xD800) * 0x400 + nextChar - 0xDC00 + 0x10000); // Advance index one extra since we already used that char here.

              i++;
              continue;
            }
        }

      escapeSeq = ESCAPE_SEQUENCES[char];
      result += !escapeSeq && isPrintable(char) ? string[i] : escapeSeq || encodeHex(char);
    }

    return result;
  }

  function writeFlowSequence(state, level, object) {
    var _result = '',
        _tag = state.tag,
        index,
        length;

    for (index = 0, length = object.length; index < length; index += 1) {
      // Write only valid elements.
      if (writeNode(state, level, object[index], false, false)) {
        if (index !== 0) _result += ',' + (!state.condenseFlow ? ' ' : '');
        _result += state.dump;
      }
    }

    state.tag = _tag;
    state.dump = '[' + _result + ']';
  }

  function writeBlockSequence(state, level, object, compact) {
    var _result = '',
        _tag = state.tag,
        index,
        length;

    for (index = 0, length = object.length; index < length; index += 1) {
      // Write only valid elements.
      if (writeNode(state, level + 1, object[index], true, true)) {
        if (!compact || index !== 0) {
          _result += generateNextLine(state, level);
        }

        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          _result += '-';
        } else {
          _result += '- ';
        }

        _result += state.dump;
      }
    }

    state.tag = _tag;
    state.dump = _result || '[]'; // Empty sequence if no valid values.
  }

  function writeFlowMapping(state, level, object) {
    var _result = '',
        _tag = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        pairBuffer;

    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = '';
      if (index !== 0) pairBuffer += ', ';
      if (state.condenseFlow) pairBuffer += '"';
      objectKey = objectKeyList[index];
      objectValue = object[objectKey];

      if (!writeNode(state, level, objectKey, false, false)) {
        continue; // Skip this pair because of invalid key;
      }

      if (state.dump.length > 1024) pairBuffer += '? ';
      pairBuffer += state.dump + (state.condenseFlow ? '"' : '') + ':' + (state.condenseFlow ? '' : ' ');

      if (!writeNode(state, level, objectValue, false, false)) {
        continue; // Skip this pair because of invalid value.
      }

      pairBuffer += state.dump; // Both key and value are valid.

      _result += pairBuffer;
    }

    state.tag = _tag;
    state.dump = '{' + _result + '}';
  }

  function writeBlockMapping(state, level, object, compact) {
    var _result = '',
        _tag = state.tag,
        objectKeyList = Object.keys(object),
        index,
        length,
        objectKey,
        objectValue,
        explicitPair,
        pairBuffer; // Allow sorting keys so that the output file is deterministic

    if (state.sortKeys === true) {
      // Default sorting
      objectKeyList.sort();
    } else if (typeof state.sortKeys === 'function') {
      // Custom sort function
      objectKeyList.sort(state.sortKeys);
    } else if (state.sortKeys) {
      // Something is wrong
      throw new exception('sortKeys must be a boolean or a function');
    }

    for (index = 0, length = objectKeyList.length; index < length; index += 1) {
      pairBuffer = '';

      if (!compact || index !== 0) {
        pairBuffer += generateNextLine(state, level);
      }

      objectKey = objectKeyList[index];
      objectValue = object[objectKey];

      if (!writeNode(state, level + 1, objectKey, true, true, true)) {
        continue; // Skip this pair because of invalid key.
      }

      explicitPair = state.tag !== null && state.tag !== '?' || state.dump && state.dump.length > 1024;

      if (explicitPair) {
        if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
          pairBuffer += '?';
        } else {
          pairBuffer += '? ';
        }
      }

      pairBuffer += state.dump;

      if (explicitPair) {
        pairBuffer += generateNextLine(state, level);
      }

      if (!writeNode(state, level + 1, objectValue, true, explicitPair)) {
        continue; // Skip this pair because of invalid value.
      }

      if (state.dump && CHAR_LINE_FEED === state.dump.charCodeAt(0)) {
        pairBuffer += ':';
      } else {
        pairBuffer += ': ';
      }

      pairBuffer += state.dump; // Both key and value are valid.

      _result += pairBuffer;
    }

    state.tag = _tag;
    state.dump = _result || '{}'; // Empty mapping if no valid pairs.
  }

  function detectType(state, object, explicit) {
    var _result, typeList, index, length, type, style;

    typeList = explicit ? state.explicitTypes : state.implicitTypes;

    for (index = 0, length = typeList.length; index < length; index += 1) {
      type = typeList[index];

      if ((type.instanceOf || type.predicate) && (!type.instanceOf || typeof object === 'object' && object instanceof type.instanceOf) && (!type.predicate || type.predicate(object))) {
        state.tag = explicit ? type.tag : '?';

        if (type.represent) {
          style = state.styleMap[type.tag] || type.defaultStyle;

          if (_toString$2.call(type.represent) === '[object Function]') {
            _result = type.represent(object, style);
          } else if (_hasOwnProperty$3.call(type.represent, style)) {
            _result = type.represent[style](object, style);
          } else {
            throw new exception('!<' + type.tag + '> tag resolver accepts not "' + style + '" style');
          }

          state.dump = _result;
        }

        return true;
      }
    }

    return false;
  } // Serializes `object` and writes it to global `result`.
  // Returns true on success, or false on invalid object.
  //


  function writeNode(state, level, object, block, compact, iskey) {
    state.tag = null;
    state.dump = object;

    if (!detectType(state, object, false)) {
      detectType(state, object, true);
    }

    var type = _toString$2.call(state.dump);

    if (block) {
      block = state.flowLevel < 0 || state.flowLevel > level;
    }

    var objectOrArray = type === '[object Object]' || type === '[object Array]',
        duplicateIndex,
        duplicate;

    if (objectOrArray) {
      duplicateIndex = state.duplicates.indexOf(object);
      duplicate = duplicateIndex !== -1;
    }

    if (state.tag !== null && state.tag !== '?' || duplicate || state.indent !== 2 && level > 0) {
      compact = false;
    }

    if (duplicate && state.usedDuplicates[duplicateIndex]) {
      state.dump = '*ref_' + duplicateIndex;
    } else {
      if (objectOrArray && duplicate && !state.usedDuplicates[duplicateIndex]) {
        state.usedDuplicates[duplicateIndex] = true;
      }

      if (type === '[object Object]') {
        if (block && Object.keys(state.dump).length !== 0) {
          writeBlockMapping(state, level, state.dump, compact);

          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + state.dump;
          }
        } else {
          writeFlowMapping(state, level, state.dump);

          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
          }
        }
      } else if (type === '[object Array]') {
        var arrayLevel = state.noArrayIndent && level > 0 ? level - 1 : level;

        if (block && state.dump.length !== 0) {
          writeBlockSequence(state, arrayLevel, state.dump, compact);

          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + state.dump;
          }
        } else {
          writeFlowSequence(state, arrayLevel, state.dump);

          if (duplicate) {
            state.dump = '&ref_' + duplicateIndex + ' ' + state.dump;
          }
        }
      } else if (type === '[object String]') {
        if (state.tag !== '?') {
          writeScalar(state, state.dump, level, iskey);
        }
      } else {
        if (state.skipInvalid) return false;
        throw new exception('unacceptable kind of an object to dump ' + type);
      }

      if (state.tag !== null && state.tag !== '?') {
        state.dump = '!<' + state.tag + '> ' + state.dump;
      }
    }

    return true;
  }

  function getDuplicateReferences(object, state) {
    var objects = [],
        duplicatesIndexes = [],
        index,
        length;
    inspectNode(object, objects, duplicatesIndexes);

    for (index = 0, length = duplicatesIndexes.length; index < length; index += 1) {
      state.duplicates.push(objects[duplicatesIndexes[index]]);
    }

    state.usedDuplicates = new Array(length);
  }

  function inspectNode(object, objects, duplicatesIndexes) {
    var objectKeyList, index, length;

    if (object !== null && typeof object === 'object') {
      index = objects.indexOf(object);

      if (index !== -1) {
        if (duplicatesIndexes.indexOf(index) === -1) {
          duplicatesIndexes.push(index);
        }
      } else {
        objects.push(object);

        if (Array.isArray(object)) {
          for (index = 0, length = object.length; index < length; index += 1) {
            inspectNode(object[index], objects, duplicatesIndexes);
          }
        } else {
          objectKeyList = Object.keys(object);

          for (index = 0, length = objectKeyList.length; index < length; index += 1) {
            inspectNode(object[objectKeyList[index]], objects, duplicatesIndexes);
          }
        }
      }
    }
  }

  function dump(input, options) {
    options = options || {};
    var state = new State$1(options);
    if (!state.noRefs) getDuplicateReferences(input, state);
    if (writeNode(state, 0, input, true, true)) return state.dump + '\n';
    return '';
  }

  function safeDump(input, options) {
    return dump(input, common.extend({
      schema: default_safe
    }, options));
  }

  var dump_1 = dump;
  var safeDump_1 = safeDump;
  var dumper = {
    dump: dump_1,
    safeDump: safeDump_1
  };

  function deprecated(name) {
    return function () {
      throw new Error('Function ' + name + ' is deprecated and cannot be used.');
    };
  }

  var Type$1 = type;
  var Schema$1 = schema;
  var FAILSAFE_SCHEMA = failsafe;
  var JSON_SCHEMA = json;
  var CORE_SCHEMA = core;
  var DEFAULT_SAFE_SCHEMA = default_safe;
  var DEFAULT_FULL_SCHEMA = default_full;
  var load$1 = loader.load;
  var loadAll$1 = loader.loadAll;
  var safeLoad$1 = loader.safeLoad;
  var safeLoadAll$1 = loader.safeLoadAll;
  var dump$1 = dumper.dump;
  var safeDump$1 = dumper.safeDump;
  var YAMLException$1 = exception; // Deprecated schema names from JS-YAML 2.0.x

  var MINIMAL_SCHEMA = failsafe;
  var SAFE_SCHEMA = default_safe;
  var DEFAULT_SCHEMA = default_full; // Deprecated functions from JS-YAML 1.x.x

  var scan = deprecated('scan');
  var parse = deprecated('parse');
  var compose = deprecated('compose');
  var addConstructor = deprecated('addConstructor');
  var jsYaml = {
    Type: Type$1,
    Schema: Schema$1,
    FAILSAFE_SCHEMA: FAILSAFE_SCHEMA,
    JSON_SCHEMA: JSON_SCHEMA,
    CORE_SCHEMA: CORE_SCHEMA,
    DEFAULT_SAFE_SCHEMA: DEFAULT_SAFE_SCHEMA,
    DEFAULT_FULL_SCHEMA: DEFAULT_FULL_SCHEMA,
    load: load$1,
    loadAll: loadAll$1,
    safeLoad: safeLoad$1,
    safeLoadAll: safeLoadAll$1,
    dump: dump$1,
    safeDump: safeDump$1,
    YAMLException: YAMLException$1,
    MINIMAL_SCHEMA: MINIMAL_SCHEMA,
    SAFE_SCHEMA: SAFE_SCHEMA,
    DEFAULT_SCHEMA: DEFAULT_SCHEMA,
    scan: scan,
    parse: parse,
    compose: compose,
    addConstructor: addConstructor
  };

  var jsYaml$1 = jsYaml;

  function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

  function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }
  /**
   * Redirect - object used to redirect some requests
   * e.g.
   * {
   *      title: 1x1-transparent.gif
   *      comment: http://probablyprogramming.com/2009/03/15/the-tiniest-gif-ever
   *      contentType: image/gif;base64
   *      content: R0lGODlhAQABAAAAACH5BAEKAAEALAAAAAABAAEAAAICTAEAOw==
   * }
   * @typedef {Object} Redirect
   * @property {string} title
   * @property {string} comment
   * @property {string} content
   * @property {string} contentType
   */

  var Redirects = /*#__PURE__*/function () {
    /**
     * Converts rawYaml into JS object with sources titles used as keys
     * @param rawYaml
     * @returns {Object<Redirect>} - return object with titles in the keys and RedirectSources
     * in the values
     */
    function Redirects(rawYaml) {
      classCallCheck(this, Redirects);

      try {
        var arrOfRedirects = jsYaml$1.safeLoad(rawYaml);
        this.redirects = arrOfRedirects.reduce(function (acc, redirect) {
          return _objectSpread(_objectSpread({}, acc), {}, defineProperty({}, redirect.title, redirect));
        }, {});
      } catch (e) {
        // eslint-disable-next-line no-console
        console.log("Was unable to load YAML into JS due to: ".concat(e.message));
        throw e;
      }
    }
    /**
     * Returns redirect source object
     * @param {string} title
     * @return {Redirect}
     */


    createClass(Redirects, [{
      key: "getRedirect",
      value: function getRedirect(title) {
        var _this = this;

        if (Object.prototype.hasOwnProperty.call(this.redirects, title)) {
          return this.redirects[title];
        } // look title among aliases


        var values = Object.keys(this.redirects).map(function (key) {
          return _this.redirects[key];
        });
        return values.find(function (redirect) {
          var aliases = redirect.aliases;

          if (!aliases) {
            return false;
          }

          return aliases.indexOf(title) > -1;
        });
      }
    }]);

    return Redirects;
  }();

  return Redirects;

}());
//# sourceMappingURL=redirects.js.map


/**
 * AdGuard Scriptlets
 * Version 1.3.0
 */

(function () {
    /**
     * Generate random six symbols id
     */
    function randomId() {
      return Math.random().toString(36).substr(2, 9);
    }

    /**
     * Set getter and setter to property if it's configurable
     * @param {Object} object target object with property
     * @param {string} property property name
     * @param {Object} descriptor contains getter and setter functions
     * @returns {boolean} is operation successful
     */
    function setPropertyAccess(object, property, descriptor) {
      var currentDescriptor = Object.getOwnPropertyDescriptor(object, property);

      if (currentDescriptor && !currentDescriptor.configurable) {
        return false;
      }

      Object.defineProperty(object, property, descriptor);
      return true;
    }

    /**
     * @typedef Chain
     * @property {Object} base
     * @property {string} prop
     * @property {string} [chain]
     */

    /**
     * Check if the property exists in the base object (recursively)
     *
     * If property doesn't exist in base object,
     * defines this property as 'undefined'
     * and returns base, property name and remaining part of property chain
     *
     * @param {Object} base
     * @param {string} chain
     * @returns {Chain}
     */
    function getPropertyInChain(base, chain) {
      var pos = chain.indexOf('.');

      if (pos === -1) {
        return {
          base: base,
          prop: chain
        };
      }

      var prop = chain.slice(0, pos);
      var nextBase = base[prop];
      chain = chain.slice(pos + 1);

      if (nextBase !== undefined) {
        return getPropertyInChain(nextBase, chain);
      }

      Object.defineProperty(base, prop, {
        configurable: true
      });
      return {
        base: nextBase,
        prop: prop,
        chain: chain
      };
    }

    /**
     * @typedef Chain
     * @property {Object} base
     * @property {string} prop
     * @property {string} [chain]
     */

    /**
     * Check if the property exists in the base object (recursively).
     * Similar to getPropertyInChain but upgraded for json-prune:
     * handle wildcard properties and does not define nonexistent base property as 'undefined'
     *
     * @param {Object} base
     * @param {string} chain
     * @param {boolean} [lookThrough=false]
     * should the method look through it's props in order to wildcard
     * @param {Array} [output=[]] result acc
     * @returns {Chain[]} array of objects
     */
    function getWildcardPropertyInChain(base, chain) {
      var lookThrough = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
      var output = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : [];
      var pos = chain.indexOf('.');

      if (pos === -1) {
        // for paths like 'a.b.*' every final nested prop should be processed
        if (chain === '*') {
          Object.keys(base).forEach(function (key) {
            output.push({
              base: base,
              prop: key
            });
          });
        } else {
          output.push({
            base: base,
            prop: chain
          });
        }

        return output;
      }

      var prop = chain.slice(0, pos);
      var shouldLookThrough = prop === '[]' && Array.isArray(base) || prop === '*' && base instanceof Object;

      if (shouldLookThrough) {
        var nextProp = chain.slice(pos + 1);
        var baseKeys = Object.keys(base); // if there is a wildcard prop in input chain (e.g. 'ad.*.src' for 'ad.0.src ad.1.src'),
        // each one of base keys should be considered as a potential chain prop in final path

        baseKeys.forEach(function (key) {
          var item = base[key];
          getWildcardPropertyInChain(item, nextProp, lookThrough, output);
        });
      }

      var nextBase = base[prop];
      chain = chain.slice(pos + 1);

      if (nextBase !== undefined) {
        getWildcardPropertyInChain(nextBase, chain, lookThrough, output);
      }

      return output;
    }

    /**
     * Escapes special chars in string
     * @param {string} str
     * @returns {string}
     */
    var escapeRegExp = function escapeRegExp(str) {
      return str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
    };
    /**
     * Converts search string to the regexp
     * TODO think about nested dependencies, but be careful with dependency loops
     * @param {string} str search string
     * @returns {RegExp}
     */

    var toRegExp = function toRegExp(str) {
      if (str[0] === '/' && str[str.length - 1] === '/') {
        return new RegExp(str.slice(1, -1));
      }

      var escaped = str.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
      return new RegExp(escaped);
    };
    /**
     * Get string before regexp first match
     * @param {string} str
     * @param {RegExp} rx
     */

    var getBeforeRegExp = function getBeforeRegExp(str, rx) {
      var index = str.search(rx);
      return str.substring(0, index);
    };
    var startsWith = function startsWith(str, prefix) {
      return str && str.indexOf(prefix) === 0;
    };
    var endsWith = function endsWith(str, prefix) {
      return str && str.indexOf(prefix) === str.length - 1;
    };
    var substringAfter = function substringAfter(str, separator) {
      if (!str) {
        return str;
      }

      var index = str.indexOf(separator);
      return index < 0 ? '' : str.substring(index + separator.length);
    };
    var substringBefore = function substringBefore(str, separator) {
      if (!str || !separator) {
        return str;
      }

      var index = str.indexOf(separator);
      return index < 0 ? str : str.substring(0, index);
    };
    /**
     * Wrap str in single qoutes and replaces single quotes to doudle one
     * @param {string} str
     */

    var wrapInSingleQuotes = function wrapInSingleQuotes(str) {
      if (str[0] === '\'' && str[str.length - 1] === '\'' || str[0] === '"' && str[str.length - 1] === '"') {
        str = str.substring(1, str.length - 1);
      } // eslint-disable-next-line no-useless-escape


      str = str.replace(/\'/g, '"');
      return "'".concat(str, "'");
    };
    /**
     * Returns substring enclosed in the widest braces
     * @param {string} str
     */

    var getStringInBraces = function getStringInBraces(str) {
      var firstIndex = str.indexOf('(');
      var lastIndex = str.lastIndexOf(')');
      return str.substring(firstIndex + 1, lastIndex);
    };

    /**
     * Generates function which silents global errors on page generated by scriptlet
     * If error doesn't belong to our error we transfer it to the native onError handler
     * @param {string} rid - unique identifier of scriptlet
     * @return {onError}
     */
    function createOnErrorHandler(rid) {
      // eslint-disable-next-line consistent-return
      var nativeOnError = window.onerror;
      return function onError(error) {
        if (typeof error === 'string' && error.indexOf(rid) !== -1) {
          return true;
        }

        if (nativeOnError instanceof Function) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          return nativeOnError.apply(this, [error].concat(args));
        }

        return false;
      };
    }

    /**
     * Noop function
     */
    var noopFunc = function noopFunc() {};
    /**
     * Function returns null
     */

    var noopNull = function noopNull() {
      return null;
    };
    /**
     * Function returns true
     */

    var trueFunc = function trueFunc() {
      return true;
    };
    /**
     * Function returns false
     */

    var falseFunc = function falseFunc() {
      return false;
    };
    /**
     * Function returns this
     */

    function noopThis() {
      return this;
    }
    /**
     * Function returns empty array
     */

    var noopArray = function noopArray() {
      return [];
    };
    /**
     * Function returns empty string
     */

    var noopStr = function noopStr() {
      return '';
    };

    /* eslint-disable no-console, no-underscore-dangle */

    /**
     * Hit used only for debug purposes now
     * @param {Source} source
     * @param {string} [message] - optional message;
     * use LOG_MARKER = 'log: ' at the start of a message
     * for logging scriptlets
     */
    var hit = function hit(source, message) {
      if (source.verbose !== true) {
        return;
      }

      try {
        var log = console.log.bind(console);
        var trace = console.trace.bind(console);
        var prefix = source.ruleText || '';

        if (source.domainName) {
          var AG_SCRIPTLET_MARKER = '#%#//';
          var UBO_SCRIPTLET_MARKER = '##+js';
          var ruleStartIndex;

          if (source.ruleText.indexOf(AG_SCRIPTLET_MARKER) > -1) {
            ruleStartIndex = source.ruleText.indexOf(AG_SCRIPTLET_MARKER);
          } else if (source.ruleText.indexOf(UBO_SCRIPTLET_MARKER) > -1) {
            ruleStartIndex = source.ruleText.indexOf(UBO_SCRIPTLET_MARKER);
          } // delete all domains from ruleText and leave just rule part


          var rulePart = source.ruleText.slice(ruleStartIndex); // prepare applied scriptlet rule for specific domain

          prefix = "".concat(source.domainName).concat(rulePart);
        } // Used to check if scriptlet uses 'hit' function for logging


        var LOG_MARKER = 'log: ';

        if (message) {
          if (message.indexOf(LOG_MARKER) === -1) {
            log("".concat(prefix, " message:\n").concat(message));
          } else {
            log(message.slice(LOG_MARKER.length));
          }
        }

        log("".concat(prefix, " trace start"));

        if (trace) {
          trace();
        }

        log("".concat(prefix, " trace end"));
      } catch (e) {// try catch for Edge 15
        // In according to this issue https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/14495220/
        // console.log throws an error
      } // This is necessary for unit-tests only!


      if (typeof window.__debug === 'function') {
        window.__debug(source);
      }
    };

    /**
     * DOM tree changes observer. Used for 'remove-attr' and 'remove-class' scriptlets
     * @param {Function} callback
     * @param {Boolean} observeAttrs - optional parameter - should observer check attibutes changes
     */
    var observeDOMChanges = function observeDOMChanges(callback) {
      var observeAttrs = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
      var attrsToObserv = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : [];

      /**
       * Returns a wrapper, passing the call to 'method' at maximum once per 'delay' milliseconds.
       * Those calls that fall into the "cooldown" period, are ignored
       * @param {Function} method
       * @param {Number} delay - milliseconds
       */
      var throttle = function throttle(method, delay) {
        var wait = false;
        var savedArgs;

        var wrapper = function wrapper() {
          for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
            args[_key] = arguments[_key];
          }

          if (wait) {
            savedArgs = args;
            return;
          }

          method.apply(void 0, args);
          wait = true;
          setTimeout(function () {
            wait = false;

            if (savedArgs) {
              wrapper(savedArgs);
              savedArgs = null;
            }
          }, delay);
        };

        return wrapper;
      };
      /**
       * 'delay' in milliseconds for 'throttle' method
       */


      var THROTTLE_DELAY_MS = 20;
      /**
       * Used for remove-class
       */
      // eslint-disable-next-line no-use-before-define

      var observer = new MutationObserver(throttle(callbackWrapper, THROTTLE_DELAY_MS));

      var connect = function connect() {
        if (attrsToObserv.length > 0) {
          observer.observe(document.documentElement, {
            childList: true,
            subtree: true,
            attributes: observeAttrs,
            attributeFilter: attrsToObserv
          });
        } else {
          observer.observe(document.documentElement, {
            childList: true,
            subtree: true,
            attributes: observeAttrs
          });
        }
      };

      var disconnect = function disconnect() {
        observer.disconnect();
      };

      function callbackWrapper() {
        disconnect();
        callback();
        connect();
      }

      connect();
    };

    /**
     * Checks if the stackTrace contains stackRegexp
     * // https://github.com/AdguardTeam/Scriptlets/issues/82
     * @param {string} stackRegexp - stack regexp
     * @param {string} stackTrace - script error stack trace
     * @returns {boolean}
     */
    var matchStackTrace = function matchStackTrace(stackRegexp, stackTrace) {
      var refinedStackTrace = stackTrace.split('\n').slice(2) // get rid of our own functions in the stack trace
      .map(function (line) {
        return line.trim();
      }) // trim the lines
      .join('\n');
      return stackRegexp.test(refinedStackTrace);
    };

    /**
     * Some browsers do not support Array.prototype.flat()
     * for example, Opera 42 which is used for browserstack tests
     * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/flat
     * @param {Array} input
     */
    var flatten = function flatten(input) {
      var stack = [];
      input.forEach(function (el) {
        return stack.push(el);
      });
      var res = [];

      while (stack.length) {
        // pop value from stack
        var next = stack.pop();

        if (Array.isArray(next)) {
          // push back array items, won't modify the original input
          next.forEach(function (el) {
            return stack.push(el);
          });
        } else {
          res.push(next);
        }
      } // reverse to restore input order


      return res.reverse();
    };

    /**
     * This file must export all used dependencies
     */

    var dependencies = /*#__PURE__*/Object.freeze({
        __proto__: null,
        randomId: randomId,
        setPropertyAccess: setPropertyAccess,
        getPropertyInChain: getPropertyInChain,
        getWildcardPropertyInChain: getWildcardPropertyInChain,
        escapeRegExp: escapeRegExp,
        toRegExp: toRegExp,
        getBeforeRegExp: getBeforeRegExp,
        startsWith: startsWith,
        endsWith: endsWith,
        substringAfter: substringAfter,
        substringBefore: substringBefore,
        wrapInSingleQuotes: wrapInSingleQuotes,
        getStringInBraces: getStringInBraces,
        createOnErrorHandler: createOnErrorHandler,
        noopFunc: noopFunc,
        noopNull: noopNull,
        trueFunc: trueFunc,
        falseFunc: falseFunc,
        noopThis: noopThis,
        noopArray: noopArray,
        noopStr: noopStr,
        hit: hit,
        observeDOMChanges: observeDOMChanges,
        matchStackTrace: matchStackTrace,
        flatten: flatten
    });

    /**
     * Concat dependencies to scriptlet code
     * @param {string} scriptlet string view of scriptlet
     */

    function attachDependencies(scriptlet) {
      var _scriptlet$injections = scriptlet.injections,
          injections = _scriptlet$injections === void 0 ? [] : _scriptlet$injections;
      return injections.reduce(function (accum, dep) {
        return "".concat(accum, "\n").concat(dependencies[dep.name]);
      }, scriptlet.toString());
    }
    /**
     * Add scriptlet call to existing code
     * @param {Function} scriptlet
     * @param {string} code
     */

    function addCall(scriptlet, code) {
      return "".concat(code, ";\n        const updatedArgs = args ? [].concat(source).concat(args) : [source];\n        ").concat(scriptlet.name, ".apply(this, updatedArgs);\n    ");
    }
    /**
     * Wrap function into IIFE (Immediately invoked function expression)
     *
     * @param {Source} source - object with scriptlet properties
     * @param {string} code - scriptlet source code with dependencies
     *
     * @returns {string} full scriptlet code
     *
     * @example
     * const source = {
     *      args: ["aaa", "bbb"],
     *      name: 'noeval',
     * };
     * const code = "function noeval(source, args) { alert(source); } noeval.apply(this, args);"
     * const result = wrapInIIFE(source, code);
     *
     * // result
     * `(function(source, args) {
     *      function noeval(source) { alert(source); }
     *      noeval.apply(this, args);
     * )({"args": ["aaa", "bbb"], "name":"noeval"}, ["aaa", "bbb"])`
     */

    function passSourceAndProps(source, code) {
      if (source.hit) {
        source.hit = source.hit.toString();
      }

      var sourceString = JSON.stringify(source);
      var argsString = source.args ? "[".concat(source.args.map(JSON.stringify), "]") : undefined;
      var params = argsString ? "".concat(sourceString, ", ").concat(argsString) : sourceString;
      return "(function(source, args){\n".concat(code, "\n})(").concat(params, ");");
    }
    /**
     * Wrap code in no name function
     * @param {string} code which must be wrapped
     */

    function wrapInNonameFunc(code) {
      return "function(source, args){\n".concat(code, "\n}");
    }

    function _arrayWithHoles(arr) {
      if (Array.isArray(arr)) return arr;
    }

    var arrayWithHoles = _arrayWithHoles;

    function _iterableToArrayLimit(arr, i) {
      if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return;
      var _arr = [];
      var _n = true;
      var _d = false;
      var _e = undefined;

      try {
        for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {
          _arr.push(_s.value);

          if (i && _arr.length === i) break;
        }
      } catch (err) {
        _d = true;
        _e = err;
      } finally {
        try {
          if (!_n && _i["return"] != null) _i["return"]();
        } finally {
          if (_d) throw _e;
        }
      }

      return _arr;
    }

    var iterableToArrayLimit = _iterableToArrayLimit;

    function _arrayLikeToArray(arr, len) {
      if (len == null || len > arr.length) len = arr.length;

      for (var i = 0, arr2 = new Array(len); i < len; i++) {
        arr2[i] = arr[i];
      }

      return arr2;
    }

    var arrayLikeToArray = _arrayLikeToArray;

    function _unsupportedIterableToArray(o, minLen) {
      if (!o) return;
      if (typeof o === "string") return arrayLikeToArray(o, minLen);
      var n = Object.prototype.toString.call(o).slice(8, -1);
      if (n === "Object" && o.constructor) n = o.constructor.name;
      if (n === "Map" || n === "Set") return Array.from(o);
      if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return arrayLikeToArray(o, minLen);
    }

    var unsupportedIterableToArray = _unsupportedIterableToArray;

    function _nonIterableRest() {
      throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
    }

    var nonIterableRest = _nonIterableRest;

    function _slicedToArray(arr, i) {
      return arrayWithHoles(arr) || iterableToArrayLimit(arr, i) || unsupportedIterableToArray(arr, i) || nonIterableRest();
    }

    var slicedToArray = _slicedToArray;

    function _defineProperty(obj, key, value) {
      if (key in obj) {
        Object.defineProperty(obj, key, {
          value: value,
          enumerable: true,
          configurable: true,
          writable: true
        });
      } else {
        obj[key] = value;
      }

      return obj;
    }

    var defineProperty = _defineProperty;

    /**
     * Iterate over iterable argument and evaluate current state with transitions
     * @param {string} init first transition name
     * @param {Array|Collection|string} iterable
     * @param {Object} transitions transtion functions
     * @param {any} args arguments which should be passed to transition functions
     */
    function iterateWithTransitions(iterable, transitions, init, args) {
      var state = init || Object.keys(transitions)[0];

      for (var i = 0; i < iterable.length; i += 1) {
        state = transitions[state](iterable, i, args);
      }

      return state;
    }
    /**
     * AdGuard scriptlet rule mask
     */


    var ADG_SCRIPTLET_MASK = '#//scriptlet';
    /**
     * Helper to accumulate an array of strings char by char
     */

    var wordSaver = function wordSaver() {
      var str = '';
      var strs = [];

      var saveSymb = function saveSymb(s) {
        str += s;
        return str;
      };

      var saveStr = function saveStr() {
        strs.push(str);
        str = '';
      };

      var getAll = function getAll() {
        return [].concat(strs);
      };

      return {
        saveSymb: saveSymb,
        saveStr: saveStr,
        getAll: getAll
      };
    };

    var substringAfter$1 = function substringAfter(str, separator) {
      if (!str) {
        return str;
      }

      var index = str.indexOf(separator);
      return index < 0 ? '' : str.substring(index + separator.length);
    };
    /**
     * Parse and validate scriptlet rule
     * @param {*} ruleText
     * @returns {{name: string, args: Array<string>}}
     */


    var parseRule = function parseRule(ruleText) {
      var _transitions;

      ruleText = substringAfter$1(ruleText, ADG_SCRIPTLET_MASK);
      /**
       * Transition names
       */

      var TRANSITION = {
        OPENED: 'opened',
        PARAM: 'param',
        CLOSED: 'closed'
      };
      /**
       * Transition function: the current index position in start, end or between params
       * @param {string} rule
       * @param {number} index
       * @param {Object} Object
       * @property {Object} Object.sep contains prop symb with current separator char
       */

      var opened = function opened(rule, index, _ref) {
        var sep = _ref.sep;
        var char = rule[index];
        var transition;

        switch (char) {
          case ' ':
          case '(':
          case ',':
            {
              transition = TRANSITION.OPENED;
              break;
            }

          case '\'':
          case '"':
            {
              sep.symb = char;
              transition = TRANSITION.PARAM;
              break;
            }

          case ')':
            {
              transition = index === rule.length - 1 ? TRANSITION.CLOSED : TRANSITION.OPENED;
              break;
            }

          default:
            {
              throw new Error('The rule is not a scriptlet');
            }
        }

        return transition;
      };
      /**
       * Transition function: the current index position inside param
       * @param {string} rule
       * @param {number} index
       * @param {Object} Object
       * @property {Object} Object.sep contains prop `symb` with current separator char
       * @property {Object} Object.saver helper which allow to save strings by car by char
       */


      var param = function param(rule, index, _ref2) {
        var saver = _ref2.saver,
            sep = _ref2.sep;
        var char = rule[index];

        switch (char) {
          case '\'':
          case '"':
            {
              var preIndex = index - 1;
              var before = rule[preIndex];

              if (char === sep.symb && before !== '\\') {
                sep.symb = null;
                saver.saveStr();
                return TRANSITION.OPENED;
              }
            }
          // eslint-disable-next-line no-fallthrough

          default:
            {
              saver.saveSymb(char);
              return TRANSITION.PARAM;
            }
        }
      };

      var transitions = (_transitions = {}, defineProperty(_transitions, TRANSITION.OPENED, opened), defineProperty(_transitions, TRANSITION.PARAM, param), defineProperty(_transitions, TRANSITION.CLOSED, function () {}), _transitions);
      var sep = {
        symb: null
      };
      var saver = wordSaver();
      var state = iterateWithTransitions(ruleText, transitions, TRANSITION.OPENED, {
        sep: sep,
        saver: saver
      });

      if (state !== 'closed') {
        throw new Error("Invalid scriptlet rule ".concat(ruleText));
      }

      var args = saver.getAll();
      return {
        name: args[0],
        args: args.slice(1)
      };
    };

    /* eslint-disable max-len */

    /**
     * @scriptlet abort-on-property-read
     *
     * @description
     * Aborts a script when it attempts to **read** the specified property.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-on-property-readjs-
     *
     * Related ABP source:
     * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L864
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('abort-on-property-read', property[, stack])
     * ```
     *
     * - `property` - required, path to a property (joined with `.` if needed). The property must be attached to `window`
     * - `stack` - optional, string or regular expression that must match the current function call stack trace
     *
     * **Examples**
     * ```
     * ! Aborts script when it tries to access `window.alert`
     * example.org#%#//scriptlet('abort-on-property-read', 'alert')
     *
     * ! Aborts script when it tries to access `navigator.language`
     * example.org#%#//scriptlet('abort-on-property-read', 'navigator.language')
     *
     * ! Aborts script when it tries to access `window.adblock` and it's error stack trace contains `test.js`
     * example.org#%#//scriptlet('abort-on-property-read', 'adblock', 'test.js')
     * ```
     */

    /* eslint-enable max-len */

    function abortOnPropertyRead(source, property, stack) {
      var stackRegexp = stack ? toRegExp(stack) : toRegExp('/.?/');

      if (!property || !matchStackTrace(stackRegexp, new Error().stack)) {
        return;
      }

      var rid = randomId();

      var abort = function abort() {
        hit(source);
        throw new ReferenceError(rid);
      };

      var setChainPropAccess = function setChainPropAccess(owner, property) {
        var chainInfo = getPropertyInChain(owner, property);
        var base = chainInfo.base;
        var prop = chainInfo.prop,
            chain = chainInfo.chain;

        if (chain) {
          var setter = function setter(a) {
            base = a;

            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };

          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }

        setPropertyAccess(base, prop, {
          get: abort,
          set: function set() {}
        });
      };

      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    abortOnPropertyRead.names = ['abort-on-property-read', // aliases are needed for matching the related scriptlet converted into our syntax
    'abort-on-property-read.js', 'ubo-abort-on-property-read.js', 'aopr.js', 'ubo-aopr.js', 'ubo-abort-on-property-read', 'ubo-aopr', 'abp-abort-on-property-read'];
    abortOnPropertyRead.injections = [randomId, toRegExp, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, matchStackTrace];

    /* eslint-disable max-len */

    /**
     * @scriptlet abort-on-property-write
     *
     * @description
     * Aborts a script when it attempts to **write** the specified property.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-on-property-writejs-
     *
     * Related ABP source:
     * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L896
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('abort-on-property-write', property[, stack])
     * ```
     *
     * - `property` - required, path to a property (joined with `.` if needed). The property must be attached to `window`
     * - `stack` - optional, string or regular expression that must match the current function call stack trace
     *
     * **Examples**
     * ```
     * ! Aborts script when it tries to set `window.adblock` value
     * example.org#%#//scriptlet('abort-on-property-write', 'adblock')
     *
     * ! Aborts script when it tries to set `window.adblock` value and it's error stack trace contains `checking.js`
     * example.org#%#//scriptlet('abort-on-property-write', 'adblock', 'checking.js')
     * ```
     */

    /* eslint-enable max-len */

    function abortOnPropertyWrite(source, property, stack) {
      var stackRegexp = stack ? toRegExp(stack) : toRegExp('/.?/');

      if (!property || !matchStackTrace(stackRegexp, new Error().stack)) {
        return;
      }

      var rid = randomId();

      var abort = function abort() {
        hit(source);
        throw new ReferenceError(rid);
      };

      var setChainPropAccess = function setChainPropAccess(owner, property) {
        var chainInfo = getPropertyInChain(owner, property);
        var base = chainInfo.base;
        var prop = chainInfo.prop,
            chain = chainInfo.chain;

        if (chain) {
          var setter = function setter(a) {
            base = a;

            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };

          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }

        setPropertyAccess(base, prop, {
          set: abort
        });
      };

      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    abortOnPropertyWrite.names = ['abort-on-property-write', // aliases are needed for matching the related scriptlet converted into our syntax
    'abort-on-property-write.js', 'ubo-abort-on-property-write.js', 'aopw.js', 'ubo-aopw.js', 'ubo-abort-on-property-write', 'ubo-aopw', 'abp-abort-on-property-write'];
    abortOnPropertyWrite.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, toRegExp, matchStackTrace];

    /* eslint-disable max-len */

    /**
     * @scriptlet prevent-setTimeout
     *
     * @description
     * Prevents a `setTimeout` call if:
     * 1) the text of the callback is matching the specified search string/regexp which does not start with `!`;
     * otherwise mismatched calls should be defused;
     * 2) the timeout is matching the specified delay; otherwise mismatched calls should be defused.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-settimeout-ifjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-setTimeout'[, search[, delay]])
     * ```
     *
     * Call with no arguments will log calls to setTimeout while debugging (`log-setTimeout` superseding),
     * so production filter lists' rules definitely require at least one of the parameters:
     * - `search` - optional, string or regular expression.
     * If starts with `!`, scriptlet will not match the stringified callback but all other will be defused.
     * If do not start with `!`, the stringified callback will be matched.
     * If not set, prevents all `setTimeout` calls due to specified `delay`.
     * - `delay` - optional, must be an integer.
     * If starts with `!`, scriptlet will not match the delay but all other will be defused.
     * If do not start with `!`, the delay passed to the `setTimeout` call will be matched.
     *
     * **Examples**
     * 1. Prevents `setTimeout` calls if the callback matches `/\.test/` regardless of the delay.
     *     ```bash
     *     example.org#%#//scriptlet('prevent-setTimeout', '/\.test/')
     *     ```
     *
     *     For instance, the following call will be prevented:
     *     ```javascript
     *     setTimeout(function () {
     *         window.test = "value";
     *     }, 100);
     *     ```
     *
     * 2. Prevents `setTimeout` calls if the callback does not contain `value`.
     *     ```
     *     example.org#%#//scriptlet('prevent-setTimeout', '!value')
     *     ```
     *
     *     For instance, only the first of the following calls will be prevented:
     *     ```javascript
     *     setTimeout(function () {
     *         window.test = "test -- prevented";
     *     }, 300);
     *     setTimeout(function () {
     *         window.test = "value -- executed";
     *     }, 400);
     *     setTimeout(function () {
     *         window.value = "test -- executed";
     *     }, 500);
     *     ```
     *
     * 3. Prevents `setTimeout` calls if the callback contains `value` and the delay is not set to `300`.
     *     ```
     *     example.org#%#//scriptlet('prevent-setTimeout', 'value', '!300')
     *     ```
     *
     *     For instance, only the first of the following calls will not be prevented:
     *     ```javascript
     *     setTimeout(function () {
     *         window.test = "value 1 -- executed";
     *     }, 300);
     *     setTimeout(function () {
     *         window.test = "value 2 -- prevented";
     *     }, 400);
     *     setTimeout(function () {
     *         window.test = "value 3 -- prevented";
     *     }, 500);
     *     ```
     *
     * 4. Prevents `setTimeout` calls if the callback does not contain `value` and the delay is not set to `300`.
     *     ```
     *     example.org#%#//scriptlet('prevent-setTimeout', '!value', '!300')
     *     ```
     *
     *     For instance, only the second of the following calls will be prevented:
     *     ```javascript
     *     setTimeout(function () {
     *         window.test = "test -- executed";
     *     }, 300);
     *     setTimeout(function () {
     *         window.test = "test -- prevented";
     *     }, 400);
     *     setTimeout(function () {
     *         window.test = "value -- executed";
     *     }, 400);
     *     setTimeout(function () {
     *         window.value = "test -- executed";
     *     }, 500);
     *     ```
     */

    /* eslint-enable max-len */

    function preventSetTimeout(source, match, delay) {
      var nativeTimeout = window.setTimeout;
      var nativeIsNaN = Number.isNaN || window.isNaN; // eslint-disable-line compat/compat

      var log = console.log.bind(console); // eslint-disable-line no-console
      // logs setTimeouts to console if no arguments have been specified

      var shouldLog = typeof match === 'undefined' && typeof delay === 'undefined';
      var INVERT_MARKER = '!';
      var isNotMatch = startsWith(match, INVERT_MARKER);

      if (isNotMatch) {
        match = match.slice(1);
      }

      var isNotDelay = startsWith(delay, INVERT_MARKER);

      if (isNotDelay) {
        delay = delay.slice(1);
      }

      delay = parseInt(delay, 10);
      delay = nativeIsNaN(delay) ? null : delay;
      match = match ? toRegExp(match) : toRegExp('/.?/');

      var timeoutWrapper = function timeoutWrapper(callback, timeout) {
        var shouldPrevent = false;

        if (shouldLog) {
          hit(source);
          log("setTimeout(\"".concat(callback.toString(), "\", ").concat(timeout, ")"));
        } else if (!delay) {
          shouldPrevent = match.test(callback.toString()) !== isNotMatch;
        } else if (match === '/.?/') {
          shouldPrevent = timeout === delay !== isNotDelay;
        } else {
          shouldPrevent = match.test(callback.toString()) !== isNotMatch && timeout === delay !== isNotDelay;
        }

        if (shouldPrevent) {
          hit(source);
          return nativeTimeout(noopFunc, timeout);
        }

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        return nativeTimeout.apply(window, [callback, timeout].concat(args));
      };

      window.setTimeout = timeoutWrapper;
    }
    preventSetTimeout.names = ['prevent-setTimeout', // aliases are needed for matching the related scriptlet converted into our syntax
    'no-setTimeout-if.js', // new implementation of setTimeout-defuser.js
    'ubo-no-setTimeout-if.js', 'setTimeout-defuser.js', // old name should be supported as well
    'ubo-setTimeout-defuser.js', 'nostif.js', // new short name of no-setTimeout-if
    'ubo-nostif.js', 'std.js', // old short scriptlet name
    'ubo-std.js', 'ubo-no-setTimeout-if', 'ubo-setTimeout-defuser', 'ubo-nostif', 'ubo-std'];
    preventSetTimeout.injections = [toRegExp, startsWith, hit, noopFunc];

    /* eslint-disable max-len */

    /**
     * @scriptlet prevent-setInterval
     *
     * @description
     * Prevents a `setInterval` call if:
     * 1) the text of the callback is matching the specified `search` string/regexp which does not start with `!`;
     * otherwise mismatched calls should be defused;
     * 2) the interval is matching the specified `delay`; otherwise mismatched calls should be defused.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-setinterval-ifjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-setInterval'[, search[, delay]])
     * ```
     *
     * Call with no arguments will log calls to setInterval while debugging (`log-setInterval` superseding),
     * so production filter lists' rules definitely require at least one of the parameters:
     * - `search` - optional, string or regular expression.
     * If starts with `!`, scriptlet will not match the stringified callback but all other will be defused.
     * If do not start with `!`, the stringified callback will be matched.
     * If not set, prevents all `setInterval` calls due to specified `delay`.
     * - `delay` - optional, must be an integer.
     * If starts with `!`, scriptlet will not match the delay but all other will be defused.
     * If do not start with `!`, the delay passed to the `setInterval` call will be matched.
     *
     *  **Examples**
     * 1. Prevents `setInterval` calls if the callback matches `/\.test/` regardless of the delay.
     *     ```bash
     *     example.org#%#//scriptlet('prevent-setInterval', '/\.test/')
     *     ```
     *
     *     For instance, the following call will be prevented:
     *     ```javascript
     *     setInterval(function () {
     *         window.test = "value";
     *     }, 100);
     *     ```
     *
     * 2. Prevents `setInterval` calls if the callback does not contain `value`.
     *     ```
     *     example.org#%#//scriptlet('prevent-setInterval', '!value')
     *     ```
     *
     *     For instance, only the first of the following calls will be prevented:
     *     ```javascript
     *     setInterval(function () {
     *         window.test = "test -- prevented";
     *     }, 300);
     *     setInterval(function () {
     *         window.test = "value -- executed";
     *     }, 400);
     *     setInterval(function () {
     *         window.value = "test -- executed";
     *     }, 500);
     *     ```
     *
     * 3. Prevents `setInterval` calls if the callback contains `value` and the delay is not set to `300`.
     *     ```
     *     example.org#%#//scriptlet('prevent-setInterval', 'value', '!300')
     *     ```
     *
     *     For instance, only the first of the following calls will not be prevented:
     *     ```javascript
     *     setInterval(function () {
     *         window.test = "value 1 -- executed";
     *     }, 300);
     *     setInterval(function () {
     *         window.test = "value 2 -- prevented";
     *     }, 400);
     *     setInterval(function () {
     *         window.test = "value 3 -- prevented";
     *     }, 500);
     *     ```
     *
     * 4. Prevents `setInterval` calls if the callback does not contain `value` and the delay is not set to `300`.
     *     ```
     *     example.org#%#//scriptlet('prevent-setInterval', '!value', '!300')
     *     ```
     *
     *     For instance, only the second of the following calls will be prevented:
     *     ```javascript
     *     setInterval(function () {
     *         window.test = "test -- executed";
     *     }, 300);
     *     setInterval(function () {
     *         window.test = "test -- prevented";
     *     }, 400);
     *     setInterval(function () {
     *         window.test = "value -- executed";
     *     }, 400);
     *     setInterval(function () {
     *         window.value = "test -- executed";
     *     }, 500);
     *     ```
     */

    /* eslint-enable max-len */

    function preventSetInterval(source, match, delay) {
      var nativeInterval = window.setInterval;
      var nativeIsNaN = Number.isNaN || window.isNaN; // eslint-disable-line compat/compat

      var log = console.log.bind(console); // eslint-disable-line no-console
      // logs setIntervals to console if no arguments have been specified

      var shouldLog = typeof match === 'undefined' && typeof delay === 'undefined';
      var INVERT_MARKER = '!';
      var isNotMatch = startsWith(match, INVERT_MARKER);

      if (isNotMatch) {
        match = match.slice(1);
      }

      var isNotDelay = startsWith(delay, INVERT_MARKER);

      if (isNotDelay) {
        delay = delay.slice(1);
      }

      delay = parseInt(delay, 10);
      delay = nativeIsNaN(delay) ? null : delay;
      match = match ? toRegExp(match) : toRegExp('/.?/');

      var intervalWrapper = function intervalWrapper(callback, interval) {
        var shouldPrevent = false;

        if (shouldLog) {
          hit(source);
          log("setInterval(\"".concat(callback.toString(), "\", ").concat(interval, ")"));
        } else if (!delay) {
          shouldPrevent = match.test(callback.toString()) !== isNotMatch;
        } else if (match === '/.?/') {
          shouldPrevent = interval === delay !== isNotDelay;
        } else {
          shouldPrevent = match.test(callback.toString()) !== isNotMatch && interval === delay !== isNotDelay;
        }

        if (shouldPrevent) {
          hit(source);
          return nativeInterval(noopFunc, interval);
        }

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        return nativeInterval.apply(window, [callback, interval].concat(args));
      };

      window.setInterval = intervalWrapper;
    }
    preventSetInterval.names = ['prevent-setInterval', // aliases are needed for matching the related scriptlet converted into our syntax
    'no-setInterval-if.js', // new implementation of setInterval-defuser.js
    'ubo-no-setInterval-if.js', 'setInterval-defuser.js', // old name should be supported as well
    'ubo-setInterval-defuser.js', 'nosiif.js', // new short name of no-setInterval-if
    'ubo-nosiif.js', 'sid.js', // old short scriptlet name
    'ubo-sid.js', 'ubo-no-setInterval-if', 'ubo-setInterval-defuser', 'ubo-nosiif', 'ubo-sid'];
    preventSetInterval.injections = [toRegExp, startsWith, hit, noopFunc];

    /* eslint-disable max-len */

    /**
     * @scriptlet prevent-window-open
     *
     * @description
     * Prevents `window.open` calls when URL either matches or not matches the specified string/regexp. Using it without parameters prevents all `window.open` calls.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#windowopen-defuserjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-window-open'[, match[, search[, replacement]]])
     * ```
     *
     * - `match` - optional, defaults to "matching", any positive number or nothing for "matching", 0 or empty string for "not matching"
     * - `search` - optional, string or regexp for matching the URL passed to `window.open` call; defaults to search all `window.open` call
     * - `replacement` - optional, string to return prop value or property instead of window.open; defaults to return noopFunc
     *
     * **Example**
     * 1. Prevent all `window.open` calls:
     * ```
     *     example.org#%#//scriptlet('prevent-window-open')
     * ```
     *
     * 2. Prevent `window.open` for all URLs containing `example`:
     * ```
     *     example.org#%#//scriptlet('prevent-window-open', '1', 'example')
     * ```
     *
     * 3. Prevent `window.open` for all URLs matching RegExp `/example\./`:
     * ```
     *     example.org#%#//scriptlet('prevent-window-open', '1', '/example\./')
     * ```
     *
     * 4. Prevent `window.open` for all URLs **NOT** containing `example`:
     * ```
     *     example.org#%#//scriptlet('prevent-window-open', '0', 'example')
     * ```
     * 5. Prevent all `window.open` calls and return 'trueFunc' instead of it if website checks it:
     * ```
     *     example.org#%#//scriptlet('prevent-window-open', '', '', 'trueFunc')
     * ```
     * 6. Prevent all `window.open` and returns callback
     * which returns object with property 'propName'=noopFunc
     * as a property of window.open if website checks it:
     * ```
     *     example.org#%#//scriptlet('prevent-window-open', '1', '', '{propName=noopFunc}')
     * ```
     */

    /* eslint-enable max-len */

    function preventWindowOpen(source) {
      var match = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;
      var search = arguments.length > 2 ? arguments[2] : undefined;
      var replacement = arguments.length > 3 ? arguments[3] : undefined;
      // Default value of 'match' is needed to prevent all `window.open` calls
      // if the scriptlet is used without parameters
      var nativeOpen = window.open; // unary plus converts 'match' to a number
      // e.g.: +'1' -> 1; +false -> 0

      match = +match > 0;
      search = search ? toRegExp(search) : toRegExp('/.?/'); // eslint-disable-next-line consistent-return

      var openWrapper = function openWrapper(str) {
        if (match !== search.test(str)) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          return nativeOpen.apply(window, [str].concat(args));
        }

        hit(source);
        var result; // defaults to return noopFunc instead of window.open

        if (!replacement) {
          result = noopFunc;
        } else if (replacement === 'trueFunc') {
          result = trueFunc;
        } else if (replacement.indexOf('=') > -1) {
          // We should return noopFunc instead of window.open
          // but with some property if website checks it (examples 5, 6)
          // https://github.com/AdguardTeam/Scriptlets/issues/71
          var isProp = startsWith(replacement, '{') && endsWith(replacement, '}');

          if (isProp) {
            var propertyPart = replacement.slice(1, -1);
            var propertyName = substringBefore(propertyPart, '=');
            var propertyValue = substringAfter(propertyPart, '=');

            if (propertyValue === 'noopFunc') {
              result = function result() {
                var resObj = {};
                resObj[propertyName] = noopFunc;
                return resObj;
              };
            }
          }
        }

        return result;
      };

      window.open = openWrapper;
    }
    preventWindowOpen.names = ['prevent-window-open', // aliases are needed for matching the related scriptlet converted into our syntax
    'window.open-defuser.js', 'ubo-window.open-defuser.js', 'ubo-window.open-defuser'];
    preventWindowOpen.injections = [toRegExp, startsWith, endsWith, substringBefore, substringAfter, hit, noopFunc, trueFunc];

    /* eslint-disable max-len */

    /**
     * @scriptlet abort-current-inline-script
     *
     * @description
     * Aborts an inline script when it attempts to **read** the specified property
     * AND when the contents of the `<script>` element contains the specified
     * text or matches the regular expression.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#abort-current-inline-scriptjs-
     *
     * Related ABP source:
     * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L928
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('abort-current-inline-script', property[, search])
     * ```
     *
     * - `property` - required, path to a property (joined with `.` if needed). The property must be attached to `window`
     * - `search` - optional, string or regular expression that must match the inline script contents. If not set, abort all inline scripts which are trying to access the specified property
     *
     * > Note please that for inline script with addEventListener in it
     * `property` should be set as `EventTarget.prototype.addEventListener`,
     * not just `addEventListener`.
     *
     * **Examples**
     * 1. Aborts all inline scripts trying to access `window.alert`
     *     ```
     *     example.org#%#//scriptlet('abort-current-inline-script', 'alert')
     *     ```
     *
     * 2. Aborts inline scripts which are trying to access `window.alert` and contain `Hello, world`.
     *     ```
     *     example.org#%#//scriptlet('abort-current-inline-script', 'alert', 'Hello, world')
     *     ```
     *
     *     For instance, the following script will be aborted
     *     ```html
     *     <script>alert("Hello, world");</script>
     *     ```
     *
     * 3. Aborts inline scripts which are trying to access `window.alert` and match this regexp: `/Hello.+world/`.
     *     ```
     *     example.org#%#//scriptlet('abort-current-inline-script', 'alert', '/Hello.+world/')
     *     ```
     *
     *     For instance, the following scripts will be aborted:
     *     ```html
     *     <script>alert("Hello, big world");</script>
     *     ```
     *     ```html
     *     <script>alert("Hello, little world");</script>
     *     ```
     *
     *     This script will not be aborted:
     *     ```html
     *     <script>alert("Hi, little world");</script>
     *     ```
     */

    /* eslint-enable max-len */

    function abortCurrentInlineScript(source, property, search) {
      var searchRegexp = search ? toRegExp(search) : toRegExp('/.?/');
      var rid = randomId();

      var getCurrentScript = function getCurrentScript() {
        if (!document.currentScript) {
          // eslint-disable-line compat/compat
          var scripts = document.getElementsByTagName('script');
          return scripts[scripts.length - 1];
        }

        return document.currentScript; // eslint-disable-line compat/compat
      };

      var ourScript = getCurrentScript();

      var abort = function abort() {
        var scriptEl = getCurrentScript();

        if (!scriptEl) {
          return;
        }

        var content = scriptEl.textContent; // We are using Node.prototype.textContent property descriptor
        // to get the real script content
        // even when document.currentScript.textContent is replaced.
        // https://github.com/AdguardTeam/Scriptlets/issues/57#issuecomment-593638991

        try {
          var textContentGetter = Object.getOwnPropertyDescriptor(Node.prototype, 'textContent').get;
          content = textContentGetter.call(scriptEl);
        } catch (e) {} // eslint-disable-line no-empty


        if (scriptEl instanceof HTMLScriptElement && content.length > 0 && scriptEl !== ourScript && searchRegexp.test(content)) {
          hit(source);
          throw new ReferenceError(rid);
        }
      };

      var setChainPropAccess = function setChainPropAccess(owner, property) {
        var chainInfo = getPropertyInChain(owner, property);
        var base = chainInfo.base;
        var prop = chainInfo.prop,
            chain = chainInfo.chain; // The scriptlet might be executed before the chain property has been created
        // (for instance, document.body before the HTML body was loaded).
        // In this case we're checking whether the base element exists or not
        // and if not, we simply exit without overriding anything.
        // e.g. https://github.com/AdguardTeam/Scriptlets/issues/57#issuecomment-575841092

        if (base instanceof Object === false && base === null) {
          var props = property.split('.');
          var propIndex = props.indexOf(prop);
          var baseName = props[propIndex - 1];
          console.log("The scriptlet had been executed before the ".concat(baseName, " was loaded.")); // eslint-disable-line no-console

          return;
        }

        if (chain) {
          var setter = function setter(a) {
            base = a;

            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };

          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }

        var currentValue = base[prop];
        setPropertyAccess(base, prop, {
          set: function set(value) {
            abort();
            currentValue = value;
          },
          get: function get() {
            abort();
            return currentValue;
          }
        });
      };

      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    abortCurrentInlineScript.names = ['abort-current-inline-script', // aliases are needed for matching the related scriptlet converted into our syntax
    'abort-current-inline-script.js', 'ubo-abort-current-inline-script.js', 'acis.js', 'ubo-acis.js', 'ubo-abort-current-inline-script', 'ubo-acis', 'abp-abort-current-inline-script'];
    abortCurrentInlineScript.injections = [randomId, setPropertyAccess, getPropertyInChain, toRegExp, createOnErrorHandler, hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet set-constant
     *
     * @description
     * Creates a constant property and assigns it one of the values from the predefined list.
     *
     * > Actually, it's not a constant. Please note, that it can be rewritten with a value of a different type.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#set-constantjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('set-constant', property, value[, stack])
     * ```
     *
     * - `property` - required, path to a property (joined with `.` if needed). The property must be attached to `window`.
     * - `value` - required. Possible values:
     *     - positive decimal integer `<= 32767`
     *     - one of the predefined constants:
     *         - `undefined`
     *         - `false`
     *         - `true`
     *         - `null`
     *         - `noopFunc` - function with empty body
     *         - `trueFunc` - function returning true
     *         - `falseFunc` - function returning false
     *         - `''` - empty string
     *         - `-1` - number value `-1`
     * - `stack` - optional, string or regular expression that must match the current function call stack trace
     *
     * **Examples**
     * ```
     * ! window.firstConst === false // this comparision will return false
     * example.org#%#//scriptlet('set-constant', 'firstConst', 'false')
     *
     * ! window.second() === trueFunc // 'second' call will return true
     * example.org#%#//scriptlet('set-constant', 'secondConst', 'trueFunc')
     *
     * ! document.third() === falseFunc  // 'third' call will return false if the method is related to checking.js
     * example.org#%#//scriptlet('set-constant', 'secondConst', 'trueFunc', 'checking.js')
     * ```
     */

    /* eslint-enable max-len */

    function setConstant(source, property, value, stack) {
      var stackRegexp = stack ? toRegExp(stack) : toRegExp('/.?/');

      if (!property || !matchStackTrace(stackRegexp, new Error().stack)) {
        return;
      }

      var nativeIsNaN = Number.isNaN || window.isNaN; // eslint-disable-line compat/compat

      var constantValue;

      if (value === 'undefined') {
        constantValue = undefined;
      } else if (value === 'false') {
        constantValue = false;
      } else if (value === 'true') {
        constantValue = true;
      } else if (value === 'null') {
        constantValue = null;
      } else if (value === 'noopFunc') {
        constantValue = noopFunc;
      } else if (value === 'trueFunc') {
        constantValue = trueFunc;
      } else if (value === 'falseFunc') {
        constantValue = falseFunc;
      } else if (/^\d+$/.test(value)) {
        constantValue = parseFloat(value);

        if (nativeIsNaN(constantValue)) {
          return;
        }

        if (Math.abs(constantValue) > 0x7FFF) {
          return;
        }
      } else if (value === '-1') {
        constantValue = -1;
      } else if (value === '') {
        constantValue = '';
      } else {
        return;
      }

      var canceled = false;

      var mustCancel = function mustCancel(value) {
        if (canceled) {
          return canceled;
        }

        canceled = value !== undefined && constantValue !== undefined && typeof value !== typeof constantValue;
        return canceled;
      };

      var setChainPropAccess = function setChainPropAccess(owner, property) {
        var chainInfo = getPropertyInChain(owner, property);
        var base = chainInfo.base;
        var prop = chainInfo.prop,
            chain = chainInfo.chain; // The scriptlet might be executed before the chain property has been created.
        // In this case we're checking whether the base element exists or not
        // and if not, we simply exit without overriding anything

        if (base instanceof Object === false && base === null) {
          // log the reason only while debugging
          if (source.verbose) {
            var props = property.split('.');
            var propIndex = props.indexOf(prop);
            var baseName = props[propIndex - 1];
            console.log("set-constant failed because the property '".concat(baseName, "' does not exist")); // eslint-disable-line no-console
          }

          return;
        }

        if (chain) {
          var setter = function setter(a) {
            base = a;

            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };

          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }

        if (mustCancel(base[prop])) {
          return;
        }

        hit(source);
        setPropertyAccess(base, prop, {
          get: function get() {
            return constantValue;
          },
          set: function set(a) {
            if (mustCancel(a)) {
              constantValue = a;
            }
          }
        });
      };

      setChainPropAccess(window, property);
    }
    setConstant.names = ['set-constant', // aliases are needed for matching the related scriptlet converted into our syntax
    'set-constant.js', 'ubo-set-constant.js', 'set.js', 'ubo-set.js', 'ubo-set-constant', 'ubo-set'];
    setConstant.injections = [getPropertyInChain, setPropertyAccess, toRegExp, matchStackTrace, hit, noopFunc, trueFunc, falseFunc];

    /* eslint-disable max-len */

    /**
     * @scriptlet remove-cookie
     *
     * @description
     * Removes current page cookies by passed string matching with name. For current domain and subdomains. Runs on load and before unload.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#cookie-removerjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('remove-cookie'[, match])
     * ```
     *
     * - `match` - optional, string or regex matching the cookie name. If not specified all accessible cookies will be removed.
     *
     * **Examples**
     * 1. Removes all cookies:
     * ```
     *     example.org#%#//scriptlet('remove-cookie')
     * ```
     *
     * 2. Removes cookies which name contains `example` string.
     * ```
     *     example.org#%#//scriptlet('remove-cookie', 'example')
     * ```
     *
     *     For instance this cookie will be removed
     *     ```javascript
     *     document.cookie = '__example=randomValue';
     *     ```
     */

    /* eslint-enable max-len */

    function removeCookie(source, match) {
      var regex = match ? toRegExp(match) : toRegExp('/.?/');

      var removeCookieFromHost = function removeCookieFromHost(cookieName, hostName) {
        var cookieSpec = "".concat(cookieName, "=");
        var domain1 = "; domain=".concat(hostName);
        var domain2 = "; domain=.".concat(hostName);
        var path = '; path=/';
        var expiration = '; expires=Thu, 01 Jan 1970 00:00:00 GMT';
        document.cookie = cookieSpec + expiration;
        document.cookie = cookieSpec + domain1 + expiration;
        document.cookie = cookieSpec + domain2 + expiration;
        document.cookie = cookieSpec + path + expiration;
        document.cookie = cookieSpec + domain1 + path + expiration;
        document.cookie = cookieSpec + domain2 + path + expiration;
        hit(source);
      };

      var rmCookie = function rmCookie() {
        document.cookie.split(';').forEach(function (cookieStr) {
          var pos = cookieStr.indexOf('=');

          if (pos === -1) {
            return;
          }

          var cookieName = cookieStr.slice(0, pos).trim();

          if (!regex.test(cookieName)) {
            return;
          }

          var hostParts = document.location.hostname.split('.');

          for (var i = 0; i <= hostParts.length - 1; i += 1) {
            var hostName = hostParts.slice(i).join('.');

            if (hostName) {
              removeCookieFromHost(cookieName, hostName);
            }
          }
        });
      };

      rmCookie();
      window.addEventListener('beforeunload', rmCookie);
    }
    removeCookie.names = ['remove-cookie', // aliases are needed for matching the related scriptlet converted into our syntax
    'cookie-remover.js', 'ubo-cookie-remover.js', 'ubo-cookie-remover'];
    removeCookie.injections = [toRegExp, hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet prevent-addEventListener
     *
     * @description
     * Prevents adding event listeners for the specified events and callbacks.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#addeventlistener-defuserjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-addEventListener'[, eventSearch[, functionSearch]])
     * ```
     *
     * - `eventSearch` - optional, string or regex matching the event name. If not specified, the scriptlets prevents all event listeners
     * - `functionSearch` - optional, string or regex matching the event listener function body. If not set, the scriptlet prevents all event listeners with event name matching `eventSearch`
     *
     * **Examples**
     * 1. Prevent all `click` listeners:
     * ```
     *     example.org#%#//scriptlet('prevent-addEventListener', 'click')
     * ```

    2. Prevent 'click' listeners with the callback body containing `searchString`.
     * ```
     *     example.org#%#//scriptlet('prevent-addEventListener', 'click', 'searchString')
     * ```
     *
     *     For instance, this listener will not be called:
     * ```javascript
     *     el.addEventListener('click', () => {
     *         window.test = 'searchString';
     *     });
     * ```
     */

    /* eslint-enable max-len */

    function preventAddEventListener(source, eventSearch, funcSearch) {
      var eventSearchRegexp = eventSearch ? toRegExp(eventSearch) : toRegExp('/.?/');
      var funcSearchRegexp = funcSearch ? toRegExp(funcSearch) : toRegExp('/.?/');
      var nativeAddEventListener = window.EventTarget.prototype.addEventListener;

      function addEventListenerWrapper(eventName, callback) {
        // The scriptlet might cause a website broke
        // if the website uses test addEventListener with callback = null
        // https://github.com/AdguardTeam/Scriptlets/issues/76
        var funcToCheck = callback;

        if (callback && typeof callback === 'function') {
          funcToCheck = callback.toString();
        }

        if (eventSearchRegexp.test(eventName.toString()) && funcSearchRegexp.test(funcToCheck)) {
          hit(source);
          return undefined;
        }

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        return nativeAddEventListener.apply(this, [eventName, callback].concat(args));
      }

      window.EventTarget.prototype.addEventListener = addEventListenerWrapper;
    }
    preventAddEventListener.names = ['prevent-addEventListener', // aliases are needed for matching the related scriptlet converted into our syntax
    'addEventListener-defuser.js', 'ubo-addEventListener-defuser.js', 'aeld.js', 'ubo-aeld.js', 'ubo-addEventListener-defuser', 'ubo-aeld'];
    preventAddEventListener.injections = [toRegExp, hit];

    /* eslint-disable consistent-return, no-eval */
    /**
     * @scriptlet prevent-bab
     *
     * @description
     * Prevents BlockAdblock script from detecting an ad blocker.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#bab-defuserjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-bab')
     * ```
     */

    function preventBab(source) {
      var _this = this;

      var nativeSetTimeout = window.setTimeout;
      var babRegex = /\.bab_elementid.$/;

      window.setTimeout = function (callback) {
        if (typeof callback !== 'string' || !babRegex.test(callback)) {
          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
            args[_key - 1] = arguments[_key];
          }

          return nativeSetTimeout.call.apply(nativeSetTimeout, [_this, callback].concat(args));
        }

        hit(source);
      };

      var signatures = [['blockadblock'], ['babasbm'], [/getItem\('babn'\)/], ['getElementById', 'String.fromCharCode', 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789', 'charAt', 'DOMContentLoaded', 'AdBlock', 'addEventListener', 'doScroll', 'fromCharCode', '<<2|r>>4', 'sessionStorage', 'clientWidth', 'localStorage', 'Math', 'random']];

      var check = function check(str) {
        for (var i = 0; i < signatures.length; i += 1) {
          var tokens = signatures[i];
          var match = 0;

          for (var j = 0; j < tokens.length; j += 1) {
            var token = tokens[j];
            var found = token instanceof RegExp ? token.test(str) : str.indexOf(token) > -1;

            if (found) {
              match += 1;
            }
          }

          if (match / tokens.length >= 0.8) {
            return true;
          }
        }

        return false;
      };

      var nativeEval = window.eval;

      window.eval = function (str) {
        if (!check(str)) {
          return nativeEval(str);
        }

        hit(source);
        var bodyEl = document.body;

        if (bodyEl) {
          bodyEl.style.removeProperty('visibility');
        }

        var el = document.getElementById('babasbmsgx');

        if (el) {
          el.parentNode.removeChild(el);
        }
      };
    }
    preventBab.names = ['prevent-bab', // aliases are needed for matching the related scriptlet converted into our syntax
    'nobab.js', 'ubo-nobab.js', 'bab-defuser.js', 'ubo-bab-defuser.js', 'ubo-nobab', 'ubo-bab-defuser'];
    preventBab.injections = [hit];

    /* eslint-disable no-unused-vars, no-extra-bind, func-names */
    /* eslint-disable max-len */

    /**
     * @scriptlet nowebrtc
     *
     * @description
     * Disables WebRTC by overriding `RTCPeerConnection`. The overriden function will log every attempt to create a new connection.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#nowebrtcjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('nowebrtc')
     * ```
     */

    /* eslint-enable max-len */

    function nowebrtc(source) {
      var propertyName = '';

      if (window.RTCPeerConnection) {
        propertyName = 'RTCPeerConnection';
      } else if (window.webkitRTCPeerConnection) {
        propertyName = 'webkitRTCPeerConnection';
      }

      if (propertyName === '') {
        return;
      }

      var rtcReplacement = function rtcReplacement(config) {
        hit(source, "Document tried to create an RTCPeerConnection: ".concat(config));
      };

      rtcReplacement.prototype = {
        close: noopFunc,
        createDataChannel: noopFunc,
        createOffer: noopFunc,
        setRemoteDescription: noopFunc
      };
      var rtc = window[propertyName];
      window[propertyName] = rtcReplacement;

      if (rtc.prototype) {
        rtc.prototype.createDataChannel = function (a, b) {
          return {
            close: noopFunc,
            send: noopFunc
          };
        }.bind(null);
      }
    }
    nowebrtc.names = ['nowebrtc', // aliases are needed for matching the related scriptlet converted into our syntax
    'nowebrtc.js', 'ubo-nowebrtc.js', 'ubo-nowebrtc'];
    nowebrtc.injections = [hit, noopFunc];

    /* eslint-disable no-console */
    /**
     * @scriptlet log-addEventListener
     *
     * @description
     * Logs all addEventListener calls to the console.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#addeventlistener-loggerjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('log-addEventListener')
     * ```
     */

    function logAddEventListener(source) {
      var log = console.log.bind(console);
      var nativeAddEventListener = window.EventTarget.prototype.addEventListener;

      function addEventListenerWrapper(eventName, callback) {
        hit(source); // The scriptlet might cause a website broke
        // if the website uses test addEventListener with callback = null
        // https://github.com/AdguardTeam/Scriptlets/issues/76

        var callbackToLog = callback;

        if (callback && typeof callback === 'function') {
          callbackToLog = callback.toString();
        }

        log("addEventListener(\"".concat(eventName, "\", ").concat(callbackToLog, ")"));

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        return nativeAddEventListener.apply(this, [eventName, callback].concat(args));
      }

      window.EventTarget.prototype.addEventListener = addEventListenerWrapper;
    }
    logAddEventListener.names = ['log-addEventListener', // aliases are needed for matching the related scriptlet converted into our syntax
    'addEventListener-logger.js', 'ubo-addEventListener-logger.js', 'aell.js', 'ubo-aell.js', 'ubo-addEventListener-logger', 'ubo-aell'];
    logAddEventListener.injections = [hit];

    /* eslint-disable no-console, no-eval */
    /**
     * @scriptlet log-eval
     *
     * @description
     * Logs all `eval()` or `new Function()` calls to the console.
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('log-eval')
     * ```
     */

    function logEval(source) {
      var log = console.log.bind(console); // wrap eval function

      var nativeEval = window.eval;

      function evalWrapper(str) {
        hit(source);
        log("eval(\"".concat(str, "\")"));
        return nativeEval(str);
      }

      window.eval = evalWrapper; // wrap new Function

      var nativeFunction = window.Function;

      function FunctionWrapper() {
        hit(source);

        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        log("new Function(".concat(args.join(', '), ")"));
        return nativeFunction.apply(this, [].concat(args));
      }

      FunctionWrapper.prototype = Object.create(nativeFunction.prototype);
      FunctionWrapper.prototype.constructor = FunctionWrapper;
      window.Function = FunctionWrapper;
    }
    logEval.names = ['log-eval'];
    logEval.injections = [hit];

    /**
     * @scriptlet log
     *
     * @description
     * A simple scriptlet which only purpose is to print arguments to console.
     * This scriptlet can be helpful for debugging and troubleshooting other scriptlets.
     *
     * **Example**
     * ```
     * example.org#%#//scriptlet('log', 'arg1', 'arg2')
     * ```
     */
    function log() {
      for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      console.log(args); // eslint-disable-line no-console
    }
    log.names = ['log'];

    /* eslint-disable no-eval, no-extra-bind */
    /**
     * @scriptlet noeval
     *
     * @description
     * Prevents page to use eval.
     * Notifies about attempts in the console
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#noevaljs-
     *
     * It also can be used as `$redirect` rules sometimes.
     * See [redirect description](../wiki/about-redirects.md#noeval).
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('noeval')
     * ```
     */

    function noeval(source) {
      window.eval = function evalWrapper(s) {
        hit(source, "AdGuard has prevented eval:\n".concat(s));
      }.bind();
    }
    noeval.names = ['noeval', // aliases are needed for matching the related scriptlet converted into our syntax
    'noeval.js', 'silent-noeval.js', 'ubo-noeval.js', 'ubo-silent-noeval.js', 'ubo-noeval', 'ubo-silent-noeval'];
    noeval.injections = [hit];

    /* eslint-disable no-eval, no-extra-bind, func-names */
    /**
     * @scriptlet prevent-eval-if
     *
     * @description
     * Prevents page to use eval matching payload.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#noeval-ifjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-eval-if'[, search])
     * ```
     *
     * - `search` - optional, string or regexp for matching stringified eval payload.
     * If 'search is not specified  all stringified eval payload will be matched
     *
     * **Examples**
     * ```
     * ! Prevents eval if it matches 'test'
     * example.org#%#//scriptlet('prevent-eval-if', 'test')
     * ```
     *
     * @param {string|RegExp} [search] string or regexp matching stringified eval payload
     */

    function preventEvalIf(source, search) {
      search = search ? toRegExp(search) : toRegExp('/.?/');
      var nativeEval = window.eval;

      window.eval = function (payload) {
        if (!search.test(payload.toString())) {
          return nativeEval.call(window, payload);
        }

        hit(source, payload);
        return undefined;
      }.bind(window);
    }
    preventEvalIf.names = ['prevent-eval-if', // aliases are needed for matching the related scriptlet converted into our syntax
    'noeval-if.js', 'ubo-noeval-if.js', 'ubo-noeval-if'];
    preventEvalIf.injections = [toRegExp, hit];

    /* eslint-disable no-console, func-names, no-multi-assign */
    /**
     * @scriptlet prevent-fab-3.2.0
     *
     * @description
     * Prevents execution of the FAB script v3.2.0.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#fuckadblockjs-320-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-fab-3.2.0')
     * ```
     */

    function preventFab(source) {
      hit(source); // redefines Fab function for adblock detection

      var Fab = function Fab() {};

      Fab.prototype.check = noopFunc;
      Fab.prototype.clearEvent = noopFunc;
      Fab.prototype.emitEvent = noopFunc;

      Fab.prototype.on = function (a, b) {
        if (!a) {
          b();
        }

        return this;
      };

      Fab.prototype.onDetected = noopThis;

      Fab.prototype.onNotDetected = function (a) {
        a();
        return this;
      };

      Fab.prototype.setOption = noopFunc;
      var fab = new Fab();
      var getSetFab = {
        get: function get() {
          return Fab;
        },
        set: function set() {}
      };
      var getsetfab = {
        get: function get() {
          return fab;
        },
        set: function set() {}
      }; // redefined Fab data properties which if 'FuckAdBlock' variable exists

      if (Object.prototype.hasOwnProperty.call(window, 'FuckAdBlock')) {
        window.FuckAdBlock = Fab;
      } else {
        // or redefined Fab accessor properties
        Object.defineProperty(window, 'FuckAdBlock', getSetFab);
      }

      if (Object.prototype.hasOwnProperty.call(window, 'BlockAdBlock')) {
        window.BlockAdBlock = Fab;
      } else {
        Object.defineProperty(window, 'BlockAdBlock', getSetFab);
      }

      if (Object.prototype.hasOwnProperty.call(window, 'SniffAdBlock')) {
        window.SniffAdBlock = Fab;
      } else {
        Object.defineProperty(window, 'SniffAdBlock', getSetFab);
      }

      if (Object.prototype.hasOwnProperty.call(window, 'fuckAdBlock')) {
        window.fuckAdBlock = fab;
      } else {
        Object.defineProperty(window, 'fuckAdBlock', getsetfab);
      }

      if (Object.prototype.hasOwnProperty.call(window, 'blockAdBlock')) {
        window.blockAdBlock = fab;
      } else {
        Object.defineProperty(window, 'blockAdBlock', getsetfab);
      }

      if (Object.prototype.hasOwnProperty.call(window, 'sniffAdBlock')) {
        window.sniffAdBlock = fab;
      } else {
        Object.defineProperty(window, 'sniffAdBlock', getsetfab);
      }
    }
    preventFab.names = ['prevent-fab-3.2.0', // aliases are needed for matching the related scriptlet converted into our syntax
    'nofab.js', 'ubo-nofab.js', 'fuckadblock.js-3.2.0', 'ubo-fuckadblock.js-3.2.0', 'ubo-nofab'];
    preventFab.injections = [hit, noopFunc, noopThis];

    /* eslint-disable no-console, func-names, no-multi-assign */
    /**
     * @scriptlet set-popads-dummy
     *
     * @description
     * Sets static properties PopAds and popns.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#popads-dummyjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('set-popads-dummy')
     * ```
     */

    function setPopadsDummy(source) {
      delete window.PopAds;
      delete window.popns;
      Object.defineProperties(window, {
        PopAds: {
          get: function get() {
            hit(source);
            return {};
          }
        },
        popns: {
          get: function get() {
            hit(source);
            return {};
          }
        }
      });
    }
    setPopadsDummy.names = ['set-popads-dummy', // aliases are needed for matching the related scriptlet converted into our syntax
    'popads-dummy.js', 'ubo-popads-dummy.js', 'ubo-popads-dummy'];
    setPopadsDummy.injections = [hit];

    /**
     * @scriptlet prevent-popads-net
     *
     * @description
     * Aborts on property write (PopAds, popns), throws reference error with random id.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#popadsnetjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-popads-net')
     * ```
     */

    function preventPopadsNet(source) {
      var rid = randomId();

      var throwError = function throwError() {
        throw new ReferenceError(rid);
      };

      delete window.PopAds;
      delete window.popns;
      Object.defineProperties(window, {
        PopAds: {
          set: throwError
        },
        popns: {
          set: throwError
        }
      });
      window.onerror = createOnErrorHandler(rid).bind();
      hit(source);
    }
    preventPopadsNet.names = ['prevent-popads-net', // aliases are needed for matching the related scriptlet converted into our syntax
    'popads.net.js', 'ubo-popads.net.js', 'ubo-popads.net'];
    preventPopadsNet.injections = [createOnErrorHandler, randomId, hit];

    /* eslint-disable func-names */
    /**
     * @scriptlet prevent-adfly
     *
     * @description
     * Prevents anti-adblock scripts on adfly short links.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#adfly-defuserjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-adfly')
     * ```
     */

    function preventAdfly(source) {
      var isDigit = function isDigit(data) {
        return /^\d$/.test(data);
      };

      var handler = function handler(encodedURL) {
        var evenChars = '';
        var oddChars = '';

        for (var i = 0; i < encodedURL.length; i += 1) {
          if (i % 2 === 0) {
            evenChars += encodedURL.charAt(i);
          } else {
            oddChars = encodedURL.charAt(i) + oddChars;
          }
        }

        var data = (evenChars + oddChars).split('');

        for (var _i = 0; _i < data.length; _i += 1) {
          if (isDigit(data[_i])) {
            for (var ii = _i + 1; ii < data.length; ii += 1) {
              if (isDigit(data[ii])) {
                // eslint-disable-next-line no-bitwise
                var temp = parseInt(data[_i], 10) ^ parseInt(data[ii], 10);

                if (temp < 10) {
                  data[_i] = temp.toString();
                }

                _i = ii;
                break;
              }
            }
          }
        }

        data = data.join('');
        var decodedURL = window.atob(data).slice(16, -16);
        /* eslint-disable compat/compat */

        if (window.stop) {
          window.stop();
        }
        /* eslint-enable compat/compat */


        window.onbeforeunload = null;
        window.location.href = decodedURL;
      };

      var val; // Do not apply handler more than one time

      var applyHandler = true;
      var result = setPropertyAccess(window, 'ysmm', {
        configurable: false,
        set: function set(value) {
          if (applyHandler) {
            applyHandler = false;

            try {
              if (typeof value === 'string') {
                handler(value);
              }
            } catch (err) {} // eslint-disable-line no-empty

          }

          val = value;
        },
        get: function get() {
          return val;
        }
      });

      if (result) {
        hit(source);
      } else {
        window.console.error('Failed to set up prevent-adfly scriptlet');
      }
    }
    preventAdfly.names = ['prevent-adfly', // aliases are needed for matching the related scriptlet converted into our syntax
    'adfly-defuser.js', 'ubo-adfly-defuser.js', 'ubo-adfly-defuser'];
    preventAdfly.injections = [setPropertyAccess, hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet debug-on-property-read
     *
     * @description
     * This scriptlet is basically the same as [abort-on-property-read](#abort-on-property-read), but instead of aborting it starts the debugger.
     *
     * **It is not supposed to be used in production filter lists!**
     *
     * **Syntax**
     * ```
     * ! Debug script if it tries to access `window.alert`
     * example.org#%#//scriptlet('debug-on-property-read', 'alert')
     * ! of `window.open`
     * example.org#%#//scriptlet('debug-on-property-read', 'open')
     * ```
     */

    /* eslint-enable max-len */

    function debugOnPropertyRead(source, property, stack) {
      var stackRegexp = stack ? toRegExp(stack) : toRegExp('/.?/');

      if (!property || !matchStackTrace(stackRegexp, new Error().stack)) {
        return;
      }

      var rid = randomId();

      var abort = function abort() {
        hit(source);
        debugger; // eslint-disable-line no-debugger
      };

      var setChainPropAccess = function setChainPropAccess(owner, property) {
        var chainInfo = getPropertyInChain(owner, property);
        var base = chainInfo.base;
        var prop = chainInfo.prop,
            chain = chainInfo.chain;

        if (chain) {
          var setter = function setter(a) {
            base = a;

            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };

          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }

        setPropertyAccess(base, prop, {
          get: abort,
          set: noopFunc
        });
      };

      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    debugOnPropertyRead.names = ['debug-on-property-read'];
    debugOnPropertyRead.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, toRegExp, matchStackTrace, noopFunc];

    /* eslint-disable max-len */

    /**
     * @scriptlet debug-on-property-write
     *
     * @description
     * This scriptlet is basically the same as [abort-on-property-write](#abort-on-property-write), but instead of aborting it starts the debugger.
     *
     * **It is not supposed to be used in production filter lists!**
     *
     * **Syntax**
     * ```
     * ! Aborts script when it tries to write in property `window.test`
     * example.org#%#//scriptlet('debug-on-property-write', 'test')
     * ```
     */

    /* eslint-enable max-len */

    function debugOnPropertyWrite(source, property, stack) {
      var stackRegexp = stack ? toRegExp(stack) : toRegExp('/.?/');

      if (!property || !matchStackTrace(stackRegexp, new Error().stack)) {
        return;
      }

      var rid = randomId();

      var abort = function abort() {
        hit(source);
        debugger; // eslint-disable-line no-debugger
      };

      var setChainPropAccess = function setChainPropAccess(owner, property) {
        var chainInfo = getPropertyInChain(owner, property);
        var base = chainInfo.base;
        var prop = chainInfo.prop,
            chain = chainInfo.chain;

        if (chain) {
          var setter = function setter(a) {
            base = a;

            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };

          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }

        setPropertyAccess(base, prop, {
          set: abort
        });
      };

      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    debugOnPropertyWrite.names = ['debug-on-property-write'];
    debugOnPropertyWrite.injections = [randomId, setPropertyAccess, getPropertyInChain, createOnErrorHandler, hit, toRegExp, matchStackTrace];

    /* eslint-disable max-len */

    /**
     * @scriptlet debug-current-inline-script
     *
     * @description
     * This scriptlet is basically the same as [abort-current-inline-script](#abort-current-inline-script), but instead of aborting it starts the debugger.
     *
     * **It is not supposed to be used in production filter lists!**
     *
     * **Syntax**
     *```
     * ! Aborts script when it tries to access `window.alert`
     * example.org#%#//scriptlet('debug-current-inline-script', 'alert')
     * ```
     */

    /* eslint-enable max-len */

    function debugCurrentInlineScript(source, property) {
      var search = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;
      var regex = search ? toRegExp(search) : null;
      var rid = randomId();

      var getCurrentScript = function getCurrentScript() {
        if (!document.currentScript) {
          // eslint-disable-line compat/compat
          var scripts = document.getElementsByTagName('script');
          return scripts[scripts.length - 1];
        }

        return document.currentScript; // eslint-disable-line compat/compat
      };

      var ourScript = getCurrentScript();

      var abort = function abort() {
        var scriptEl = getCurrentScript();

        if (scriptEl instanceof HTMLScriptElement && scriptEl.textContent.length > 0 && scriptEl !== ourScript && (!regex || regex.test(scriptEl.textContent))) {
          hit(source);
          debugger; // eslint-disable-line no-debugger
        }
      };

      var setChainPropAccess = function setChainPropAccess(owner, property) {
        var chainInfo = getPropertyInChain(owner, property);
        var base = chainInfo.base;
        var prop = chainInfo.prop,
            chain = chainInfo.chain;

        if (chain) {
          var setter = function setter(a) {
            base = a;

            if (a instanceof Object) {
              setChainPropAccess(a, chain);
            }
          };

          Object.defineProperty(owner, prop, {
            get: function get() {
              return base;
            },
            set: setter
          });
          return;
        }

        var currentValue = base[prop];
        setPropertyAccess(base, prop, {
          set: function set(value) {
            abort();
            currentValue = value;
          },
          get: function get() {
            abort();
            return currentValue;
          }
        });
      };

      setChainPropAccess(window, property);
      window.onerror = createOnErrorHandler(rid).bind();
    }
    debugCurrentInlineScript.names = ['debug-current-inline-script'];
    debugCurrentInlineScript.injections = [randomId, setPropertyAccess, getPropertyInChain, toRegExp, createOnErrorHandler, hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet remove-attr
     *
     * @description
     * Removes the specified attributes from DOM nodes. This scriptlet runs once when the page loads
     * and after that periodically in order to DOM tree changes.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#remove-attrjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('remove-attr', attrs[, selector])
     * ```
     *
     * - `attrs`  required, attribute or list of attributes joined by '|'
     * - `selector`  optional, CSS selector, specifies DOM nodes from which the attributes will be removed
     *
     * **Examples**
     * 1.  Removes by attribute
     *     ```
     *     example.org#%#//scriptlet('remove-attr', 'example|test')
     *     ```
     *
     *     ```html
     *     <!-- before  -->
     *     <div example="true" test="true">Some text</div>
     *
     *     <!-- after -->
     *     <div>Some text</div>
     *     ```
     *
     * 2. Removes with specified selector
     *     ```
     *     example.org#%#//scriptlet('remove-attr', 'example', 'div[class="inner"]')
     *     ```
     *
     *     ```html
     *     <!-- before -->
     *     <div class="wrapper" example="true">
     *         <div class="inner" example="true">Some text</div>
     *     </div>
     *
     *     <!-- after -->
     *     <div class="wrapper" example="true">
     *         <div class="inner">Some text</div>
     *     </div>
     *     ```
     */

    /* eslint-enable max-len */

    function removeAttr(source, attrs, selector) {
      if (!attrs) {
        return;
      }

      attrs = attrs.split(/\s*\|\s*/);

      if (!selector) {
        selector = "[".concat(attrs.join('],['), "]");
      }

      var rmattr = function rmattr() {
        var nodes = [].slice.call(document.querySelectorAll(selector));
        var removed = false;
        nodes.forEach(function (node) {
          attrs.forEach(function (attr) {
            node.removeAttribute(attr);
            removed = true;
          });
        });

        if (removed) {
          hit(source);
        }
      };

      rmattr(); // 'true' for observing attributes

      observeDOMChanges(rmattr, true);
    }
    removeAttr.names = ['remove-attr', // aliases are needed for matching the related scriptlet converted into our syntax
    'remove-attr.js', 'ubo-remove-attr.js', 'ra.js', 'ubo-ra.js', 'ubo-remove-attr', 'ubo-ra'];
    removeAttr.injections = [hit, observeDOMChanges];

    /* eslint-disable max-len */

    /**
     * @scriptlet remove-class
     *
     * @description
     * Removes the specified classes from DOM nodes. This scriptlet runs once after the page loads
     * and after that periodically in order to DOM tree changes.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#remove-classjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('remove-class', classes[, selector])
     * ```
     *
     * - `classes`  required, class or list of classes separated by '|'
     * - `selector`  optional, CSS selector, specifies DOM nodes from which the classes will be removed.
     * If there is no `selector`, each class of `classes` independently will be removed from all nodes which has one
     *
     * **Examples**
     * 1.  Removes by classes
     *     ```
     *     example.org#%#//scriptlet('remove-class', 'example|test')
     *     ```
     *
     *     ```html
     *     <!-- before  -->
     *     <div id="first" class="nice test">Some text</div>
     *     <div id="second" class="rare example for test">Some text</div>
     *     <div id="third" class="testing better example">Some text</div>
     *
     *     <!-- after -->
     *     <div id="first" class="nice">Some text</div>
     *     <div id="second" class="rare for">Some text</div>
     *     <div id="third" class="testing better">Some text</div>
     *     ```
     *
     * 2. Removes with specified selector
     *     ```
     *     example.org#%#//scriptlet('remove-class', 'branding', 'div[class^="inner"]')
     *     ```
     *
     *     ```html
     *     <!-- before -->
     *     <div class="wrapper true branding">
     *         <div class="inner bad branding">Some text</div>
     *     </div>
     *
     *     <!-- after -->
     *     <div class="wrapper true branding">
     *         <div class="inner bad">Some text</div>
     *     </div>
     *     ```
     */

    /* eslint-enable max-len */

    function removeClass(source, classNames, selector) {
      if (!classNames) {
        return;
      }

      classNames = classNames.split(/\s*\|\s*/);
      var selectors = [];

      if (!selector) {
        selectors = classNames.map(function (className) {
          return ".".concat(className);
        });
      }

      var removeClassHandler = function removeClassHandler() {
        var nodes = new Set();

        if (selector) {
          var foundedNodes = [].slice.call(document.querySelectorAll(selector));
          foundedNodes.forEach(function (n) {
            return nodes.add(n);
          });
        } else if (selectors.length > 0) {
          selectors.forEach(function (s) {
            var elements = document.querySelectorAll(s);

            for (var i = 0; i < elements.length; i += 1) {
              var element = elements[i];
              nodes.add(element);
            }
          });
        }

        var removed = false;
        nodes.forEach(function (node) {
          classNames.forEach(function (className) {
            if (node.classList.contains(className)) {
              node.classList.remove(className);
              removed = true;
            }
          });
        });

        if (removed) {
          hit(source);
        }
      };

      removeClassHandler();
      var CLASS_ATTR_NAME = ['class']; // 'true' for observing attributes
      // 'class' for observing only classes

      observeDOMChanges(removeClassHandler, true, CLASS_ATTR_NAME);
    }
    removeClass.names = ['remove-class', // aliases are needed for matching the related scriptlet converted into our syntax
    'remove-class.js', 'ubo-remove-class.js', 'rc.js', 'ubo-rc.js', 'ubo-remove-class', 'ubo-rc'];
    removeClass.injections = [hit, observeDOMChanges];

    /**
     * @scriptlet disable-newtab-links
     *
     * @description
     * Prevents opening new tabs and windows if there is `target` attribute in element.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#disable-newtab-linksjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('disable-newtab-links')
     * ```
     */

    function disableNewtabLinks(source) {
      document.addEventListener('click', function (ev) {
        var target = ev.target;

        while (target !== null) {
          if (target.localName === 'a' && target.hasAttribute('target')) {
            ev.stopPropagation();
            ev.preventDefault();
            hit(source);
            break;
          }

          target = target.parentNode;
        }
      });
    }
    disableNewtabLinks.names = ['disable-newtab-links', // aliases are needed for matching the related scriptlet converted into our syntax
    'disable-newtab-links.js', 'ubo-disable-newtab-links.js', 'ubo-disable-newtab-links'];
    disableNewtabLinks.injections = [hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet adjust-setInterval
     *
     * @description
     * Adjusts interval for specified setInterval() callbacks.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#nano-setinterval-boosterjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('adjust-setInterval'[, match [, interval[, boost]]])
     * ```
     *
     * - `match` - optional, string/regular expression, matching in stringified callback function
     * - `interval` - optional, defaults to 1000, decimal integer, matching setInterval delay
     * - `boost` - optional, default to 0.05, float, capped at 50 times for up and down (0.02...50), interval multiplier
     *
     * **Examples**
     * 1. Adjust all setInterval() x20 times where interval equal 1000ms:
     *     ```
     *     example.org#%#//scriptlet('adjust-setInterval')
     *     ```
     *
     * 2. Adjust all setInterval() x20 times where callback mathed with `example` and interval equal 1000ms
     *     ```
     *     example.org#%#//scriptlet('adjust-setInterval', 'example')
     *     ```
     *
     * 3. Adjust all setInterval() x20 times where callback mathed with `example` and interval equal 400ms
     *     ```
     *     example.org#%#//scriptlet('adjust-setInterval', 'example', '400')
     *     ```
     *
     * 4. Slow down setInterval() x2 times where callback matched with `example` and interval equal 1000ms
     *     ```
     *     example.org#%#//scriptlet('adjust-setInterval', 'example', '', '2')
     *     ```
     * 5.  Adjust all setInterval() x50 times where interval equal 2000ms
     *     ```
     *     example.org#%#//scriptlet('adjust-setInterval', '', '2000', '0.02')
     *     ```
     */

    /* eslint-enable max-len */

    function adjustSetInterval(source, match, interval, boost) {
      var nativeInterval = window.setInterval;
      var nativeIsNaN = Number.isNaN || window.isNaN; // eslint-disable-line compat/compat

      var nativeIsFinite = Number.isFinite || window.isFinite; // eslint-disable-line compat/compat

      interval = parseInt(interval, 10);
      interval = nativeIsNaN(interval) ? 1000 : interval;
      boost = parseFloat(boost);
      boost = nativeIsNaN(boost) || !nativeIsFinite(boost) ? 0.05 : boost;
      match = match ? toRegExp(match) : toRegExp('/.?/');

      if (boost < 0.02) {
        boost = 0.02;
      }

      if (boost > 50) {
        boost = 50;
      }

      var intervalWrapper = function intervalWrapper(cb, d) {
        if (d === interval && match.test(cb.toString())) {
          d *= boost;
          hit(source);
        }

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        return nativeInterval.apply(window, [cb, d].concat(args));
      };

      window.setInterval = intervalWrapper;
    }
    adjustSetInterval.names = ['adjust-setInterval', // aliases are needed for matching the related scriptlet converted into our syntax
    'nano-setInterval-booster.js', 'ubo-nano-setInterval-booster.js', 'nano-sib.js', 'ubo-nano-sib.js', 'ubo-nano-setInterval-booster', 'ubo-nano-sib'];
    adjustSetInterval.injections = [toRegExp, hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet adjust-setTimeout
     *
     * @description
     * Adjusts timeout for specified setTimout() callbacks.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#nano-settimeout-boosterjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('adjust-setTimeout'[, match [, timeout[, boost]]])
     * ```
     *
     * - `match` - optional, string/regular expression, matching in stringified callback function
     * - `timeout` - optional, defaults to 1000, decimal integer, matching setTimout delay
     * - `boost` - optional, default to 0.05, float, capped at 50 times for up and down (0.02...50), timeout multiplier
     *
     * **Examples**
     * 1. Adjust all setTimeout() x20 times where timeout equal 1000ms:
     *     ```
     *     example.org#%#//scriptlet('adjust-setTimeout')
     *     ```
     *
     * 2. Adjust all setTimeout() x20 times where callback mathed with `example` and timeout equal 1000ms
     *     ```
     *     example.org#%#//scriptlet('adjust-setTimeout', 'example')
     *     ```
     *
     * 3. Adjust all setTimeout() x20 times where callback mathed with `example` and timeout equal 400ms
     *     ```
     *     example.org#%#//scriptlet('adjust-setTimeout', 'example', '400')
     *     ```
     *
     * 4. Slow down setTimeout() x2 times where callback matched with `example` and timeout equal 1000ms
     *     ```
     *     example.org#%#//scriptlet('adjust-setTimeout', 'example', '', '2')
     *     ```
     * 5.  Adjust all setTimeout() x50 times where timeout equal 2000ms
     *     ```
     *     example.org#%#//scriptlet('adjust-setTimeout', '', '2000', '0.02')
     *     ```
     */

    /* eslint-enable max-len */

    function adjustSetTimeout(source, match, timeout, boost) {
      var nativeTimeout = window.setTimeout;
      var nativeIsNaN = Number.isNaN || window.isNaN; // eslint-disable-line compat/compat

      var nativeIsFinite = Number.isFinite || window.isFinite; // eslint-disable-line compat/compat

      timeout = parseInt(timeout, 10);
      timeout = nativeIsNaN(timeout) ? 1000 : timeout;
      boost = parseFloat(boost);
      boost = nativeIsNaN(boost) || !nativeIsFinite(boost) ? 0.05 : boost;
      match = match ? toRegExp(match) : toRegExp('/.?/');

      if (boost < 0.02) {
        boost = 0.02;
      }

      if (boost > 50) {
        boost = 50;
      }

      var timeoutWrapper = function timeoutWrapper(cb, d) {
        if (d === timeout && match.test(cb.toString())) {
          d *= boost;
          hit(source);
        }

        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        return nativeTimeout.apply(window, [cb, d].concat(args));
      };

      window.setTimeout = timeoutWrapper;
    }
    adjustSetTimeout.names = ['adjust-setTimeout', // aliases are needed for matching the related scriptlet converted into our syntax
    'nano-setTimeout-booster.js', 'ubo-nano-setTimeout-booster.js', 'nano-stb.js', 'ubo-nano-stb.js', 'ubo-nano-setTimeout-booster', 'ubo-nano-stb'];
    adjustSetTimeout.injections = [toRegExp, hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet dir-string
     *
     * @description
     * Wraps the `console.dir` API to call the `toString` method of the argument.
     * There are several adblock circumvention systems that detect browser devtools
     * and hide themselves. Therefore, if we force them to think
     * that devtools are open (using this scrciptlet),
     * it will automatically disable the adblock circumvention script.
     *
     * Related ABP source:
     * https://github.com/adblockplus/adblockpluscore/blob/6b2a309054cc23432102b85d13f12559639ef495/lib/content/snippets.js#L766
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('dir-string'[, times])
     * ```
     * - `times` - optional, the number of times to call the `toString` method of the argument to `console.dir`
     *
     * **Example**
     * ```
     * ! Run 2 times
     * example.org#%#//scriptlet('dir-string', '2')
     * ```
     */

    /* eslint-enable max-len */

    function dirString(source, times) {
      var _console = console,
          dir = _console.dir;
      times = parseInt(times, 10);

      function dirWrapper(object) {
        // eslint-disable-next-line no-unused-vars
        var temp;

        for (var i = 0; i < times; i += 1) {
          // eslint-disable-next-line no-unused-expressions
          temp = "".concat(object);
        }

        if (typeof dir === 'function') {
          dir.call(this, object);
        }

        hit(source, temp);
      } // eslint-disable-next-line no-console


      console.dir = dirWrapper;
    }
    dirString.names = ['dir-string', 'abp-dir-string'];
    dirString.injections = [hit];

    /* eslint-disable max-len */

    /**
     * @scriptlet json-prune
     *
     * @description
     * Removes specified properties from the result of calling JSON.parse and returns the caller
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#json-prunejs-
     *
     * Related ABP source:
     * https://github.com/adblockplus/adblockpluscore/blob/master/lib/content/snippets.js#L1285
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('json-prune'[, propsToRemove [, obligatoryProps [, stack]]])
     * ```
     *
     * - `propsToRemove` - optional, string of space-separated properties to remove
     * - `obligatoryProps` - optional, string of space-separated properties which must be all present for the pruning to occur
     * - `stack` - optional, string or regular expression that must match the current function call stack trace
     *
     * > Note please that you can use wildcard `*` for chain property name.
     * e.g. 'ad.*.src' instead of 'ad.0.src ad.1.src ad.2.src ...'
     *
     * **Examples**
     * 1. Removes property `example` from the results of JSON.parse call
     *     ```
     *     example.org#%#//scriptlet('json-prune', 'example')
     *     ```
     *
     *     For instance, the following call will return `{ one: 1}`
     *
     *     ```html
     *     JSON.parse('{"one":1,"example":true}')
     *     ```
     *
     * 2. If there are no specified properties in the result of JSON.parse call, pruning will NOT occur
     *     ```
     *     example.org#%#//scriptlet('json-prune', 'one', 'obligatoryProp')
     *     ```
     *
     *     For instance, the following call will return `{ one: 1, two: 2}`
     *
     *     ```html
     *     JSON.parse('{"one":1,"two":2}')
     *     ```
     *
     * 3. A property in a list of properties can be a chain of properties
     *
     *     ```
     *     example.org#%#//scriptlet('json-prune', 'a.b', 'adpath.url.first')
     *     ```
     *
     * 4. Removes property `content.ad` from the results of JSON.parse call it's error stack trace contains `test.js`
     *     ```
     *     example.org#%#//scriptlet('json-prune', 'content.ad', '', 'test.js')
     *     ```
     *
     * 5. A property in a list of properties can be a chain of properties with wildcard in it
     *
     *     ```
     *     example.org#%#//scriptlet('json-prune', 'content.*.media.src', 'content.*.media.preroll')
     *     ```
     *
     * 6. Call with no arguments will log the current hostname and json payload at the console
     *     ```
     *     example.org#%#//scriptlet('json-prune')
     *     ```
     */

    /* eslint-enable max-len */

    function jsonPrune(source, propsToRemove, requiredInitialProps, stack) {
      var stackRegexp = stack ? toRegExp(stack) : toRegExp('/.?/');

      if (!matchStackTrace(stackRegexp, new Error().stack)) {
        return;
      } // eslint-disable-next-line no-console


      var log = console.log.bind(console);
      var prunePaths = propsToRemove !== undefined && propsToRemove !== '' ? propsToRemove.split(/ +/) : [];
      var requiredPaths = requiredInitialProps !== undefined && requiredInitialProps !== '' ? requiredInitialProps.split(/ +/) : [];

      function isPruningNeeded(root) {
        if (!root) {
          return false;
        }

        var shouldProcess;

        for (var i = 0; i < requiredPaths.length; i += 1) {
          var requiredPath = requiredPaths[i];
          var lastNestedPropName = requiredPath.split('.').pop();
          var hasWildcard = requiredPath.indexOf('.*.') > -1 || requiredPath.indexOf('*.') > -1 || requiredPath.indexOf('.*') > -1; // if the path has wildcard, getPropertyInChain should 'look through' chain props

          var details = getWildcardPropertyInChain(root, requiredPath, hasWildcard); // start value of 'shouldProcess' due to checking below

          shouldProcess = !hasWildcard;

          for (var _i = 0; _i < details.length; _i += 1) {
            if (hasWildcard) {
              // if there is a wildcard,
              // at least one (||) of props chain should be present in object
              shouldProcess = !(details[_i].base[lastNestedPropName] === undefined) || shouldProcess;
            } else {
              // otherwise each one (&&) of them should be there
              shouldProcess = !(details[_i].base[lastNestedPropName] === undefined) && shouldProcess;
            }
          }
        }

        return shouldProcess;
      }

      var nativeParse = JSON.parse;

      var parseWrapper = function parseWrapper() {
        for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
          args[_key] = arguments[_key];
        }

        var root = nativeParse.apply(window, args);

        if (prunePaths.length === 0) {
          log(window.location.hostname, root);
          return root;
        }

        if (isPruningNeeded(root) === false) {
          return root;
        } // if pruning is needed, we check every input pathToRemove
        // and delete it if root has it


        prunePaths.forEach(function (path) {
          var ownerObjArr = getWildcardPropertyInChain(root, path, true);
          ownerObjArr.forEach(function (ownerObj) {
            if (ownerObj !== undefined && ownerObj.base) {
              delete ownerObj.base[ownerObj.prop];
            }
          });
        });
        hit(source);
        return root;
      };

      JSON.parse = parseWrapper;
    }
    jsonPrune.names = ['json-prune', // aliases are needed for matching the related scriptlet converted into our syntax
    'json-prune.js', 'ubo-json-prune.js', 'ubo-json-prune', 'abp-json-prune'];
    jsonPrune.injections = [hit, toRegExp, matchStackTrace, getWildcardPropertyInChain];

    /* eslint-disable max-len */

    /**
     * @scriptlet prevent-requestAnimationFrame
     *
     * @description
     * Prevents a `requestAnimationFrame` call
     * if the text of the callback is matching the specified search string which does not start with `!`;
     * otherwise mismatched calls should be defused.
     *
     * Related UBO scriptlet:
     * https://github.com/gorhill/uBlock/wiki/Resources-Library#no-requestanimationframe-ifjs-
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('prevent-requestAnimationFrame'[, search])
     * ```
     *
     * - `search` - optional, string or regular expression.
     * If starts with `!`, scriptlet will not match the stringified callback but all other will be defused.
     * If do not start with `!`, the stringified callback will be matched.
     *
     * Call with no argument will log all requestAnimationFrame calls while debugging.
     * So do not use the scriptlet without any parameter in production filter lists.
     *
     * **Examples**
     * 1. Prevents `requestAnimationFrame` calls if the callback matches `/\.test/`.
     *     ```bash
     *     example.org#%#//scriptlet('prevent-requestAnimationFrame', '/\.test/')
     *     ```
     *
     *     For instance, the following call will be prevented:
     *     ```javascript
     *     var times = 0;
     *     requestAnimationFrame(function change() {
     *         window.test = 'new value';
     *         if (times < 2) {
     *             times += 1;
     *             requestAnimationFrame(change);
     *         }
     *     });
     *     ```
     * 2. Prevents `requestAnimationFrame` calls if **does not match** 'check'.
     *     ```bash
     *     example.org#%#//scriptlet('prevent-requestAnimationFrame', '!check')
     *     ```
     *
     *     For instance, only the first call will be prevented:
     *
     *     ```javascript
     *     var timesFirst = 0;
     *     requestAnimationFrame(function changeFirst() {
     *         window.check = 'should not be prevented';
     *         if (timesFirst < 2) {
     *             timesFirst += 1;
     *             requestAnimationFrame(changeFirst);
     *         }
     *     });
     *
     *     var timesSecond = 0;
     *     requestAnimationFrame(function changeSecond() {
     *         window.second = 'should be prevented';
     *         if (timesSecond < 2) {
     *             timesSecond += 1;
     *             requestAnimationFrame(changeSecond);
     *         }
     *     });
     *     ```
     */

    /* eslint-enable max-len */

    function preventRequestAnimationFrame(source, match) {
      var nativeRequestAnimationFrame = window.requestAnimationFrame; // logs requestAnimationFrame to console if no arguments have been specified

      var shouldLog = typeof match === 'undefined';
      var INVERT_MARKER = '!';
      var doNotMatch = startsWith(match, INVERT_MARKER);

      if (doNotMatch) {
        match = match.slice(1);
      }

      match = match ? toRegExp(match) : toRegExp('/.?/');

      var rafWrapper = function rafWrapper(callback) {
        var shouldPrevent = false;

        if (shouldLog) {
          var logMessage = "log: requestAnimationFrame(\"".concat(callback.toString(), "\")");
          hit(source, logMessage);
        } else {
          shouldPrevent = match.test(callback.toString()) !== doNotMatch;
        }

        if (shouldPrevent) {
          hit(source);
          return nativeRequestAnimationFrame(noopFunc);
        }

        for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {
          args[_key - 1] = arguments[_key];
        }

        return nativeRequestAnimationFrame.apply(window, [callback].concat(args));
      };

      window.requestAnimationFrame = rafWrapper;
    }
    preventRequestAnimationFrame.names = ['prevent-requestAnimationFrame', // aliases are needed for matching the related scriptlet converted into our syntax
    'no-requestAnimationFrame-if.js', 'ubo-no-requestAnimationFrame-if.js', 'norafif.js', 'ubo-norafif.js', 'ubo-no-requestAnimationFrame-if', 'ubo-norafif'];
    preventRequestAnimationFrame.injections = [hit, startsWith, toRegExp, noopFunc];

    /* eslint-disable max-len */

    /**
     * @scriptlet set-cookie
     *
     * @description
     * Sets a cookie with the specified name and value. Cookie path defaults to root.
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('set-cookie', name, value)
     * ```
     *
     * - `name` - required, cookie name to be set
     * - `value` - required, cookie value; possible values:
     *     - number `>= 0 && <= 15`
     *     - one of the predefined constants:
     *         - `true` / `True`
     *         - `false` / `False`
     *         - `yes` / `Yes` / `Y`
     *         - `no`
     *         - `ok` / `OK`
     *
     * **Examples**
     * ```
     * example.org#%#//scriptlet('set-cookie', 'checking', 'ok')
     *
     * example.org#%#//scriptlet('set-cookie', 'gdpr-settings-cookie', '1')
     * ```
     */

    /* eslint-enable max-len */

    function setCookie(source, name, value) {
      if (!name || !value) {
        return;
      }

      var nativeIsNaN = Number.isNaN || window.isNaN; // eslint-disable-line compat/compat

      var valueToSet;

      if (value === 'true') {
        valueToSet = 'true';
      } else if (value === 'True') {
        valueToSet = 'True';
      } else if (value === 'false') {
        valueToSet = 'false';
      } else if (value === 'False') {
        valueToSet = 'False';
      } else if (value === 'yes') {
        valueToSet = 'yes';
      } else if (value === 'Yes') {
        valueToSet = 'Yes';
      } else if (value === 'Y') {
        valueToSet = 'Y';
      } else if (value === 'no') {
        valueToSet = 'no';
      } else if (value === 'ok') {
        valueToSet = 'ok';
      } else if (value === 'OK') {
        valueToSet = 'OK';
      } else if (/^\d+$/.test(value)) {
        valueToSet = parseFloat(value);

        if (nativeIsNaN(valueToSet)) {
          return;
        }

        if (Math.abs(valueToSet) < 0 || Math.abs(valueToSet) > 15) {
          return;
        }
      } else {
        return;
      }

      var pathToSet = 'path=/;';
      var cookieData = "".concat(encodeURIComponent(name), "=").concat(encodeURIComponent(valueToSet), "; ").concat(pathToSet);
      hit(source);
      document.cookie = cookieData;
    }
    setCookie.names = ['set-cookie'];
    setCookie.injections = [hit];

    /**
     * @scriptlet hide-in-shadow-dom
     *
     * @description
     * Hides elements inside open shadow DOM elements.
     *
     * **Syntax**
     * ```
     * example.org#%#//scriptlet('hide-in-shadow-dom', selector[, baseSelector])
     * ```
     *
     * - `selector`  required, CSS selector of element in shadow-dom to hide
     * - `baseSelector`  optional, selector of specific page DOM element,
     * narrows down the part of the page DOM where shadow-dom host supposed to be,
     * defaults to document.documentElement
     *
     * > `baseSelector` should match element of the page DOM, but not of shadow DOM
     *
     * **Examples**
     * ```
     * ! hides menu bar
     * virustotal.com#%#//scriptlet('hide-in-shadow-dom', 'iron-pages', 'vt-virustotal-app')
     *
     * ! hides floating element
     * virustotal.com#%#//scriptlet('hide-in-shadow-dom', 'vt-ui-contact-fab')
     * ```
     */

    function hideInShadowDom(source, selector, baseSelector) {
      // do nothing if browser does not support ShadowRoot
      // https://developer.mozilla.org/en-US/docs/Web/API/ShadowRoot
      if (!Element.prototype.attachShadow) {
        return;
      }
      /**
       * Finds shadow-dom host (elements with shadowRoot property) in DOM of rootElement.
       * @param {HTMLElement} rootElement
       * @returns {nodeList[]} shadow-dom hosts
       */


      var findHostElements = function findHostElements(rootElement) {
        var hosts = []; // Element.querySelectorAll() returns list of elements
        // which are defined in DOM of Element.
        // Meanwhile, inner DOM of the element with shadowRoot property
        // is absolutely another DOM and which can not be reached by querySelectorAll('*')

        var domElems = rootElement.querySelectorAll('*');
        domElems.forEach(function (el) {
          if (el.shadowRoot) {
            hosts.push(el);
          }
        });
        return hosts;
      };
      /**
       * @typedef {Object} PierceData
       * @property {Array} targets found elements
       * @property {Array} innerHosts inner shadow-dom hosts
       */

      /**
       * Pierces open shadow-dom in order to find:
       * - elements by 'selector' matching
       * - inner shadow-dom hosts
       * @param {string} selector
       * @param {nodeList[]} hostElements
       * @returns {PierceData}
       */


      var pierceShadowDom = function pierceShadowDom(selector, hostElements) {
        var targets = [];
        var innerHostsAcc = [];

        var collectTargets = function collectTargets(arr) {
          if (arr.length !== 0) {
            arr.forEach(function (el) {
              return targets.push(el);
            });
          }
        }; // it's possible to get a few hostElements found by baseSelector on the page


        hostElements.forEach(function (host) {
          // check presence of selector element inside base element if it's not in shadow-dom
          var simpleElems = host.querySelectorAll(selector);
          collectTargets(simpleElems);
          var shadowRootElem = host.shadowRoot;
          var shadowChildren = shadowRootElem.querySelectorAll(selector);
          collectTargets(shadowChildren); // find inner shadow-dom hosts inside processing shadow-dom

          innerHostsAcc.push(findHostElements(shadowRootElem));
        }); // if there were more than one host element,
        // innerHostsAcc is an array of arrays and should be flatten

        var innerHosts = flatten(innerHostsAcc);
        return {
          targets: targets,
          innerHosts: innerHosts
        };
      };
      /**
       * Handles shadow-dom piercing and hiding of found elements
       */


      var hideHandler = function hideHandler() {
        // start value of shadow-dom hosts for the page dom
        var hostElements = !baseSelector ? findHostElements(document.documentElement) : document.querySelectorAll(baseSelector); // if there is shadow-dom host, they should be explored

        var _loop = function _loop() {
          var hidden = false;
          var DISPLAY_NONE_CSS = 'display:none!important;';

          var _pierceShadowDom = pierceShadowDom(selector, hostElements),
              targets = _pierceShadowDom.targets,
              innerHosts = _pierceShadowDom.innerHosts;

          targets.forEach(function (targetEl) {
            targetEl.style.cssText = DISPLAY_NONE_CSS;
            hidden = true;
          });

          if (hidden) {
            hit(source);
          } // continue to pierce for inner shadow-dom hosts
          // and search inside them while the next iteration


          hostElements = innerHosts;
        };

        while (hostElements.length !== 0) {
          _loop();
        }
      };

      hideHandler();
      observeDOMChanges(hideHandler, true);
    }
    hideInShadowDom.names = ['hide-in-shadow-dom'];
    hideInShadowDom.injections = [hit, observeDOMChanges, flatten];

    /**
     * This file must export all scriptlets which should be accessible
     */

    var scriptletList = /*#__PURE__*/Object.freeze({
        __proto__: null,
        abortOnPropertyRead: abortOnPropertyRead,
        abortOnPropertyWrite: abortOnPropertyWrite,
        preventSetTimeout: preventSetTimeout,
        preventSetInterval: preventSetInterval,
        preventWindowOpen: preventWindowOpen,
        abortCurrentInlineScript: abortCurrentInlineScript,
        setConstant: setConstant,
        removeCookie: removeCookie,
        preventAddEventListener: preventAddEventListener,
        preventBab: preventBab,
        nowebrtc: nowebrtc,
        logAddEventListener: logAddEventListener,
        logEval: logEval,
        log: log,
        noeval: noeval,
        preventEvalIf: preventEvalIf,
        preventFab: preventFab,
        setPopadsDummy: setPopadsDummy,
        preventPopadsNet: preventPopadsNet,
        preventAdfly: preventAdfly,
        debugOnPropertyRead: debugOnPropertyRead,
        debugOnPropertyWrite: debugOnPropertyWrite,
        debugCurrentInlineScript: debugCurrentInlineScript,
        removeAttr: removeAttr,
        removeClass: removeClass,
        disableNewtabLinks: disableNewtabLinks,
        adjustSetInterval: adjustSetInterval,
        adjustSetTimeout: adjustSetTimeout,
        dirString: dirString,
        jsonPrune: jsonPrune,
        preventRequestAnimationFrame: preventRequestAnimationFrame,
        setCookie: setCookie,
        hideInShadowDom: hideInShadowDom
    });

    const redirects=[{adg:"1x1-transparent.gif",ubo:"1x1.gif",abp:"1x1-transparent-gif"},{adg:"2x2-transparent.png",ubo:"2x2.png",abp:"2x2-transparent-png"},{adg:"3x2-transparent.png",ubo:"3x2.png",abp:"3x2-transparent-png"},{adg:"32x32-transparent.png",ubo:"32x32.png",abp:"32x32-transparent-png"},{adg:"amazon-apstag",ubo:"amazon_apstag.js"},{adg:"google-analytics",ubo:"google-analytics_analytics.js"},{adg:"google-analytics-ga",ubo:"google-analytics_ga.js"},{adg:"googlesyndication-adsbygoogle",ubo:"googlesyndication_adsbygoogle.js"},{adg:"googletagmanager-gtm",ubo:"googletagmanager_gtm.js"},{adg:"googletagservices-gpt",ubo:"googletagservices_gpt.js"},{adg:"metrika-yandex-watch"},{adg:"metrika-yandex-tag"},{adg:"noeval",ubo:"noeval-silent.js"},{adg:"noopcss",abp:"blank-css"},{adg:"noopframe",ubo:"noop.html",abp:"blank-html"},{adg:"noopjs",ubo:"noop.js",abp:"blank-js"},{adg:"nooptext",ubo:"noop.txt",abp:"blank-text"},{adg:"noopmp3-0.1s",ubo:"noop-0.1s.mp3",abp:"blank-mp3"},{adg:"noopmp4-1s",ubo:"noop-1s.mp4",abp:"blank-mp4"},{adg:"noopvmap-1.0"},{adg:"noopvast-2.0"},{adg:"noopvast-3.0"},{adg:"prevent-fab-3.2.0",ubo:"nofab.js"},{adg:"prevent-popads-net",ubo:"popads.js"},{adg:"scorecardresearch-beacon",ubo:"scorecardresearch_beacon.js"},{adg:"set-popads-dummy",ubo:"popads-dummy.js"},{ubo:"addthis_widget.js"},{ubo:"amazon_ads.js"},{ubo:"ampproject_v0.js"},{ubo:"chartbeat.js"},{ubo:"disqus_embed.js"},{ubo:"disqus_forums_embed.js"},{ubo:"doubleclick_instream_ad_status.js"},{ubo:"empty"},{ubo:"google-analytics_cx_api.js"},{ubo:"google-analytics_inpage_linkid.js"},{ubo:"hd-main.js"},{ubo:"ligatus_angular-tag.js"},{ubo:"monkeybroker.js"},{ubo:"outbrain-widget.js"},{ubo:"window.open-defuser.js"},{ubo:"nobab.js"},{ubo:"noeval.js"}];

    var JS_RULE_MARKER = '#%#';
    var COMMENT_MARKER = '!';
    /**
     * Checks if rule text is comment e.g. !!example.org##+js(set-constant.js, test, false)
     * @param {string} rule
     * @return {boolean}
     */

    var isComment = function isComment(rule) {
      return startsWith(rule, COMMENT_MARKER);
    };
    /* ************************************************************************
     *
     * Scriptlets
     *
     ************************************************************************** */

    /**
     * uBlock scriptlet rule mask
     */


    var UBO_SCRIPTLET_MASK_REG = /#@?#script:inject|#@?#\s*\+js/;
    var UBO_SCRIPTLET_MASK_1 = '##+js';
    var UBO_SCRIPTLET_MASK_2 = '##script:inject';
    var UBO_SCRIPTLET_EXCEPTION_MASK_1 = '#@#+js';
    var UBO_SCRIPTLET_EXCEPTION_MASK_2 = '#@#script:inject';
    /**
     * AdBlock Plus snippet rule mask
     */

    var ABP_SCRIPTLET_MASK = '#$#';
    var ABP_SCRIPTLET_EXCEPTION_MASK = '#@$#';
    /**
     * AdGuard CSS rule mask
     */

    var ADG_CSS_MASK_REG = /#@?\$#.+?\s*\{.*\}\s*$/g;
    /**
     * Checks if the `rule` is AdGuard scriptlet rule
     * @param {string} rule - rule text
     */

    var isAdgScriptletRule = function isAdgScriptletRule(rule) {
      return !isComment(rule) && rule.indexOf(ADG_SCRIPTLET_MASK) > -1;
    };
    /**
     * Checks if the `rule` is uBO scriptlet rule
     * @param {string} rule rule text
     */


    var isUboScriptletRule = function isUboScriptletRule(rule) {
      return (rule.indexOf(UBO_SCRIPTLET_MASK_1) > -1 || rule.indexOf(UBO_SCRIPTLET_MASK_2) > -1 || rule.indexOf(UBO_SCRIPTLET_EXCEPTION_MASK_1) > -1 || rule.indexOf(UBO_SCRIPTLET_EXCEPTION_MASK_2) > -1) && UBO_SCRIPTLET_MASK_REG.test(rule) && !isComment(rule);
    };
    /**
     * Checks if the `rule` is AdBlock Plus snippet
     * @param {string} rule rule text
     */


    var isAbpSnippetRule = function isAbpSnippetRule(rule) {
      return (rule.indexOf(ABP_SCRIPTLET_MASK) > -1 || rule.indexOf(ABP_SCRIPTLET_EXCEPTION_MASK) > -1) && rule.search(ADG_CSS_MASK_REG) === -1 && !isComment(rule);
    };
    /**
     * Finds scriptlet by it's name
     * @param {string} name - scriptlet name
     */


    var getScriptletByName = function getScriptletByName(name) {
      var scriptlets = Object.keys(scriptletList).map(function (key) {
        return scriptletList[key];
      });
      return scriptlets.find(function (s) {
        return s.names // full match name checking
        && (s.names.indexOf(name) > -1 // or check ubo alias name without '.js' at the end
        || !endsWith(name, '.js') && s.names.indexOf("".concat(name, ".js")) > -1);
      });
    };
    /**
     * Checks if the scriptlet name is valid
     * @param {string} name - Scriptlet name
     */


    var isValidScriptletName = function isValidScriptletName(name) {
      if (!name) {
        return false;
      }

      var scriptlet = getScriptletByName(name);

      if (!scriptlet) {
        return false;
      }

      return true;
    };
    /* ************************************************************************
     *
     * Redirects
     *
     ************************************************************************** */

    /**
     * Redirect resources markers
     */


    var ADG_UBO_REDIRECT_MARKER = 'redirect=';
    var ABP_REDIRECT_MARKER = 'rewrite=abp-resource:';
    var VALID_SOURCE_TYPES = ['image', 'subdocument', 'stylesheet', 'script', 'xmlhttprequest', 'media'];
    var validAdgRedirects = redirects.filter(function (el) {
      return el.adg;
    });
    /**
     * Converts array of pairs to object.
     * Sort of Object.fromEntries() polyfill.
     * @param {Array} pairs - array of pairs
     * @returns {Object}
     */

    var objFromEntries = function objFromEntries(pairs) {
      var output = pairs.reduce(function (acc, el) {
        var _el = slicedToArray(el, 2),
            key = _el[0],
            value = _el[1];

        acc[key] = value;
        return acc;
      }, {});
      return output;
    };
    /**
     * Compatibility object where KEYS = UBO redirect names and VALUES = ADG redirect names
     * It's used for UBO -> ADG converting
     */


    var uboToAdgCompatibility = objFromEntries(validAdgRedirects.filter(function (el) {
      return el.ubo;
    }).map(function (el) {
      return [el.ubo, el.adg];
    }));
    /**
     * Compatibility object where KEYS = ABP redirect names and VALUES = ADG redirect names
     * It's used for ABP -> ADG converting
     */

    var abpToAdgCompatibility = objFromEntries(validAdgRedirects.filter(function (el) {
      return el.abp;
    }).map(function (el) {
      return [el.abp, el.adg];
    }));
    /**
     * Compatibility object where KEYS = UBO redirect names and VALUES = ADG redirect names
     * It's used for ADG -> UBO converting
     */

    var adgToUboCompatibility = objFromEntries(validAdgRedirects.filter(function (el) {
      return el.ubo;
    }).map(function (el) {
      return [el.adg, el.ubo];
    }));
    /**
     * Needed for AdGuard redirect names validation where KEYS = **valid** AdGuard redirect names
     * 'adgToUboCompatibility' is still needed for ADG -> UBO converting
     */

    var validAdgCompatibility = objFromEntries(validAdgRedirects.map(function (el) {
      return [el.adg, 'valid adg redirect'];
    }));
    var REDIRECT_RULE_TYPES = {
      VALID_ADG: {
        marker: ADG_UBO_REDIRECT_MARKER,
        compatibility: validAdgCompatibility
      },
      ADG: {
        marker: ADG_UBO_REDIRECT_MARKER,
        compatibility: adgToUboCompatibility
      },
      UBO: {
        marker: ADG_UBO_REDIRECT_MARKER,
        compatibility: uboToAdgCompatibility
      },
      ABP: {
        marker: ABP_REDIRECT_MARKER,
        compatibility: abpToAdgCompatibility
      }
    };
    /**
     * Parses redirect rule modifiers
     * @param {string} rule
     * @returns {Array}
     */

    var parseModifiers = function parseModifiers(rule) {
      return substringAfter(rule, '$').split(',');
    };
    /**
     * Gets redirect resource name
     * @param {string} rule
     * @param {string} marker - specific Adg/Ubo or Abp redirect resources marker
     * @returns {string} - redirect resource name
     */


    var getRedirectName = function getRedirectName(rule, marker) {
      var ruleModifiers = parseModifiers(rule);
      var redirectNamePart = ruleModifiers.find(function (el) {
        return el.indexOf(marker) > -1;
      });
      return substringAfter(redirectNamePart, marker);
    };
    /**
     * Checks if the `rule` is AdGuard redirect rule.
     * Discards comments and JS rules and checks if the `rule` has 'redirect' modifier.
     * @param {string} rule - rule text
     */


    var isAdgRedirectRule = function isAdgRedirectRule(rule) {
      var MARKER_IN_BASE_PART_MASK = '/((?!\\$|\\,).{1})redirect=(.{0,}?)\\$(popup)?/';
      return !isComment(rule) && rule.indexOf(REDIRECT_RULE_TYPES.ADG.marker) > -1 // some js rules may have 'redirect=' in it, so we should get rid of them
      && rule.indexOf(JS_RULE_MARKER) === -1 // get rid of rules like '_redirect=*://look.$popup'
      && !toRegExp(MARKER_IN_BASE_PART_MASK).test(rule);
    };
    /**
     * Checks if the `rule` satisfies the `type`
     * @param {string} rule - rule text
     * @param {'VALID_ADG'|'ADG'|'UBO'|'ABP'} type - type of a redirect rule
     */


    var isRedirectRuleByType = function isRedirectRuleByType(rule, type) {
      var _REDIRECT_RULE_TYPES$ = REDIRECT_RULE_TYPES[type],
          marker = _REDIRECT_RULE_TYPES$.marker,
          compatibility = _REDIRECT_RULE_TYPES$.compatibility;

      if (rule && !isComment(rule) && rule.indexOf(marker) > -1) {
        var redirectName = getRedirectName(rule, marker);
        return redirectName === Object.keys(compatibility).find(function (el) {
          return el === redirectName;
        });
      }

      return false;
    };
    /**
    * Checks if the `rule` is **valid** AdGuard redirect resource rule
    * @param {string} rule - rule text
    * @returns {boolean}
    */


    var isValidAdgRedirectRule = function isValidAdgRedirectRule(rule) {
      return isRedirectRuleByType(rule, 'VALID_ADG');
    };
    /**
    * Checks if the AdGuard redirect `rule` has Ubo analog. Needed for Adg->Ubo conversion
    * @param {string} rule - AdGuard rule text
    * @returns {boolean} - true if the rule can be converted to Ubo
    */


    var isAdgRedirectCompatibleWithUbo = function isAdgRedirectCompatibleWithUbo(rule) {
      return isAdgRedirectRule(rule) && isRedirectRuleByType(rule, 'ADG');
    };
    /**
    * Checks if the Ubo redirect `rule` has AdGuard analog. Needed for Ubo->Adg conversion
    * @param {string} rule - Ubo rule text
    * @returns {boolean} - true if the rule can be converted to AdGuard
    */


    var isUboRedirectCompatibleWithAdg = function isUboRedirectCompatibleWithAdg(rule) {
      return isRedirectRuleByType(rule, 'UBO');
    };
    /**
    * Checks if the Abp redirect `rule` has AdGuard analog. Needed for Abp->Adg conversion
    * @param {string} rule - Abp rule text
    * @returns {boolean} - true if the rule can be converted to AdGuard
    */


    var isAbpRedirectCompatibleWithAdg = function isAbpRedirectCompatibleWithAdg(rule) {
      return isRedirectRuleByType(rule, 'ABP');
    };
    /**
     * Checks if the rule has specified content type before Adg -> Ubo conversion.
     *
     * Used ONLY for Adg -> Ubo conversion
     * because Ubo redirect rules must contain content type, but Adg and Abp must not.
     *
     * Also source type can not be added automatically because of such valid rules:
     * ! Abp:
     * $rewrite=abp-resource:blank-js,xmlhttprequest
     * ! Adg:
     * $script,redirect=noopvast-2.0
     * $xmlhttprequest,redirect=noopvast-2.0
     *
     * @param {string} rule
     * @returns {boolean}
     */


    var hasValidContentType = function hasValidContentType(rule) {
      if (isRedirectRuleByType(rule, 'ADG')) {
        var ruleModifiers = parseModifiers(rule);
        var sourceType = ruleModifiers.find(function (el) {
          return VALID_SOURCE_TYPES.indexOf(el) > -1;
        });
        return sourceType !== undefined;
      }

      return false;
    };

    var validator = {
      UBO_SCRIPTLET_MASK_REG: UBO_SCRIPTLET_MASK_REG,
      ABP_SCRIPTLET_MASK: ABP_SCRIPTLET_MASK,
      ABP_SCRIPTLET_EXCEPTION_MASK: ABP_SCRIPTLET_EXCEPTION_MASK,
      isComment: isComment,
      isAdgScriptletRule: isAdgScriptletRule,
      isUboScriptletRule: isUboScriptletRule,
      isAbpSnippetRule: isAbpSnippetRule,
      getScriptletByName: getScriptletByName,
      isValidScriptletName: isValidScriptletName,
      REDIRECT_RULE_TYPES: REDIRECT_RULE_TYPES,
      isAdgRedirectRule: isAdgRedirectRule,
      isValidAdgRedirectRule: isValidAdgRedirectRule,
      isAdgRedirectCompatibleWithUbo: isAdgRedirectCompatibleWithUbo,
      isUboRedirectCompatibleWithAdg: isUboRedirectCompatibleWithAdg,
      isAbpRedirectCompatibleWithAdg: isAbpRedirectCompatibleWithAdg,
      parseModifiers: parseModifiers,
      getRedirectName: getRedirectName,
      hasValidContentType: hasValidContentType
    };

    function _iterableToArray(iter) {
      if (typeof Symbol !== "undefined" && Symbol.iterator in Object(iter)) return Array.from(iter);
    }

    var iterableToArray = _iterableToArray;

    function _toArray(arr) {
      return arrayWithHoles(arr) || iterableToArray(arr) || unsupportedIterableToArray(arr) || nonIterableRest();
    }

    var toArray = _toArray;

    /**
     * AdGuard scriptlet rule
     */

    var ADGUARD_SCRIPTLET_MASK_REG = /#@?%#\/\/scriptlet\(.+\)/; // eslint-disable-next-line no-template-curly-in-string

    var ADGUARD_SCRIPTLET_TEMPLATE = '${domains}#%#//scriptlet(${args})'; // eslint-disable-next-line no-template-curly-in-string

    var ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE = '${domains}#@%#//scriptlet(${args})';
    /**
     * uBlock scriptlet rule mask
     */
    // eslint-disable-next-line no-template-curly-in-string

    var UBO_SCRIPTLET_TEMPLATE = '${domains}##+js(${args})'; // eslint-disable-next-line no-template-curly-in-string

    var UBO_SCRIPTLET_EXCEPTION_TEMPLATE = '${domains}#@#+js(${args})';
    var UBO_ALIAS_NAME_MARKER = 'ubo-'; // https://github.com/gorhill/uBlock/wiki/Static-filter-syntax#xhr

    var UBO_XHR_TYPE = 'xhr';
    var ADG_XHR_TYPE = 'xmlhttprequest';
    /**
     * Returns array of strings separated by space which not in quotes
     * @param {string} str
     */

    var getSentences = function getSentences(str) {
      var reg = /'.*?'|".*?"|\S+/g;
      return str.match(reg);
    };
    /**
     * Replaces string with data by placeholders
     * @param {string} str
     * @param {Object} data - where keys are placeholders names
     */


    var replacePlaceholders = function replacePlaceholders(str, data) {
      return Object.keys(data).reduce(function (acc, key) {
        var reg = new RegExp("\\$\\{".concat(key, "\\}"), 'g');
        acc = acc.replace(reg, data[key]);
        return acc;
      }, str);
    };
    /**
     * Converts string of UBO scriptlet rule to AdGuard scritlet rule
     * @param {string} rule - UBO scriptlet rule
     * @returns {Array} - array with one AdGuard scriptlet rule
     */


    var convertUboScriptletToAdg = function convertUboScriptletToAdg(rule) {
      var domains = getBeforeRegExp(rule, validator.UBO_SCRIPTLET_MASK_REG);
      var mask = rule.match(validator.UBO_SCRIPTLET_MASK_REG)[0];
      var template;

      if (mask.indexOf('@') > -1) {
        template = ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE;
      } else {
        template = ADGUARD_SCRIPTLET_TEMPLATE;
      }

      var args = getStringInBraces(rule).split(/, /g).map(function (arg, index) {
        var outputArg;

        if (index === 0) {
          outputArg = arg.indexOf('.js') > -1 ? "ubo-".concat(arg) : "ubo-".concat(arg, ".js");
        } else {
          outputArg = arg;
        } // for example: dramaserial.xyz##+js(abort-current-inline-script, $, popup)


        if (arg === '$') {
          outputArg = '$$';
        }

        return outputArg;
      }).map(function (arg) {
        return wrapInSingleQuotes(arg);
      }).join(', ');
      var adgRule = replacePlaceholders(template, {
        domains: domains,
        args: args
      });
      return [adgRule];
    };
    /**
     * Convert string of ABP snippet rule to AdGuard scritlet rule
     * @param {string} rule - ABP snippet rule
     * @returns {Array} - array of AdGuard scriptlet rules -
     * one or few items depends on Abp-rule
     */

    var convertAbpSnippetToAdg = function convertAbpSnippetToAdg(rule) {
      var SEMICOLON_DIVIDER = /;(?=(?:(?:[^"]*"){2})*[^"]*$)/g;
      var mask = rule.indexOf(validator.ABP_SCRIPTLET_MASK) > -1 ? validator.ABP_SCRIPTLET_MASK : validator.ABP_SCRIPTLET_EXCEPTION_MASK;
      var template = mask === validator.ABP_SCRIPTLET_MASK ? ADGUARD_SCRIPTLET_TEMPLATE : ADGUARD_SCRIPTLET_EXCEPTION_TEMPLATE;
      var domains = substringBefore(rule, mask);
      var args = substringAfter(rule, mask);
      return args.split(SEMICOLON_DIVIDER).map(function (args) {
        return getSentences(args).filter(function (arg) {
          return arg;
        }).map(function (arg, index) {
          return index === 0 ? "abp-".concat(arg) : arg;
        }).map(function (arg) {
          return wrapInSingleQuotes(arg);
        }).join(', ');
      }).map(function (args) {
        return replacePlaceholders(template, {
          domains: domains,
          args: args
        });
      });
    };
    /**
     * Converts scriptlet rule to AdGuard one
     * @param {string} rule
     * @returns {Array} - array of AdGuard scriptlet rules -
     * one item for Adg and Ubo or few items for Abp
     */

    var convertScriptletToAdg = function convertScriptletToAdg(rule) {
      var result;

      if (validator.isUboScriptletRule(rule)) {
        result = convertUboScriptletToAdg(rule);
      } else if (validator.isAbpSnippetRule(rule)) {
        result = convertAbpSnippetToAdg(rule);
      } else if (validator.isAdgScriptletRule(rule) || validator.isComment(rule)) {
        result = [rule];
      }

      return result;
    };
    /**
     * Converts UBO scriptlet rule to AdGuard one
     * @param {string} rule - AdGuard scriptlet rule
     * @returns {string} - UBO scriptlet rule
     */

    var convertAdgScriptletToUbo = function convertAdgScriptletToUbo(rule) {
      var res;

      if (validator.isAdgScriptletRule(rule)) {
        var _parseRule = parseRule(rule),
            parsedName = _parseRule.name,
            parsedParams = _parseRule.args; // object of name and aliases for the Adg-scriptlet


        var adgScriptletObject = Object.keys(scriptletList).map(function (el) {
          return scriptletList[el];
        }).map(function (s) {
          var _s$names = toArray(s.names),
              name = _s$names[0],
              aliases = _s$names.slice(1);

          return {
            name: name,
            aliases: aliases
          };
        }).find(function (el) {
          return el.name === parsedName || el.aliases.indexOf(parsedName) >= 0;
        });
        var aliases = adgScriptletObject.aliases;

        if (aliases.length > 0) {
          var uboAlias = adgScriptletObject.aliases // eslint-disable-next-line no-restricted-properties
          .find(function (alias) {
            return alias.includes(UBO_ALIAS_NAME_MARKER);
          });

          if (uboAlias) {
            var mask = rule.match(ADGUARD_SCRIPTLET_MASK_REG)[0];
            var template;

            if (mask.indexOf('@') > -1) {
              template = UBO_SCRIPTLET_EXCEPTION_TEMPLATE;
            } else {
              template = UBO_SCRIPTLET_TEMPLATE;
            }

            var domains = getBeforeRegExp(rule, ADGUARD_SCRIPTLET_MASK_REG);
            var uboName = uboAlias.replace(UBO_ALIAS_NAME_MARKER, '') // '.js' in the Ubo scriptlet name can be omitted
            // https://github.com/gorhill/uBlock/wiki/Resources-Library#general-purpose-scriptlets
            .replace('.js', '');
            var args = parsedParams.length > 0 ? "".concat(uboName, ", ").concat(parsedParams.join(', ')) : uboName;
            var uboRule = replacePlaceholders(template, {
              domains: domains,
              args: args
            });
            res = uboRule;
          }
        }
      }

      return res;
    };
    /**
     * Validates any scriptlet rule
     * @param {string} input - can be Adguard or Ubo or Abp scriptlet rule
     */

    var isValidScriptletRule = function isValidScriptletRule(input) {
      if (!input) {
        return false;
      } // ABP 'input' rule may contain more than one snippet


      var rulesArray = convertScriptletToAdg(input); // checking if each of parsed scriptlets is valid
      // if at least one of them is not valid - whole 'input' rule is not valid too

      var isValid = rulesArray.reduce(function (acc, rule) {
        var parsedRule = parseRule(rule);
        return validator.isValidScriptletName(parsedRule.name) && acc;
      }, true);
      return isValid;
    };
    /**
     * Converts Ubo redirect rule to Adg one
     * @param {string} rule
     * @returns {string}
     */

    var convertUboRedirectToAdg = function convertUboRedirectToAdg(rule) {
      var firstPartOfRule = substringBefore(rule, '$');
      var uboModifiers = validator.parseModifiers(rule);
      var adgModifiers = uboModifiers.map(function (el) {
        if (el.indexOf(validator.REDIRECT_RULE_TYPES.UBO.marker) > -1) {
          var uboName = substringAfter(el, validator.REDIRECT_RULE_TYPES.UBO.marker);
          var adgName = validator.REDIRECT_RULE_TYPES.UBO.compatibility[uboName];
          return "".concat(validator.REDIRECT_RULE_TYPES.ADG.marker).concat(adgName);
        }

        if (el === UBO_XHR_TYPE) {
          return ADG_XHR_TYPE;
        }

        return el;
      }).join(',');
      return "".concat(firstPartOfRule, "$").concat(adgModifiers);
    };
    /**
     * Converts Abp redirect rule to Adg one
     * @param {string} rule
     * @returns {string}
     */

    var convertAbpRedirectToAdg = function convertAbpRedirectToAdg(rule) {
      var firstPartOfRule = substringBefore(rule, '$');
      var abpModifiers = validator.parseModifiers(rule);
      var adgModifiers = abpModifiers.map(function (el) {
        if (el.indexOf(validator.REDIRECT_RULE_TYPES.ABP.marker) > -1) {
          var abpName = substringAfter(el, validator.REDIRECT_RULE_TYPES.ABP.marker);
          var adgName = validator.REDIRECT_RULE_TYPES.ABP.compatibility[abpName];
          return "".concat(validator.REDIRECT_RULE_TYPES.ADG.marker).concat(adgName);
        }

        return el;
      }).join(',');
      return "".concat(firstPartOfRule, "$").concat(adgModifiers);
    };
    /**
     * Converts redirect rule to AdGuard one
     * @param {string} rule
     * @returns {string}
     */

    var convertRedirectToAdg = function convertRedirectToAdg(rule) {
      var result;

      if (validator.isUboRedirectCompatibleWithAdg(rule)) {
        result = convertUboRedirectToAdg(rule);
      } else if (validator.isAbpRedirectCompatibleWithAdg(rule)) {
        result = convertAbpRedirectToAdg(rule);
      } else if (validator.isValidAdgRedirectRule(rule)) {
        result = rule;
      }

      return result;
    };
    /**
     * Converts Adg redirect rule to Ubo one
     * @param {string} rule
     * @returns {string}
     */

    var convertAdgRedirectToUbo = function convertAdgRedirectToUbo(rule) {
      if (!validator.hasValidContentType(rule)) {
        throw new Error("Rule is not valid for converting to Ubo. Source type is not specified in the rule: ".concat(rule));
      } else {
        var firstPartOfRule = substringBefore(rule, '$');
        var uboModifiers = validator.parseModifiers(rule);
        var adgModifiers = uboModifiers.map(function (el) {
          if (el.indexOf(validator.REDIRECT_RULE_TYPES.ADG.marker) > -1) {
            var adgName = substringAfter(el, validator.REDIRECT_RULE_TYPES.ADG.marker);
            var uboName = validator.REDIRECT_RULE_TYPES.ADG.compatibility[adgName];
            return "".concat(validator.REDIRECT_RULE_TYPES.UBO.marker).concat(uboName);
          }

          return el;
        }).join(',');
        return "".concat(firstPartOfRule, "$").concat(adgModifiers);
      }
    };

    /**
     * @redirect google-analytics
     *
     * @description
     * Mocks Google Analytics API.
     *
     * Related UBO redirect resource:
     * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/google-analytics_analytics.js
     *
     * **Example**
     * ```
     * ||google-analytics.com/analytics.js$script,redirect=google-analytics
     * ```
     */

    function GoogleAnalytics(source) {
      // eslint-disable-next-line func-names
      var Tracker = function Tracker() {}; // constructor


      var proto = Tracker.prototype;
      proto.get = noopFunc;
      proto.set = noopFunc;
      proto.send = noopFunc;
      var googleAnalyticsName = window.GoogleAnalyticsObject || 'ga'; // a -- fake arg for 'ga.length < 1' antiadblock checking
      // eslint-disable-next-line no-unused-vars

      function ga(a) {
        var len = arguments.length;

        if (len === 0) {
          return;
        } // eslint-disable-next-line prefer-rest-params


        var lastArg = arguments[len - 1];

        if (typeof lastArg !== 'object' || lastArg === null || typeof lastArg.hitCallback !== 'function') {
          return;
        }

        try {
          lastArg.hitCallback(); // eslint-disable-next-line no-empty
        } catch (ex) {}
      }

      ga.create = function () {
        return new Tracker();
      };

      ga.getByName = noopNull;
      ga.getAll = noopArray;
      ga.remove = noopFunc;
      ga.loaded = true;
      window[googleAnalyticsName] = ga;
      var _window = window,
          dataLayer = _window.dataLayer;

      if (dataLayer instanceof Object && dataLayer.hide instanceof Object && typeof dataLayer.hide.end === 'function') {
        dataLayer.hide.end();
      }

      hit(source);
    }
    GoogleAnalytics.names = ['google-analytics', 'ubo-google-analytics_analytics.js', 'google-analytics_analytics.js'];
    GoogleAnalytics.injections = [hit, noopFunc, noopNull, noopArray];

    /* eslint-disable no-underscore-dangle */
    /**
     * @redirect google-analytics-ga
     *
     * @description
     * Mocks old Google Analytics API.
     *
     * Related UBO redirect resource:
     * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/google-analytics_ga.js
     *
     * **Example**
     * ```
     * ||google-analytics.com/ga.js$script,redirect=google-analytics-ga
     * ```
     */

    function GoogleAnalyticsGa(source) {
      // Gaq constructor
      function Gaq() {}

      Gaq.prototype.Na = noopFunc;
      Gaq.prototype.O = noopFunc;
      Gaq.prototype.Sa = noopFunc;
      Gaq.prototype.Ta = noopFunc;
      Gaq.prototype.Va = noopFunc;
      Gaq.prototype._createAsyncTracker = noopFunc;
      Gaq.prototype._getAsyncTracker = noopFunc;
      Gaq.prototype._getPlugin = noopFunc;

      Gaq.prototype.push = function (data) {
        if (typeof data === 'function') {
          data();
          return;
        }

        if (Array.isArray(data) === false) {
          return;
        } // https://developers.google.com/analytics/devguides/collection/gajs/methods/gaJSApiDomainDirectory#_gat.GA_Tracker_._link


        if (data[0] === '_link' && typeof data[1] === 'string') {
          window.location.assign(data[1]);
        } // https://github.com/gorhill/uBlock/issues/2162


        if (data[0] === '_set' && data[1] === 'hitCallback' && typeof data[2] === 'function') {
          data[2]();
        }
      };

      var gaq = new Gaq();
      var asyncTrackers = window._gaq || [];

      if (Array.isArray(asyncTrackers)) {
        while (asyncTrackers[0]) {
          gaq.push(asyncTrackers.shift());
        }
      } // eslint-disable-next-line no-multi-assign


      window._gaq = gaq.qf = gaq; // Gat constructor

      function Gat() {} // Mock tracker api


      var api = ['_addIgnoredOrganic', '_addIgnoredRef', '_addItem', '_addOrganic', '_addTrans', '_clearIgnoredOrganic', '_clearIgnoredRef', '_clearOrganic', '_cookiePathCopy', '_deleteCustomVar', '_getName', '_setAccount', '_getAccount', '_getClientInfo', '_getDetectFlash', '_getDetectTitle', '_getLinkerUrl', '_getLocalGifPath', '_getServiceMode', '_getVersion', '_getVisitorCustomVar', '_initData', '_link', '_linkByPost', '_setAllowAnchor', '_setAllowHash', '_setAllowLinker', '_setCampContentKey', '_setCampMediumKey', '_setCampNameKey', '_setCampNOKey', '_setCampSourceKey', '_setCampTermKey', '_setCampaignCookieTimeout', '_setCampaignTrack', '_setClientInfo', '_setCookiePath', '_setCookiePersistence', '_setCookieTimeout', '_setCustomVar', '_setDetectFlash', '_setDetectTitle', '_setDomainName', '_setLocalGifPath', '_setLocalRemoteServerMode', '_setLocalServerMode', '_setReferrerOverride', '_setRemoteServerMode', '_setSampleRate', '_setSessionTimeout', '_setSiteSpeedSampleRate', '_setSessionCookieTimeout', '_setVar', '_setVisitorCookieTimeout', '_trackEvent', '_trackPageLoadTime', '_trackPageview', '_trackSocial', '_trackTiming', '_trackTrans', '_visitCode'];
      var tracker = api.reduce(function (res, funcName) {
        res[funcName] = noopFunc;
        return res;
      }, {});

      tracker._getLinkerUrl = function (a) {
        return a;
      };

      Gat.prototype._anonymizeIP = noopFunc;
      Gat.prototype._createTracker = noopFunc;
      Gat.prototype._forceSSL = noopFunc;
      Gat.prototype._getPlugin = noopFunc;

      Gat.prototype._getTracker = function () {
        return tracker;
      };

      Gat.prototype._getTrackerByName = function () {
        return tracker;
      };

      Gat.prototype._getTrackers = noopFunc;
      Gat.prototype.aa = noopFunc;
      Gat.prototype.ab = noopFunc;
      Gat.prototype.hb = noopFunc;
      Gat.prototype.la = noopFunc;
      Gat.prototype.oa = noopFunc;
      Gat.prototype.pa = noopFunc;
      Gat.prototype.u = noopFunc;
      var gat = new Gat();
      window._gat = gat;
      hit(source);
    }
    GoogleAnalyticsGa.names = ['google-analytics-ga', 'ubo-google-analytics_ga.js', 'google-analytics_ga.js'];
    GoogleAnalyticsGa.injections = [hit, noopFunc];

    /* eslint-disable max-len */

    /**
     * @redirect googlesyndication-adsbygoogle
     *
     * @description
     * Mocks Google AdSense API.
     *
     * Related UBO redirect resource:
     * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/googlesyndication_adsbygoogle.js
     *
     * **Example**
     * ```
     * ||pagead2.googlesyndication.com/pagead/js/adsbygoogle.js$script,redirect=googlesyndication-adsbygoogle
     * ```
     */

    /* eslint-enable max-len */

    function GoogleSyndicationAdsByGoogle(source) {
      window.adsbygoogle = {
        length: 0,
        loaded: true,
        push: function push() {
          this.length += 1;
        }
      };
      var adElems = document.querySelectorAll('.adsbygoogle');
      var css = 'height:1px!important;max-height:1px!important;max-width:1px!important;width:1px!important;';
      var statusAttrName = 'data-adsbygoogle-status';
      var ASWIFT_IFRAME_MARKER = 'aswift_';
      var GOOGLE_ADS_IFRAME_MARKER = 'google_ads_iframe_';
      var executed = false;

      for (var i = 0; i < adElems.length; i += 1) {
        var adElemChildNodes = adElems[i].childNodes;
        var childNodesQuantity = adElemChildNodes.length; // childNodes of .adsbygoogle can be defined if scriptlet was executed before
        // so we should check are that childNodes exactly defined by us
        // TODO: remake after scriptlets context developing in 1.3

        var areIframesDefined = false;

        if (childNodesQuantity > 0) {
          // it should be only 2 child iframes if scriptlet was executed
          areIframesDefined = childNodesQuantity === 2 // the first of child nodes should be aswift iframe
          && adElemChildNodes[0].tagName.toLowerCase() === 'iframe' && adElemChildNodes[0].id.indexOf(ASWIFT_IFRAME_MARKER) > -1 // the second of child nodes should be google_ads iframe
          && adElemChildNodes[1].tagName.toLowerCase() === 'iframe' && adElemChildNodes[1].id.indexOf(GOOGLE_ADS_IFRAME_MARKER) > -1;
        }

        if (!areIframesDefined) {
          // here we do the job if scriptlet has not been executed earlier
          adElems[i].setAttribute(statusAttrName, 'done');
          var aswiftIframe = document.createElement('iframe');
          aswiftIframe.id = "".concat(ASWIFT_IFRAME_MARKER).concat(i + 1);
          aswiftIframe.style = css;
          adElems[i].appendChild(aswiftIframe);
          var innerAswiftIframe = document.createElement('iframe');
          aswiftIframe.contentWindow.document.body.appendChild(innerAswiftIframe);
          var googleadsIframe = document.createElement('iframe');
          googleadsIframe.id = "".concat(GOOGLE_ADS_IFRAME_MARKER).concat(i + 1);
          googleadsIframe.style = css;
          adElems[i].appendChild(googleadsIframe);
          var innerGoogleadsIframe = document.createElement('iframe');
          googleadsIframe.contentWindow.document.body.appendChild(innerGoogleadsIframe);
          executed = true;
        }
      }

      if (executed) {
        hit(source);
      }
    }
    GoogleSyndicationAdsByGoogle.names = ['googlesyndication-adsbygoogle', 'ubo-googlesyndication_adsbygoogle.js', 'googlesyndication_adsbygoogle.js'];
    GoogleSyndicationAdsByGoogle.injections = [hit];

    /**
     * @redirect googletagmanager-gtm
     *
     * @description
     * Mocks Google Tag Manager API.
     *
     * Related UBO redirect resource:
     * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/googletagmanager_gtm.js
     *
     * **Example**
     * ```
     * ||googletagmanager.com/gtm.js$script,redirect=googletagmanager-gtm
     * ```
     */

    function GoogleTagManagerGtm(source) {
      window.ga = window.ga || noopFunc;
      var _window = window,
          dataLayer = _window.dataLayer,
          google_optimize = _window.google_optimize; // eslint-disable-line camelcase

      if (dataLayer instanceof Object === false) {
        return;
      }

      if (dataLayer.hide instanceof Object && typeof dataLayer.hide.end === 'function') {
        dataLayer.hide.end();
      }

      if (typeof dataLayer.push === 'function') {
        dataLayer.push = function (data) {
          if (data instanceof Object && typeof data.eventCallback === 'function') {
            setTimeout(data.eventCallback, 1);
          }
        };
      } // https://github.com/AdguardTeam/Scriptlets/issues/81


      if (google_optimize instanceof Object && typeof google_optimize.get === 'function') {
        // eslint-disable-line camelcase
        var googleOptimizeWrapper = {};
        googleOptimizeWrapper.get = noopFunc;
        window.google_optimize = googleOptimizeWrapper;
      }

      hit(source);
    }
    GoogleTagManagerGtm.names = ['googletagmanager-gtm', 'ubo-googletagmanager_gtm.js', 'googletagmanager_gtm.js'];
    GoogleTagManagerGtm.injections = [hit, noopFunc];

    /**
     * @redirect googletagservices-gpt
     *
     * @description
     * Mocks Google Publisher Tag API.
     *
     * Related UBO redirect resource:
     * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/googletagservices_gpt.js
     *
     * **Example**
     * ```
     * ||googletagservices.com/tag/js/gpt.js$script,redirect=googletagservices-gpt
     * ```
     */

    function GoogleTagServicesGpt(source) {
      var companionAdsService = {
        addEventListener: noopThis,
        enableSyncLoading: noopFunc,
        setRefreshUnfilledSlots: noopFunc
      };
      var contentService = {
        addEventListener: noopThis,
        setContent: noopFunc
      };

      function PassbackSlot() {} // constructor


      PassbackSlot.prototype.display = noopFunc;
      PassbackSlot.prototype.get = noopNull;
      PassbackSlot.prototype.set = noopThis;
      PassbackSlot.prototype.setClickUrl = noopThis;
      PassbackSlot.prototype.setTagForChildDirectedTreatment = noopThis;
      PassbackSlot.prototype.setTargeting = noopThis;
      PassbackSlot.prototype.updateTargetingFromMap = noopThis;

      function SizeMappingBuilder() {} // constructor


      SizeMappingBuilder.prototype.addSize = noopThis;
      SizeMappingBuilder.prototype.build = noopNull;

      function Slot() {} // constructor


      Slot.prototype.addService = noopThis;
      Slot.prototype.clearCategoryExclusions = noopThis;
      Slot.prototype.clearTargeting = noopThis;
      Slot.prototype.defineSizeMapping = noopThis;
      Slot.prototype.get = noopNull;
      Slot.prototype.getAdUnitPath = noopArray;
      Slot.prototype.getAttributeKeys = noopArray;
      Slot.prototype.getCategoryExclusions = noopArray;
      Slot.prototype.getDomId = noopStr;
      Slot.prototype.getSlotElementId = noopStr;
      Slot.prototype.getSlotId = noopThis;
      Slot.prototype.getTargeting = noopArray;
      Slot.prototype.getTargetingKeys = noopArray;
      Slot.prototype.set = noopThis;
      Slot.prototype.setCategoryExclusion = noopThis;
      Slot.prototype.setClickUrl = noopThis;
      Slot.prototype.setCollapseEmptyDiv = noopThis;
      Slot.prototype.setTargeting = noopThis;
      var pubAdsService = {
        addEventListener: noopThis,
        clear: noopFunc,
        clearCategoryExclusions: noopThis,
        clearTagForChildDirectedTreatment: noopThis,
        clearTargeting: noopThis,
        collapseEmptyDivs: noopFunc,
        defineOutOfPagePassback: function defineOutOfPagePassback() {
          return new PassbackSlot();
        },
        definePassback: function definePassback() {
          return new PassbackSlot();
        },
        disableInitialLoad: noopFunc,
        display: noopFunc,
        enableAsyncRendering: noopFunc,
        enableSingleRequest: noopFunc,
        enableSyncRendering: noopFunc,
        enableVideoAds: noopFunc,
        get: noopNull,
        getAttributeKeys: noopArray,
        getTargeting: noopFunc,
        getTargetingKeys: noopArray,
        getSlots: noopArray,
        refresh: noopFunc,
        set: noopThis,
        setCategoryExclusion: noopThis,
        setCentering: noopFunc,
        setCookieOptions: noopThis,
        setForceSafeFrame: noopThis,
        setLocation: noopThis,
        setPublisherProvidedId: noopThis,
        setRequestNonPersonalizedAds: noopThis,
        setSafeFrameConfig: noopThis,
        setTagForChildDirectedTreatment: noopThis,
        setTargeting: noopThis,
        setVideoContent: noopThis,
        updateCorrelator: noopFunc
      };
      var _window = window,
          _window$googletag = _window.googletag,
          googletag = _window$googletag === void 0 ? {} : _window$googletag;
      var _googletag$cmd = googletag.cmd,
          cmd = _googletag$cmd === void 0 ? [] : _googletag$cmd;
      googletag.apiReady = true;
      googletag.cmd = [];

      googletag.cmd.push = function (a) {
        try {
          a(); // eslint-disable-next-line no-empty
        } catch (ex) {}

        return 1;
      };

      googletag.companionAds = function () {
        return companionAdsService;
      };

      googletag.content = function () {
        return contentService;
      };

      googletag.defineOutOfPageSlot = function () {
        return new Slot();
      };

      googletag.defineSlot = function () {
        return new Slot();
      };

      googletag.destroySlots = noopFunc;
      googletag.disablePublisherConsole = noopFunc;
      googletag.display = noopFunc;
      googletag.enableServices = noopFunc;
      googletag.getVersion = noopStr;

      googletag.pubads = function () {
        return pubAdsService;
      };

      googletag.pubadsReady = true;
      googletag.setAdIframeTitle = noopFunc;

      googletag.sizeMapping = function () {
        return new SizeMappingBuilder();
      };

      window.googletag = googletag;

      while (cmd.length !== 0) {
        googletag.cmd.push(cmd.shift());
      }

      hit(source);
    }
    GoogleTagServicesGpt.names = ['googletagservices-gpt', 'ubo-googletagservices_gpt.js', 'googletagservices_gpt.js'];
    GoogleTagServicesGpt.injections = [hit, noopFunc, noopThis, noopNull, noopArray, noopStr];

    /**
     * @redirect scorecardresearch-beacon
     *
     * @description
     * Mocks Scorecard Research API.
     *
     * Related UBO redirect resource:
     * https://github.com/gorhill/uBlock/blob/a94df7f3b27080ae2dcb3b914ace39c0c294d2f6/src/web_accessible_resources/scorecardresearch_beacon.js
     *
     * **Example**
     * ```
     * ||sb.scorecardresearch.com/beacon.js$script,redirect=scorecardresearch-beacon
     * ```
     */

    function ScoreCardResearchBeacon(source) {
      window.COMSCORE = {
        purge: function purge() {
          // eslint-disable-next-line no-underscore-dangle
          window._comscore = [];
        },
        beacon: function beacon() {}
      };
      hit(source);
    }
    ScoreCardResearchBeacon.names = ['scorecardresearch-beacon', 'ubo-scorecardresearch_beacon.js', 'scorecardresearch_beacon.js'];
    ScoreCardResearchBeacon.injections = [hit];

    /**
     * @redirect metrika-yandex-tag
     *
     * @description
     * Mocks Yandex Metrika API.
     * https://yandex.ru/support/metrica/objects/method-reference.html
     *
     * **Example**
     * ```
     * ||mc.yandex.ru/metrika/tag.js$script,redirect=metrika-yandex-tag
     * ```
     */

    function metrikaYandexTag(source) {
      var asyncCallbackFromOptions = function asyncCallbackFromOptions(param) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        var callback = options.callback;
        var ctx = options.ctx;

        if (typeof callback === 'function') {
          callback = ctx !== undefined ? callback.bind(ctx) : callback;
          setTimeout(function () {
            return callback();
          });
        }
      };

      var init = noopFunc;
      /**
       * https://yandex.ru/support/metrica/objects/addfileextension.html
       */

      var addFileExtension = noopFunc;
      /**
       * https://yandex.ru/support/metrica/objects/extlink.html
       */

      var extLink = asyncCallbackFromOptions;
      /**
       * https://yandex.ru/support/metrica/objects/file.html
       */

      var file = asyncCallbackFromOptions;
      /**
       * https://yandex.ru/support/metrica/objects/get-client-id.html
       * @param {Function} cb
       */

      var getClientID = function getClientID(cb) {
        setTimeout(cb(null));
      };
      /**
       * https://yandex.ru/support/metrica/objects/hit.html
       */


      var hitFunc = asyncCallbackFromOptions;
      /**
       * https://yandex.ru/support/metrica/objects/notbounce.html
       */

      var notBounce = asyncCallbackFromOptions;
      /**
       * https://yandex.ru/support/metrica/objects/params-method.html
       */

      var params = noopFunc;
      /**
       * https://yandex.ru/support/metrica/objects/reachgoal.html
       * @param {string} target
       * @param {Object} params
       * @param {Function} callback
       * @param {any} ctx
       */

      var reachGoal = function reachGoal(target, params, callback, ctx) {
        asyncCallbackFromOptions(null, {
          callback: callback,
          ctx: ctx
        });
      };
      /**
       * https://yandex.ru/support/metrica/objects/set-user-id.html
       */


      var setUserID = noopFunc;
      /**
       * https://yandex.ru/support/metrica/objects/user-params.html
       */

      var userParams = noopFunc;
      var api = {
        init: init,
        addFileExtension: addFileExtension,
        extLink: extLink,
        file: file,
        getClientID: getClientID,
        hit: hitFunc,
        notBounce: notBounce,
        params: params,
        reachGoal: reachGoal,
        setUserID: setUserID,
        userParams: userParams
      };

      function ym(id, funcName) {
        for (var _len = arguments.length, args = new Array(_len > 2 ? _len - 2 : 0), _key = 2; _key < _len; _key++) {
          args[_key - 2] = arguments[_key];
        }

        return api[funcName] && api[funcName].apply(api, args);
      }

      window.ym = ym;
      hit(source);
    }
    metrikaYandexTag.names = ['metrika-yandex-tag'];
    metrikaYandexTag.injections = [hit, noopFunc];

    /**
     * @redirect metrika-yandex-watch
     *
     * @description
     * Mocks the old Yandex Metrika API.
     * https://yandex.ru/support/metrica/objects/_method-reference.html
     *
     * **Example**
     * ```
     * ||mc.yandex.ru/metrika/watch.js$script,redirect=metrika-yandex-watch
     * ```
     */

    function metrikaYandexWatch(source) {
      var cbName = 'yandex_metrika_callbacks';
      /**
       * Gets callback and its context from options and call it in async way
       * @param {Object} options Yandex Metrika API options
       */

      var asyncCallbackFromOptions = function asyncCallbackFromOptions() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
        var callback = options.callback;
        var ctx = options.ctx;

        if (typeof callback === 'function') {
          callback = ctx !== undefined ? callback.bind(ctx) : callback;
          setTimeout(function () {
            return callback();
          });
        }
      };

      function Metrika() {} // constructor
      // Methods without options


      Metrika.prototype.addFileExtension = noopFunc;
      Metrika.prototype.getClientID = noopFunc;
      Metrika.prototype.setUserID = noopFunc;
      Metrika.prototype.userParams = noopFunc; // Methods with options
      // The order of arguments should be kept in according to API

      Metrika.prototype.extLink = function (url, options) {
        asyncCallbackFromOptions(options);
      };

      Metrika.prototype.file = function (url, options) {
        asyncCallbackFromOptions(options);
      };

      Metrika.prototype.hit = function (url, options) {
        asyncCallbackFromOptions(options);
      };

      Metrika.prototype.reachGoal = function (target, params, cb, ctx) {
        asyncCallbackFromOptions({
          callback: cb,
          ctx: ctx
        });
      };

      Metrika.prototype.notBounce = asyncCallbackFromOptions;

      if (window.Ya) {
        window.Ya.Metrika = Metrika;
      } else {
        window.Ya = {
          Metrika: Metrika
        };
      }

      if (window[cbName] && Array.isArray(window[cbName])) {
        window[cbName].forEach(function (func) {
          if (typeof func === 'function') {
            func();
          }
        });
      }

      hit(source);
    }
    metrikaYandexWatch.names = ['metrika-yandex-watch'];
    metrikaYandexWatch.injections = [hit, noopFunc];

    /**
     * @redirect amazon-apstag
     *
     * @description
     * Mocks Amazon's apstag.js
     *
     * Related UBO redirect resource:
     * https://github.com/gorhill/uBlock/blob/f842ab6d3c1cf0394f95d27092bf59627262da40/src/web_accessible_resources/amazon_apstag.js
     *
     * **Example**
     * ```
     * ||amazon-adsystem.com/aax2/apstag.js$script,redirect=amazon-apstag
     * ```
     */

    function AmazonApstag(source) {
      var apstagWrapper = {
        fetchBids: function fetchBids(a, b) {
          if (typeof b === 'function') {
            b([]);
          }
        },
        init: noopFunc,
        setDisplayBids: noopFunc,
        targetingKeys: noopFunc
      };
      window.apstag = apstagWrapper;
      hit(source);
    }
    AmazonApstag.names = ['amazon-apstag', 'ubo-amazon_apstag.js', 'amazon_apstag.js'];
    AmazonApstag.injections = [hit, noopFunc];

    var redirectsList = /*#__PURE__*/Object.freeze({
        __proto__: null,
        noeval: noeval,
        GoogleAnalytics: GoogleAnalytics,
        GoogleAnalyticsGa: GoogleAnalyticsGa,
        GoogleSyndicationAdsByGoogle: GoogleSyndicationAdsByGoogle,
        GoogleTagManagerGtm: GoogleTagManagerGtm,
        GoogleTagServicesGpt: GoogleTagServicesGpt,
        ScoreCardResearchBeacon: ScoreCardResearchBeacon,
        metrikaYandexTag: metrikaYandexTag,
        metrikaYandexWatch: metrikaYandexWatch,
        preventFab: preventFab,
        setPopadsDummy: setPopadsDummy,
        preventPopadsNet: preventPopadsNet,
        AmazonApstag: AmazonApstag
    });

    /**
     * Finds redirect resource by it's name
     * @param {string} name - redirect name
     */

    var getRedirectByName = function getRedirectByName(name) {
      var redirects = Object.keys(redirectsList).map(function (key) {
        return redirectsList[key];
      });
      return redirects.find(function (r) {
        return r.names && r.names.indexOf(name) > -1;
      });
    };
    /**
     * @typedef {Object} Source - redirect properties
     * @property {string} name redirect name
     * @property {Array<string>} args Arguments for redirect function
     * @property {'extension'|'test'} [engine] -
     * Defines the final form of redirect string presentation
     * @property {boolean} [verbose] flag to enable printing to console debug information
     */

    /**
     * Returns redirect code by param
     * @param {Source} source
     * @returns {string} redirect code
     */


    var getRedirectCode = function getRedirectCode(source) {
      var redirect = getRedirectByName(source.name);
      var result = attachDependencies(redirect);
      result = addCall(redirect, result); // redirect code for different sources is checked in tests
      // so it should be just a code without any source and props passed

      result = source.engine === 'test' ? wrapInNonameFunc(result) : passSourceAndProps(source, result);
      return result;
    };

    var redirectsCjs = {
      getCode: getRedirectCode,
      isAdgRedirectRule: validator.isAdgRedirectRule,
      isValidAdgRedirectRule: validator.isValidAdgRedirectRule,
      isAdgRedirectCompatibleWithUbo: validator.isAdgRedirectCompatibleWithUbo,
      isUboRedirectCompatibleWithAdg: validator.isUboRedirectCompatibleWithAdg,
      isAbpRedirectCompatibleWithAdg: validator.isAbpRedirectCompatibleWithAdg,
      convertUboRedirectToAdg: convertUboRedirectToAdg,
      convertAbpRedirectToAdg: convertAbpRedirectToAdg,
      convertRedirectToAdg: convertRedirectToAdg,
      convertAdgRedirectToUbo: convertAdgRedirectToUbo
    };

    /**
     * @typedef {Object} Source - scriptlet properties
     * @property {string} name Scriptlet name
     * @property {Array<string>} args Arguments for scriptlet function
     * @property {'extension'|'corelibs'|'test'} engine -
     * Defines the final form of scriptlet string presentation
     * @property {string} [version]
     * @property {boolean} [verbose] flag to enable printing to console debug information
     * @property {string} [ruleText] Source rule text is used for debugging purposes
     * @property {string} [domainName] domain name where scriptlet is applied; for debugging purposes
     */

    /**
     * Returns scriptlet code by param
     * @param {Source} source
     * @returns {string} scriptlet code
     */

    function getScriptletCode(source) {
      if (!validator.isValidScriptletName(source.name)) {
        return null;
      }

      var scriptlet = validator.getScriptletByName(source.name);
      var result = attachDependencies(scriptlet);
      result = addCall(scriptlet, result);
      result = source.engine === 'corelibs' || source.engine === 'test' ? wrapInNonameFunc(result) : passSourceAndProps(source, result);
      return result;
    }
    /**
     * Scriptlets variable
     *
     * @returns {Object} object with methods:
     * `invoke` method receives one argument with `Source` type
     * `validate` method receives one argument with `String` type
     */


    var scriptletsObject = function () {
      return {
        invoke: getScriptletCode,
        isValidScriptletName: validator.isValidScriptletName,
        isValidScriptletRule: isValidScriptletRule,
        isAdgScriptletRule: validator.isAdgScriptletRule,
        isUboScriptletRule: validator.isUboScriptletRule,
        isAbpSnippetRule: validator.isAbpSnippetRule,
        convertUboToAdg: convertUboScriptletToAdg,
        convertAbpToAdg: convertAbpSnippetToAdg,
        convertScriptletToAdg: convertScriptletToAdg,
        convertAdgToUbo: convertAdgScriptletToUbo,
        redirects: redirectsCjs
      };
    }();

    /**
     * Expose scriptlets to global
     */
    // eslint-disable-next-line no-undef

    scriptlets = scriptletsObject;

}());

/**
 * -------------------------------------------
 * |                                         |
 * |  If you want to add your own scriptlet  |
 * |  please put your code below             |
 * |                                         |
 * -------------------------------------------
 */
//# sourceMappingURL=scriptlets.js.map

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Global adguard object
 */
var adguard = (function () { // eslint-disable-line
    /**
     * This function allows cache property in object. Use with javascript getter.
     *
     * var Object = {
     *
     *      get someProperty(){
     *          return adguard.lazyGet(Object, 'someProperty', function() {
     *              return calculateSomeProperty();
     *          });
     *      }
     * }
     *
     * @param object Object
     * @param prop Original property name
     * @param calculateFunc Calculation function
     * @returns {*}
     */
    const lazyGet = function (object, prop, calculateFunc) {
        const cachedProp = `_${prop}`;
        if (cachedProp in object) {
            return object[cachedProp];
        }
        const value = calculateFunc.apply(object);
        object[cachedProp] = value;
        return value;
    };

    /**
     * Clear cached property
     * @param object Object
     * @param prop Original property name
     */
    const lazyGetClear = function (object, prop) {
        delete object[`_${prop}`];
    };

    function notImplemented() {
        return false;
    }

    const hitStatsModule = {
        addRuleHit: notImplemented,
        addDomainView: notImplemented,
        cleanup: notImplemented,
    };

    const filteringLogModule = {
        addHttpRequestEvent: notImplemented,
        clearEventsByTabId: notImplemented,
        isOpen: notImplemented,
    };

    const safebrowsingModule = {
        checkSafebrowsingFilter: notImplemented,
    };

    const syncModule = {
        settingsProvider: notImplemented(),
    };

    return {
        lazyGet,
        lazyGetClear,

        /**
         * Define dummy modules.
         * In case of simple adguard API, some modules aren't supported
         */
        hitStats: hitStatsModule,
        filteringLog: filteringLogModule,
        safebrowsing: safebrowsingModule,
        sync: syncModule,
    };
})();

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Extension global preferences.
 * (!) Firefox has it's own implementation
 */
adguard.prefs = (function (adguard) {
    var Prefs = {

        get mobile() {
            return adguard.lazyGet(Prefs, 'mobile', () => navigator.userAgent.indexOf('Android') >= 0);
        },

        platform: 'chromium',

        get browser() {
            return adguard.lazyGet(Prefs, 'browser', () => {
                let browser;
                let { userAgent } = navigator;
                userAgent = userAgent.toLowerCase();
                if (userAgent.indexOf('yabrowser') >= 0) {
                    browser = 'YaBrowser';
                } else if (userAgent.indexOf('edge') >= 0) {
                    browser = 'Edge';
                } else if (userAgent.indexOf('edg') >= 0) {
                    browser = 'EdgeChromium';
                } else if (userAgent.indexOf('opera') >= 0
                    || userAgent.indexOf('opr') >= 0) {
                    browser = 'Opera';
                } else if (userAgent.indexOf('firefox') >= 0) {
                    browser = 'Firefox';
                } else {
                    browser = 'Chrome';
                }
                return browser;
            });
        },

        get chromeVersion() {
            return adguard.lazyGet(Prefs, 'chromeVersion', () => {
                const match = /\sChrome\/(\d+)\./.exec(navigator.userAgent);
                return match === null ? null : parseInt(match[1]);
            });
        },

        get firefoxVersion() {
            return adguard.lazyGet(Prefs, 'firefoxVersion', () => {
                const match = /\sFirefox\/(\d+)\./.exec(navigator.userAgent);
                return match === null ? null : Number.parseInt(match[1], 10);
            });
        },

        /**
         * https://msdn.microsoft.com/ru-ru/library/hh869301(v=vs.85).aspx
         * @returns {*}
         */
        get edgeVersion() {
            return adguard.lazyGet(Prefs, 'edgeVersion', function () {
                if (this.browser === 'Edge') {
                    const { userAgent } = navigator;
                    const i = userAgent.indexOf('Edge/');
                    if (i < 0) {
                        return {
                            rev: 0,
                            build: 0,
                        };
                    }
                    const version = userAgent.substring(i + 'Edge/'.length);
                    const parts = version.split('.');
                    return {
                        rev: parseInt(parts[0]),
                        build: parseInt(parts[1]),
                    };
                }
            });
        },

        /**
         * Makes sense in case of FF add-on only
         */
        speedupStartup() {
            return false;
        },

        get ICONS() {
            return adguard.lazyGet(Prefs, 'ICONS', () => ({
                ICON_GREEN: {
                    '19': adguard.getURL('icons/green-19.png'),
                    '38': adguard.getURL('icons/green-38.png'),
                },
                ICON_GRAY: {
                    '19': adguard.getURL('icons/gray-19.png'),
                    '38': adguard.getURL('icons/gray-38.png'),
                },
            }));
        },

        // interval 60 seconds in Firefox is set so big due to excessive IO operations on every storage save
        // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1006
        get statsSaveInterval() {
            return this.browser === 'Firefox' ? 1000 * 60 : 1000;
        },
    };

    /**
     * Collect browser specific features here
     */
    Prefs.features = (function () {
        // Get the global extension object (browser for FF, chrome for Chromium)
        const browser = window.browser || window.chrome;

        const responseContentFilteringSupported = (typeof browser !== 'undefined'
            && typeof browser.webRequest !== 'undefined'
            && typeof browser.webRequest.filterResponseData !== 'undefined');

        const canUseInsertCSSAndExecuteScript = (
            // Blink engine based browsers
            (Prefs.browser === 'Chrome' || Prefs.browser === 'Opera' || Prefs.browser === 'YaBrowser' || Prefs.browser === 'EdgeChromium')
            // Support for tabs.insertCSS and tabs.executeScript on chrome
            // requires chrome version above or equal to 39, as per documentation: https://developers.chrome.com/extensions/tabs
            // But due to a bug, it requires version >= 50
            // https://bugs.chromium.org/p/chromium/issues/detail?id=63979
            && Prefs.chromeVersion >= 50
        ) || (
            Prefs.browser === 'Firefox' && (
                typeof browser !== 'undefined'
                && typeof browser.tabs !== 'undefined'
                && typeof browser.tabs.insertCSS !== 'undefined'
            )
        );
        // Edge browser does not support `runAt` in options of tabs.insertCSS
        // and tabs.executeScript

        return {
            responseContentFilteringSupported,
            canUseInsertCSSAndExecuteScript,
            hasBackgroundTab: typeof browser !== 'undefined', // Background requests have sense only in case of webext
        };
    })();

    return Prefs;
})(adguard);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Request types enumeration
 */
adguard.RequestTypes = {

    /**
     * Document that is loaded for a top-level frame
     */
    DOCUMENT: 'DOCUMENT',

    /**
     * Document that is loaded for an embedded frame (iframe)
     */
    SUBDOCUMENT: 'SUBDOCUMENT',

    SCRIPT: 'SCRIPT',
    STYLESHEET: 'STYLESHEET',
    OBJECT: 'OBJECT',
    IMAGE: 'IMAGE',
    XMLHTTPREQUEST: 'XMLHTTPREQUEST',
    MEDIA: 'MEDIA',
    FONT: 'FONT',
    WEBSOCKET: 'WEBSOCKET',
    WEBRTC: 'WEBRTC',
    OTHER: 'OTHER',
    CSP: 'CSP',
    COOKIE: 'COOKIE',
    PING: 'PING',
};

/**
 * Background tab id in browsers is defined as -1
 */
adguard.BACKGROUND_TAB_ID = -1;

/**
 * Main frame id is equal to 0
 */
adguard.MAIN_FRAME_ID = 0;

/**
 * Utilities namespace
 */
adguard.utils = (function () {
    return {
        strings: null, // StringUtils
        dates: null, // DateUtils
        collections: null, // CollectionUtils,
        concurrent: null, // ConcurrentUtils,
        channels: null, // EventChannels
        browser: null, // BrowserUtils
        filters: null, // FilterUtils,
        workaround: null, // WorkaroundUtils
        i18n: null, // I18nUtils
        StopWatch: null,
        Promise: null, // Deferred,
    };
})();

/**
 * Util class for work with strings
 */
(function (api) {
    if (!String.prototype.endsWith) {
        String.prototype.endsWith = function (suffix) { // jshint ignore:line
            const index = this.lastIndexOf(suffix);
            return index !== -1 && index === this.length - suffix.length;
        };
    }

    // noinspection UnnecessaryLocalVariableJS
    const StringUtils = {

        isEmpty(str) {
            return !str || str.trim().length === 0;
        },

        startWith(str, prefix) {
            return str && str.indexOf(prefix) === 0;
        },

        endsWith(str, postfix) {
            return str.endsWith(postfix);
        },

        substringAfter(str, separator) {
            if (!str) {
                return str;
            }
            const index = str.indexOf(separator);
            return index < 0 ? '' : str.substring(index + separator.length);
        },

        substringBefore(str, separator) {
            if (!str || !separator) {
                return str;
            }
            const index = str.indexOf(separator);
            return index < 0 ? str : str.substring(0, index);
        },

        contains(str, searchString) {
            return str && str.indexOf(searchString) >= 0;
        },

        containsIgnoreCase(str, searchString) {
            return str && searchString && str.toUpperCase().indexOf(searchString.toUpperCase()) >= 0;
        },

        replaceAll(str, find, replace) {
            if (!str) {
                return str;
            }
            return str.split(find).join(replace);
        },

        join(array, separator, startIndex, endIndex) {
            if (!array) {
                return null;
            }
            if (!startIndex) {
                startIndex = 0;
            }
            if (!endIndex) {
                endIndex = array.length;
            }
            if (startIndex >= endIndex) {
                return '';
            }
            const buf = [];
            for (let i = startIndex; i < endIndex; i++) {
                buf.push(array[i]);
            }
            return buf.join(separator);
        },

        /**
         * Get string before regexp first match
         * @param {string} str
         * @param {RegExp} rx
         */
        getBeforeRegExp(str, rx) {
            const index = str.search(rx);
            return str.substring(0, index);
        },

        /**
         * Look for any symbol from "chars" array starting at "start" index or from the start of the string
         *
         * @param str   String to search
         * @param chars Chars to search for
         * @param start Start index (optional, inclusive)
         * @return int Index of the element found or null
         */
        indexOfAny(str, chars, start) {
            start = start || 0;

            if (typeof str === 'string' && str.length <= start) {
                return -1;
            }

            for (let i = start; i < str.length; i++) {
                const c = str.charAt(i);
                if (chars.indexOf(c) > -1) {
                    return i;
                }
            }

            return -1;
        },

        /**
         * Splits string by a delimiter, ignoring escaped delimiters
         * @param str               String to split
         * @param delimiter         Delimiter
         * @param escapeCharacter   Escape character
         * @param preserveAllTokens If true - preserve empty entries.
         */
        splitByDelimiterWithEscapeCharacter(str, delimiter, escapeCharacter, preserveAllTokens) {
            const parts = [];

            if (adguard.utils.strings.isEmpty(str)) {
                return parts;
            }

            let sb = [];
            for (let i = 0; i < str.length; i++) {
                const c = str.charAt(i);

                if (c === delimiter) {
                    if (i === 0) { // jshint ignore:line
                        // Ignore
                    } else if (str.charAt(i - 1) === escapeCharacter) {
                        sb.splice(sb.length - 1, 1);
                        sb.push(c);
                    } else if (preserveAllTokens || sb.length > 0) {
                        const part = sb.join('');
                        parts.push(part);
                        sb = [];
                    }
                } else {
                    sb.push(c);
                }
            }

            if (preserveAllTokens || sb.length > 0) {
                parts.push(sb.join(''));
            }

            return parts;
        },

        /**
         * Serialize HTML element
         * @param element
         */
        elementToString(element) {
            const s = [];
            s.push('<');
            s.push(element.localName);
            const { attributes } = element;
            for (let i = 0; i < attributes.length; i++) {
                const attr = attributes[i];
                s.push(' ');
                s.push(attr.name);
                s.push('="');
                const value = attr.value === null ? '' : attr.value.replace(/"/g, '\\"');
                s.push(value);
                s.push('"');
            }
            s.push('>');
            return s.join('');
        },

        /**
         * Checks if the specified string starts with a substr at the specified index.
         * @param str - String to check
         * @param startIndex - Index to start checking from
         * @param substr - Substring to check
         * @return boolean true if it does start
         */
        startsAtIndexWith(str, startIndex, substr) {
            if (str.length - startIndex < substr.length) {
                return false;
            }

            for (let i = 0; i < substr.length; i += 1) {
                if (str.charAt(startIndex + i) !== substr.charAt(i)) {
                    return false;
                }
            }

            return true;
        },

        /**
         * Checks if str has unquoted substr
         * @param str
         * @param substr
         */
        hasUnquotedSubstring(str, substr) {
            const quotes = ['"', "'", '/'];

            const stack = [];
            for (let i = 0; i < str.length; i += 1) {
                const cursor = str[i];

                if (stack.length === 0) {
                    if (this.startsAtIndexWith(str, i, substr)) {
                        return true;
                    }
                }

                if (quotes.indexOf(cursor) >= 0
                    && (i === 0 || str[i - 1] !== '\\')) {
                    const last = stack.pop();
                    if (!last) {
                        stack.push(cursor);
                    } else if (last !== cursor) {
                        stack.push(last);
                        stack.push(cursor);
                    }
                }
            }

            return false;
        },
    };

    api.strings = StringUtils;
})(adguard.utils);

/**
 * Util class for dates
 */
(function (api) {
    const DateUtils = {

        isSameHour(a, b) {
            return (
                this.isSameDay(a, b)
                && a.getHours() === b.getHours()
            );
        },
        isSameDay(a, b) {
            return (
                this.isSameMonth(a, b)
                && a.getDate() === b.getDate()
            );
        },
        isSameMonth(a, b) {
            if (!a || !b) {
                return false;
            }

            return (
                a.getYear() === b.getYear()
                && a.getMonth() === b.getMonth()
            );
        },
        getDifferenceInHours(a, b) {
            return (a.getTime() - b.getTime()) / 1000 / 60 / 60;
        },
        getDifferenceInDays(a, b) {
            return this.getDifferenceInHours(a, b) / 24;
        },
        getDifferenceInMonths(a, b) {
            return this.getDifferenceInDays(a, b) / 30;
        },
    };

    api.dates = DateUtils;
})(adguard.utils);

/**
 * Util class for work with collections
 */
(function (api) {
    // noinspection UnnecessaryLocalVariableJS
    const CollectionUtils = {

        remove(collection, element) {
            if (!element || !collection) {
                return;
            }
            const index = collection.indexOf(element);
            if (index >= 0) {
                collection.splice(index, 1);
            }
        },

        removeAll(collection, element) {
            if (!element || !collection) {
                return;
            }
            for (let i = collection.length - 1; i >= 0; i--) {
                if (collection[i] == element) {
                    collection.splice(i, 1);
                }
            }
        },

        removeRule(collection, rule) {
            if (!rule || !collection) {
                return;
            }
            for (let i = collection.length - 1; i >= 0; i--) {
                if (rule.ruleText === collection[i].ruleText) {
                    collection.splice(i, 1);
                }
            }
        },

        removeDuplicates(arr) {
            if (!arr || arr.length == 1) {
                return arr;
            }
            return arr.filter((elem, pos) => arr.indexOf(elem) == pos);
        },

        getRulesText(collection) {
            const text = [];
            if (!collection) {
                return text;
            }
            for (let i = 0; i < collection.length; i++) {
                text.push(collection[i].ruleText);
            }
            return text;
        },

        /**
         * Find element in array by property
         * @param array
         * @param property
         * @param value
         * @returns {*}
         */
        find(array, property, value) {
            if (typeof array.find === 'function') {
                return array.find(a => a[property] === value);
            }
            for (let i = 0; i < array.length; i++) {
                const elem = array[i];
                if (elem[property] === value) {
                    return elem;
                }
            }
            return null;
        },

        /**
         * Checks if specified object is array
         * We don't use instanceof because it is too slow: http://jsperf.com/instanceof-performance/2
         * @param obj Object
         */
        isArray: Array.isArray || function (obj) {
            return `${obj}` === '[object Array]';
        },

        /**
         * Returns array elements of a, which is not included in b
         *
         * @param a
         * @param b
         */
        getArraySubtraction(a, b) {
            return a.filter(i => b.indexOf(i) < 0);
        },
    };

    api.collections = CollectionUtils;
})(adguard.utils);

/**
 * Util class for support timeout, retry operations, debounce
 */
(function (api) {
    // noinspection UnnecessaryLocalVariableJS
    const ConcurrentUtils = {

        runAsync(callback, context) {
            const params = Array.prototype.slice.call(arguments, 2);
            setTimeout(() => {
                callback.apply(context, params);
            }, 0);
        },

        retryUntil(predicate, main, details) {
            if (typeof details !== 'object') {
                details = {};
            }

            let now = 0;
            const next = details.next || 200;
            const until = details.until || 2000;

            var check = function () {
                if (predicate() === true || now >= until) {
                    main();
                    return;
                }
                now += next;
                setTimeout(check, next);
            };

            setTimeout(check, 1);
        },

        debounce(func, wait) {
            let timeout;
            return function () {
                const context = this; const
                    args = arguments;
                const later = function () {
                    timeout = null;
                    func.apply(context, args);
                };
                clearTimeout(timeout);
                timeout = setTimeout(later, wait);
            };
        },

        /**
         * Returns a new function that, when invoked, invokes `func` at most once per `wait` milliseconds.
         * https://github.com/component/throttle
         *
         * @param {Function} func Function to wrap.
         * @param {Number} wait Number of milliseconds that must elapse between `func` invocations.
         * @return {Function} A new function that wraps the `func` function passed in.
         */
        throttle(func, wait) {
            let ctx; let args; let rtn; let
                timeoutID; // caching
            let last = 0;

            function call() {
                timeoutID = 0;
                last = +new Date();
                rtn = func.apply(ctx, args);
                ctx = null;
                args = null;
            }

            return function throttled() {
                ctx = this;
                args = arguments;
                const delta = new Date() - last;
                if (!timeoutID) {
                    if (delta >= wait) {
                        call();
                    } else {
                        timeoutID = setTimeout(call, wait - delta);
                    }
                }
                return rtn;
            };
        },
    };

    api.concurrent = ConcurrentUtils;
})(adguard.utils);

/**
 * Util class for detect filter type. Includes various filter identifiers
 */
(function (api) {
    const AntiBannerFiltersId = {
        USER_FILTER_ID: 0,
        RUSSIAN_FILTER_ID: 1,
        ENGLISH_FILTER_ID: 2,
        TRACKING_FILTER_ID: 3,
        SOCIAL_FILTER_ID: 4,
        SEARCH_AND_SELF_PROMO_FILTER_ID: 10,
        WHITE_LIST_FILTER_ID: 100,
        EASY_PRIVACY: 118,
        FANBOY_ANNOYANCES: 122,
        FANBOY_SOCIAL: 123,
        FANBOY_ENHANCED: 215,
        MOBILE_ADS_FILTER_ID: 11,
    };

    const FilterUtils = {

        isUserFilterRule(rule) {
            return rule.filterId == AntiBannerFiltersId.USER_FILTER_ID;
        },

        isWhiteListFilterRule(rule) {
            return rule.filterId == AntiBannerFiltersId.WHITE_LIST_FILTER_ID;
        },
    };

    // Make accessible only constants without functions. They will be passed to content-page
    FilterUtils.ids = AntiBannerFiltersId;

    // Copy filter ids to api
    for (const key in AntiBannerFiltersId) {
        if (AntiBannerFiltersId.hasOwnProperty(key)) {
            FilterUtils[key] = AntiBannerFiltersId[key];
        }
    }

    api.filters = FilterUtils;
})(adguard.utils);

/**
 * Simple time measurement utils
 */
(function (api) {
    const StopWatch = function (name) {
        this.name = name;
    };

    StopWatch.prototype = {

        start() {
            this.startTime = Date.now();
        },

        stop() {
            this.stopTime = Date.now();
        },

        print() {
            const elapsed = this.stopTime - this.startTime;
            console.log(`${this.name}[elapsed: ${elapsed} ms]`);
        },
    };

    api.StopWatch = StopWatch;
})(adguard.utils);

/**
 * Simple publish-subscribe implementation
 */
(function (api) {
    const EventChannels = (function () {
        'use strict';

        const EventChannel = function () {
            let listeners = null;
            let listenerCallback = null;

            const addListener = function (callback) {
                if (typeof callback !== 'function') {
                    throw new Error('Illegal callback');
                }
                if (listeners !== null) {
                    listeners.push(callback);
                    return;
                }
                if (listenerCallback !== null) {
                    listeners = [];
                    listeners.push(listenerCallback);
                    listeners.push(callback);
                    listenerCallback = null;
                } else {
                    listenerCallback = callback;
                }
            };

            const removeListener = function (callback) {
                if (listenerCallback !== null) {
                    listenerCallback = null;
                } else {
                    const index = listeners.indexOf(callback);
                    if (index >= 0) {
                        listeners.splice(index, 1);
                    }
                }
            };

            const notify = function () {
                if (listenerCallback !== null) {
                    return listenerCallback.apply(listenerCallback, arguments);
                }
                if (listeners !== null) {
                    for (let i = 0; i < listeners.length; i++) {
                        const listener = listeners[i];
                        listener.apply(listener, arguments);
                    }
                }
            };

            const notifyInReverseOrder = function () {
                if (listenerCallback !== null) {
                    return listenerCallback.apply(listenerCallback, arguments);
                }
                if (listeners !== null) {
                    for (let i = listeners.length - 1; i >= 0; i--) {
                        const listener = listeners[i];
                        listener.apply(listener, arguments);
                    }
                }
            };

            return {
                addListener,
                removeListener,
                notify,
                notifyInReverseOrder,
            };
        };

        const namedChannels = Object.create(null);

        const newChannel = function () {
            return new EventChannel();
        };

        const newNamedChannel = function (name) {
            const channel = newChannel();
            namedChannels[name] = channel;
            return channel;
        };

        const getNamedChannel = function (name) {
            return namedChannels[name];
        };

        return {
            newChannel,
            newNamedChannel,
            getNamedChannel,
        };
    })();

    api.channels = EventChannels;
})(adguard.utils);

/**
 * Promises wrapper
 */
(function (api, global) {
    'use strict';

    const defer = global.Deferred;
    const deferAll = function (arr) {
        return global.Deferred.when.apply(global.Deferred, arr);
    };

    const Promise = function () {
        const deferred = defer();
        let promise;
        if (typeof deferred.promise === 'function') {
            promise = deferred.promise();
        } else {
            promise = deferred.promise;
        }

        const resolve = function (arg) {
            deferred.resolve(arg);
        };

        const reject = function (arg) {
            deferred.reject(arg);
        };

        const then = function (onSuccess, onReject) {
            promise.then(onSuccess, onReject);
        };

        return {
            promise,
            resolve,
            reject,
            then,
        };
    };

    Promise.all = function (promises) {
        const defers = [];
        for (let i = 0; i < promises.length; i++) {
            defers.push(promises[i].promise);
        }
        return deferAll(defers);
    };

    api.Promise = Promise;
})(adguard.utils, window);

/**
 * We collect here all workarounds and ugly hacks:)
 */
(function (api) {
    // noinspection UnnecessaryLocalVariableJS
    const WorkaroundUtils = {

        /**
         * Converts blocked counter to the badge text.
         * Workaround for FF - make 99 max.
         *
         * @param blocked Blocked requests count
         */
        getBlockedCountText(blocked) {
            let blockedText = blocked == '0' ? '' : blocked;
            if (blocked - 0 > 99) {
                blockedText = '\u221E';
            }

            return blockedText;
        },
    };

    api.workaround = WorkaroundUtils;
})(adguard.utils);

/**
 * Simple i18n utils
 */
(function (api) {
    function isArrayElement(array, elem) {
        return array.indexOf(elem) >= 0;
    }

    function isObjectKey(object, key) {
        return key in object;
    }

    api.i18n = {

        /**
         * Tries to find locale in the given collection of locales
         * @param locales Collection of locales (array or object)
         * @param locale Locale (e.g. en, en_GB, pt_BR)
         * @returns matched locale from the locales collection or null
         */
        normalize(locales, locale) {
            if (!locale) {
                return null;
            }

            // Transform Language-Country => Language_Country
            locale = locale.replace('-', '_');

            let search;

            if (api.collections.isArray(locales)) {
                search = isArrayElement;
            } else {
                search = isObjectKey;
            }

            if (search(locales, locale)) {
                return locale;
            }

            // Try to search by the language
            const parts = locale.split('_');
            const language = parts[0];
            if (search(locales, language)) {
                return language;
            }

            return null;
        },
    };
})(adguard.utils);

/**
 * Unload handler. When extension is unload then 'fireUnload' is invoked.
 * You can add own handler with method 'when'
 * @type {{when, fireUnload}}
 */
adguard.unload = (function (adguard) {
    'use strict';

    const unloadChannel = adguard.utils.channels.newChannel();

    const when = function (callback) {
        if (typeof callback !== 'function') {
            return;
        }
        unloadChannel.addListener(() => {
            try {
                callback();
            } catch (ex) {
                console.error('Error while invoke unload method');
                console.error(ex);
            }
        });
    };

    const fireUnload = function (reason) {
        console.info(`Unload is fired: ${reason}`);
        unloadChannel.notifyInReverseOrder(reason);
    };

    return {
        when,
        fireUnload,
    };
})(adguard);

/**
 * Utility class for saving and retrieving some item by key;
 * It's bounded with some capacity.
 * Details are stored in some ring buffer. For each key corresponding item are retrieved in LIFO order.
 */
adguard.utils.RingBuffer = function (size) { // jshint ignore:line
    if (typeof Map === 'undefined') {
        throw new Error('Unable to create RingBuffer');
    }

    /**
     * itemKeyToIndex: Map (key => indexes)
     * indexes = Array of [index];
     * index = position of item in ringBuffer
     */
    /* global Map */
    let itemKeyToIndex = new Map();
    let itemWritePointer = 0; // Current write position

    /**
     * ringBuffer: Array [0:item][1:item]...[size-1:item]
     */
    const ringBuffer = new Array(size);

    let i = ringBuffer.length;
    while (i--) {
        ringBuffer[i] = { processedKey: null }; // 'if not null' means this item hasn't been processed yet.
    }

    /**
     * Put new value to buffer
     * 1. Associates item with next index from ringBuffer.
     * 2. If index has been already in use and item hasn't been processed yet, then removes it from indexes array in itemKeyToIndex
     * 3. Push this index to indexes array in itemKeyToIndex at first position
     * @param key Key
     * @param value Object
     */
    const put = function (key, value) {
        const index = itemWritePointer;
        itemWritePointer = (index + 1) % size;

        let item = ringBuffer[index];
        let indexes;

        // Cleanup unprocessed item
        if (item.processedKey !== null) {
            indexes = itemKeyToIndex.get(item.processedKey);
            if (indexes.length === 1) {
                // It's last item with this key
                itemKeyToIndex.delete(item.processedKey);
            } else {
                const pos = indexes.indexOf(index);
                if (pos >= 0) {
                    indexes.splice(pos, 1);
                }
            }
            ringBuffer[index] = item = null;
        }
        indexes = itemKeyToIndex.get(key);
        if (indexes === undefined) {
            // It's first item with this key
            itemKeyToIndex.set(key, [index]);
        } else {
            // Push item index at first position
            indexes.unshift(index);
        }

        ringBuffer[index] = value;
        value.processedKey = key;
    };

    /**
     * Finds item by key
     * 1. Get indexes from itemKeyToIndex by key.
     * 2. Gets first index from indexes, then gets item from ringBuffer by this index
     * @param key Key for searching
     */
    const pop = function (key) {
        const indexes = itemKeyToIndex.get(key);
        if (indexes === undefined) {
            return null;
        }
        const index = indexes.shift();
        if (indexes.length === 0) {
            itemKeyToIndex.delete(key);
        }
        const item = ringBuffer[index];
        // Mark as processed
        item.processedKey = null;
        return item;
    };

    const clear = function () {
        itemKeyToIndex = new Map();
        itemWritePointer = 0;
        let i = ringBuffer.length;
        while (i--) {
            ringBuffer[i] = { processedKey: null };
        }
    };

    return {
        put,
        pop,
        clear,
    };
};

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/* eslint-disable no-console */

/**
 * Simple logger with log levels
 */
adguard.console = (function () {
    // Redefine if you need it
    const CURRENT_LEVEL = 'INFO';

    const LEVELS = {
        ERROR: 1,
        WARN: 2,
        INFO: 3,
        DEBUG: 4,
    };

    /**
     * Pretty-print javascript error
     */
    const errorToString = function (error) {
        return `${error.toString()}\nStack trace:\n${error.stack}`;
    };

    const getLocalTimeString = (date) => {
        const ONE_MINUTE_MS = 60 * 1000;
        const timeZoneOffsetMs = date.getTimezoneOffset() * ONE_MINUTE_MS;
        const localTime = new Date(date - timeZoneOffsetMs);
        return localTime.toISOString().replace('Z', '');
    };

    /**
     * Prints log message
     */
    const print = function (level, method, args) {
        // check log level
        if (LEVELS[CURRENT_LEVEL] < LEVELS[level]) {
            return;
        }
        if (!args || args.length === 0 || !args[0]) {
            return;
        }

        const str = `${args[0]}`;
        args = Array.prototype.slice.call(args, 1);
        let formatted = str.replace(/{(\d+)}/g, (match, number) => {
            if (typeof args[number] !== 'undefined') {
                let value = args[number];
                if (value instanceof Error) {
                    value = errorToString(value);
                } else if (value && value.message) {
                    value = value.message;
                } else if (typeof value === 'object') {
                    value = JSON.stringify(value);
                }
                return value;
            }

            return match;
        });

        formatted = `${getLocalTimeString(new Date())}: ${formatted}`;
        console[method](formatted);
    };

    /**
     * Expose public API
     */
    return {
        debug(...args) {
            print('DEBUG', 'log', args);
        },

        info(...args) {
            print('INFO', 'info', args);
        },

        warn(...args) {
            print('WARN', 'info', args);
        },

        error(...args) {
            print('ERROR', 'error', args);
        },
    };
})();

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (api) {
  // %START_RESERVED_DOMAINS% and %END_RESERVED_DOMAINS% serve as markers for the possibility to update RESERVED_DOMAINS object
  // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1010
  var publicSuffixes =
    //%START_RESERVED_DOMAINS%
{
  "0.bg": 1,
  "001www.com": 1,
  "0e.vc": 1,
  "1.bg": 1,
  "12hp.at": 1,
  "12hp.ch": 1,
  "12hp.de": 1,
  "1337.pictures": 1,
  "16-b.it": 1,
  "1kapp.com": 1,
  "2.bg": 1,
  "2000.hu": 1,
  "2038.io": 1,
  "2ix.at": 1,
  "2ix.ch": 1,
  "2ix.de": 1,
  "3.bg": 1,
  "32-b.it": 1,
  "3utilities.com": 1,
  "4.bg": 1,
  "4lima.at": 1,
  "4lima.ch": 1,
  "4lima.de": 1,
  "4u.com": 1,
  "5.bg": 1,
  "6.bg": 1,
  "611.to": 1,
  "64-b.it": 1,
  "7.bg": 1,
  "8.bg": 1,
  "9.bg": 1,
  "9guacu.br": 1,
  "a.bg": 1,
  "a.prod.fastly.net": 1,
  "a.run.app": 1,
  "a.se": 1,
  "a.ssl.fastly.net": 1,
  "aa.no": 1,
  "aaa": 1,
  "aaa.pro": 1,
  "aarborte.no": 1,
  "aarp": 1,
  "ab.ca": 1,
  "abarth": 1,
  "abashiri.hokkaido.jp": 1,
  "abb": 1,
  "abbott": 1,
  "abbvie": 1,
  "abc": 1,
  "abc.br": 1,
  "abeno.osaka.jp": 1,
  "abiko.chiba.jp": 1,
  "abira.hokkaido.jp": 1,
  "abkhazia.su": 1,
  "able": 1,
  "abo.pa": 1,
  "abogado": 1,
  "abr.it": 1,
  "abruzzo.it": 1,
  "abu.yamaguchi.jp": 1,
  "abudhabi": 1,
  "ac": 1,
  "ac.ae": 1,
  "ac.at": 1,
  "ac.be": 1,
  "ac.ci": 1,
  "ac.cn": 1,
  "ac.cr": 1,
  "ac.cy": 1,
  "ac.fj": 1,
  "ac.gn": 1,
  "ac.gov.br": 1,
  "ac.id": 1,
  "ac.il": 1,
  "ac.im": 1,
  "ac.in": 1,
  "ac.ir": 1,
  "ac.jp": 1,
  "ac.ke": 1,
  "ac.kr": 1,
  "ac.leg.br": 1,
  "ac.lk": 1,
  "ac.ls": 1,
  "ac.ma": 1,
  "ac.me": 1,
  "ac.mu": 1,
  "ac.mw": 1,
  "ac.mz": 1,
  "ac.ni": 1,
  "ac.nz": 1,
  "ac.pa": 1,
  "ac.pr": 1,
  "ac.rs": 1,
  "ac.ru": 1,
  "ac.rw": 1,
  "ac.se": 1,
  "ac.sz": 1,
  "ac.th": 1,
  "ac.tj": 1,
  "ac.tz": 1,
  "ac.ug": 1,
  "ac.uk": 1,
  "ac.vn": 1,
  "ac.za": 1,
  "ac.zm": 1,
  "ac.zw": 1,
  "aca.pro": 1,
  "academia.bo": 1,
  "academy": 1,
  "academy.museum": 1,
  "accenture": 1,
  "accesscam.org": 1,
  "accident-investigation.aero": 1,
  "accident-prevention.aero": 1,
  "accountant": 1,
  "accountants": 1,
  "acct.pro": 1,
  "achi.nagano.jp": 1,
  "aco": 1,
  "act.au": 1,
  "act.edu.au": 1,
  "actor": 1,
  "ad": 1,
  "ad.jp": 1,
  "adac": 1,
  "adachi.tokyo.jp": 1,
  "adm.br": 1,
  "adobeaemcloud.com": 1,
  "adobeaemcloud.net": 1,
  "ads": 1,
  "adult": 1,
  "adult.ht": 1,
  "adv.br": 1,
  "adv.mz": 1,
  "adygeya.ru": 1,
  "adygeya.su": 1,
  "ae": 1,
  "ae.org": 1,
  "aeg": 1,
  "aejrie.no": 1,
  "aero": 1,
  "aero.mv": 1,
  "aero.tt": 1,
  "aerobatic.aero": 1,
  "aeroclub.aero": 1,
  "aerodrome.aero": 1,
  "aeroport.fr": 1,
  "aetna": 1,
  "af": 1,
  "afamilycompany": 1,
  "afjord.no": 1,
  "afl": 1,
  "africa": 1,
  "africa.com": 1,
  "ag": 1,
  "ag.it": 1,
  "aga.niigata.jp": 1,
  "agakhan": 1,
  "agano.niigata.jp": 1,
  "agdenes.no": 1,
  "agematsu.nagano.jp": 1,
  "agency": 1,
  "agents.aero": 1,
  "agr.br": 1,
  "agrar.hu": 1,
  "agric.za": 1,
  "agriculture.museum": 1,
  "agrigento.it": 1,
  "agrinet.tn": 1,
  "agro.bo": 1,
  "agro.pl": 1,
  "aguni.okinawa.jp": 1,
  "ah.cn": 1,
  "ah.no": 1,
  "ai": 1,
  "aibetsu.hokkaido.jp": 1,
  "aichi.jp": 1,
  "aid.pl": 1,
  "aig": 1,
  "aikawa.kanagawa.jp": 1,
  "ainan.ehime.jp": 1,
  "aioi.hyogo.jp": 1,
  "aip.ee": 1,
  "air-surveillance.aero": 1,
  "air-traffic-control.aero": 1,
  "air.museum": 1,
  "airbus": 1,
  "aircraft.aero": 1,
  "airforce": 1,
  "airguard.museum": 1,
  "airline.aero": 1,
  "airport.aero": 1,
  "airtel": 1,
  "airtraffic.aero": 1,
  "aisai.aichi.jp": 1,
  "aisho.shiga.jp": 1,
  "aizubange.fukushima.jp": 1,
  "aizumi.tokushima.jp": 1,
  "aizumisato.fukushima.jp": 1,
  "aizuwakamatsu.fukushima.jp": 1,
  "aju.br": 1,
  "ak.us": 1,
  "akabira.hokkaido.jp": 1,
  "akagi.shimane.jp": 1,
  "akaiwa.okayama.jp": 1,
  "akashi.hyogo.jp": 1,
  "akdn": 1,
  "aki.kochi.jp": 1,
  "akiruno.tokyo.jp": 1,
  "akishima.tokyo.jp": 1,
  "akita.akita.jp": 1,
  "akita.jp": 1,
  "akkeshi.hokkaido.jp": 1,
  "aknoluokta.no": 1,
  "ako.hyogo.jp": 1,
  "akrehamn.no": 1,
  "aktyubinsk.su": 1,
  "akune.kagoshima.jp": 1,
  "al": 1,
  "al.eu.org": 1,
  "al.gov.br": 1,
  "al.it": 1,
  "al.leg.br": 1,
  "al.no": 1,
  "al.us": 1,
  "alabama.museum": 1,
  "alaheadju.no": 1,
  "aland.fi": 1,
  "alaska.museum": 1,
  "alessandria.it": 1,
  "alesund.no": 1,
  "alfaromeo": 1,
  "algard.no": 1,
  "alibaba": 1,
  "alipay": 1,
  "allfinanz": 1,
  "allstate": 1,
  "ally": 1,
  "alpha-myqnapcloud.com": 1,
  "alpha.bounty-full.com": 1,
  "alsace": 1,
  "alstahaug.no": 1,
  "alstom": 1,
  "alt.za": 1,
  "alta.no": 1,
  "altervista.org": 1,
  "alto-adige.it": 1,
  "altoadige.it": 1,
  "alvdal.no": 1,
  "alwaysdata.net": 1,
  "am": 1,
  "am.br": 1,
  "am.gov.br": 1,
  "am.leg.br": 1,
  "ama.aichi.jp": 1,
  "ama.shimane.jp": 1,
  "amagasaki.hyogo.jp": 1,
  "amakusa.kumamoto.jp": 1,
  "amami.kagoshima.jp": 1,
  "amazon": 1,
  "amber.museum": 1,
  "ambulance.aero": 1,
  "ambulance.museum": 1,
  "american.museum": 1,
  "americana.museum": 1,
  "americanantiques.museum": 1,
  "americanart.museum": 1,
  "americanexpress": 1,
  "americanfamily": 1,
  "amex": 1,
  "amfam": 1,
  "ami.ibaraki.jp": 1,
  "amica": 1,
  "amli.no": 1,
  "amot.no": 1,
  "amsterdam": 1,
  "amsterdam.museum": 1,
  "amsw.nl": 1,
  "amusement.aero": 1,
  "an.it": 1,
  "analytics": 1,
  "anamizu.ishikawa.jp": 1,
  "anan.nagano.jp": 1,
  "anan.tokushima.jp": 1,
  "anani.br": 1,
  "ancona.it": 1,
  "and.mom": 1,
  "and.museum": 1,
  "andasuolo.no": 1,
  "andebu.no": 1,
  "ando.nara.jp": 1,
  "andoy.no": 1,
  "andria-barletta-trani.it": 1,
  "andria-trani-barletta.it": 1,
  "andriabarlettatrani.it": 1,
  "andriatranibarletta.it": 1,
  "android": 1,
  "anjo.aichi.jp": 1,
  "ann-arbor.mi.us": 1,
  "annaka.gunma.jp": 1,
  "annefrank.museum": 1,
  "anpachi.gifu.jp": 1,
  "anquan": 1,
  "anthro.museum": 1,
  "anthropology.museum": 1,
  "antiques.museum": 1,
  "anz": 1,
  "ao": 1,
  "ao.it": 1,
  "aogaki.hyogo.jp": 1,
  "aogashima.tokyo.jp": 1,
  "aoki.nagano.jp": 1,
  "aol": 1,
  "aomori.aomori.jp": 1,
  "aomori.jp": 1,
  "aosta-valley.it": 1,
  "aosta.it": 1,
  "aostavalley.it": 1,
  "aoste.it": 1,
  "ap-northeast-1.elasticbeanstalk.com": 1,
  "ap-northeast-2.elasticbeanstalk.com": 1,
  "ap-northeast-3.elasticbeanstalk.com": 1,
  "ap-south-1.elasticbeanstalk.com": 1,
  "ap-southeast-1.elasticbeanstalk.com": 1,
  "ap-southeast-2.elasticbeanstalk.com": 1,
  "ap.gov.br": 1,
  "ap.gov.pl": 1,
  "ap.it": 1,
  "ap.leg.br": 1,
  "aparecida.br": 1,
  "apartments": 1,
  "api.stdlib.com": 1,
  "apigee.io": 1,
  "app": 1,
  "app.banzaicloud.io": 1,
  "app.br": 1,
  "app.gp": 1,
  "app.lmpm.com": 1,
  "app.os.fedoraproject.org": 1,
  "app.os.stg.fedoraproject.org": 1,
  "app.render.com": 1,
  "appchizi.com": 1,
  "apple": 1,
  "applicationcloud.io": 1,
  "applinzi.com": 1,
  "apps.fbsbx.com": 1,
  "apps.lair.io": 1,
  "appspot.com": 1,
  "aprendemas.cl": 1,
  "aq": 1,
  "aq.it": 1,
  "aquarelle": 1,
  "aquarium.museum": 1,
  "aquila.it": 1,
  "ar": 1,
  "ar.com": 1,
  "ar.it": 1,
  "ar.us": 1,
  "arab": 1,
  "arai.shizuoka.jp": 1,
  "arakawa.saitama.jp": 1,
  "arakawa.tokyo.jp": 1,
  "aramco": 1,
  "arao.kumamoto.jp": 1,
  "arboretum.museum": 1,
  "archaeological.museum": 1,
  "archaeology.museum": 1,
  "archi": 1,
  "architecture.museum": 1,
  "ardal.no": 1,
  "aremark.no": 1,
  "arendal.no": 1,
  "arezzo.it": 1,
  "ariake.saga.jp": 1,
  "arida.wakayama.jp": 1,
  "aridagawa.wakayama.jp": 1,
  "arita.saga.jp": 1,
  "arkhangelsk.su": 1,
  "armenia.su": 1,
  "army": 1,
  "arna.no": 1,
  "arpa": 1,
  "arq.br": 1,
  "art": 1,
  "art.br": 1,
  "art.do": 1,
  "art.dz": 1,
  "art.ht": 1,
  "art.museum": 1,
  "art.pl": 1,
  "art.sn": 1,
  "artanddesign.museum": 1,
  "artcenter.museum": 1,
  "artdeco.museum": 1,
  "arte": 1,
  "arte.bo": 1,
  "arteducation.museum": 1,
  "artgallery.museum": 1,
  "arts.co": 1,
  "arts.museum": 1,
  "arts.nf": 1,
  "arts.ro": 1,
  "arts.ve": 1,
  "artsandcrafts.museum": 1,
  "arvo.network": 1,
  "as": 1,
  "as.us": 1,
  "asago.hyogo.jp": 1,
  "asahi.chiba.jp": 1,
  "asahi.ibaraki.jp": 1,
  "asahi.mie.jp": 1,
  "asahi.nagano.jp": 1,
  "asahi.toyama.jp": 1,
  "asahi.yamagata.jp": 1,
  "asahikawa.hokkaido.jp": 1,
  "asaka.saitama.jp": 1,
  "asakawa.fukushima.jp": 1,
  "asakuchi.okayama.jp": 1,
  "asaminami.hiroshima.jp": 1,
  "ascoli-piceno.it": 1,
  "ascolipiceno.it": 1,
  "asda": 1,
  "aseral.no": 1,
  "ashgabad.su": 1,
  "ashibetsu.hokkaido.jp": 1,
  "ashikaga.tochigi.jp": 1,
  "ashiya.fukuoka.jp": 1,
  "ashiya.hyogo.jp": 1,
  "ashoro.hokkaido.jp": 1,
  "asia": 1,
  "asker.no": 1,
  "askim.no": 1,
  "askoy.no": 1,
  "askvoll.no": 1,
  "asmatart.museum": 1,
  "asn.au": 1,
  "asn.lv": 1,
  "asnes.no": 1,
  "aso.kumamoto.jp": 1,
  "ass.km": 1,
  "assabu.hokkaido.jp": 1,
  "assassination.museum": 1,
  "assisi.museum": 1,
  "assn.lk": 1,
  "asso.bj": 1,
  "asso.ci": 1,
  "asso.dz": 1,
  "asso.eu.org": 1,
  "asso.fr": 1,
  "asso.gp": 1,
  "asso.ht": 1,
  "asso.km": 1,
  "asso.mc": 1,
  "asso.nc": 1,
  "asso.re": 1,
  "associates": 1,
  "association.aero": 1,
  "association.museum": 1,
  "asti.it": 1,
  "astronomy.museum": 1,
  "asuke.aichi.jp": 1,
  "at": 1,
  "at-band-camp.net": 1,
  "at.eu.org": 1,
  "at.it": 1,
  "at.md": 1,
  "at.vg": 1,
  "atami.shizuoka.jp": 1,
  "ath.cx": 1,
  "athleta": 1,
  "atlanta.museum": 1,
  "atm.pl": 1,
  "ato.br": 1,
  "atsugi.kanagawa.jp": 1,
  "atsuma.hokkaido.jp": 1,
  "attorney": 1,
  "au": 1,
  "au.eu.org": 1,
  "auction": 1,
  "audi": 1,
  "audible": 1,
  "audio": 1,
  "audnedaln.no": 1,
  "augustow.pl": 1,
  "aukra.no": 1,
  "aure.no": 1,
  "aurland.no": 1,
  "aurskog-holand.no": 1,
  "auspost": 1,
  "austevoll.no": 1,
  "austin.museum": 1,
  "australia.museum": 1,
  "austrheim.no": 1,
  "author": 1,
  "author.aero": 1,
  "auto": 1,
  "auto.pl": 1,
  "automotive.museum": 1,
  "autos": 1,
  "av.it": 1,
  "av.tr": 1,
  "avellino.it": 1,
  "averoy.no": 1,
  "avianca": 1,
  "aviation.museum": 1,
  "avocat.fr": 1,
  "avocat.pro": 1,
  "avoues.fr": 1,
  "aw": 1,
  "awaji.hyogo.jp": 1,
  "aws": 1,
  "awsmppl.com": 1,
  "ax": 1,
  "axa": 1,
  "axis.museum": 1,
  "aya.miyazaki.jp": 1,
  "ayabe.kyoto.jp": 1,
  "ayagawa.kagawa.jp": 1,
  "ayase.kanagawa.jp": 1,
  "az": 1,
  "az.us": 1,
  "azerbaijan.su": 1,
  "azimuth.network": 1,
  "azumino.nagano.jp": 1,
  "azure": 1,
  "azure-mobile.net": 1,
  "azurewebsites.net": 1,
  "b-data.io": 1,
  "b.bg": 1,
  "b.br": 1,
  "b.se": 1,
  "b.ssl.fastly.net": 1,
  "ba": 1,
  "ba.gov.br": 1,
  "ba.it": 1,
  "ba.leg.br": 1,
  "babia-gora.pl": 1,
  "baby": 1,
  "backplaneapp.io": 1,
  "badaddja.no": 1,
  "badajoz.museum": 1,
  "baghdad.museum": 1,
  "bahcavuotna.no": 1,
  "bahccavuotna.no": 1,
  "bahn.museum": 1,
  "baidar.no": 1,
  "baidu": 1,
  "bajddar.no": 1,
  "balashov.su": 1,
  "balat.no": 1,
  "bale.museum": 1,
  "balena-devices.com": 1,
  "balestrand.no": 1,
  "ballangen.no": 1,
  "ballooning.aero": 1,
  "balsan-sudtirol.it": 1,
  "balsan-suedtirol.it": 1,
  "balsan.it": 1,
  "balsfjord.no": 1,
  "baltimore.museum": 1,
  "bamble.no": 1,
  "banamex": 1,
  "bananarepublic": 1,
  "band": 1,
  "bandai.fukushima.jp": 1,
  "bando.ibaraki.jp": 1,
  "bank": 1,
  "bar": 1,
  "bar.pro": 1,
  "bar0.net": 1,
  "bar1.net": 1,
  "bar2.net": 1,
  "barcelona": 1,
  "barcelona.museum": 1,
  "barclaycard": 1,
  "barclays": 1,
  "bardu.no": 1,
  "barefoot": 1,
  "bargains": 1,
  "bari.it": 1,
  "barletta-trani-andria.it": 1,
  "barlettatraniandria.it": 1,
  "barreau.bj": 1,
  "barrel-of-knowledge.info": 1,
  "barrell-of-knowledge.info": 1,
  "barsy.bg": 1,
  "barsy.ca": 1,
  "barsy.club": 1,
  "barsy.co.uk": 1,
  "barsy.de": 1,
  "barsy.eu": 1,
  "barsy.in": 1,
  "barsy.info": 1,
  "barsy.io": 1,
  "barsy.me": 1,
  "barsy.menu": 1,
  "barsy.mobi": 1,
  "barsy.net": 1,
  "barsy.online": 1,
  "barsy.org": 1,
  "barsy.pro": 1,
  "barsy.pub": 1,
  "barsy.shop": 1,
  "barsy.site": 1,
  "barsy.support": 1,
  "barsy.uk": 1,
  "barsycenter.com": 1,
  "barsyonline.co.uk": 1,
  "barsyonline.com": 1,
  "barueri.br": 1,
  "barum.no": 1,
  "bas.it": 1,
  "baseball": 1,
  "baseball.museum": 1,
  "basel.museum": 1,
  "bashkiria.ru": 1,
  "bashkiria.su": 1,
  "basicserver.io": 1,
  "basilicata.it": 1,
  "basketball": 1,
  "baths.museum": 1,
  "bato.tochigi.jp": 1,
  "batsfjord.no": 1,
  "bauern.museum": 1,
  "bauhaus": 1,
  "bayern": 1,
  "bb": 1,
  "bbc": 1,
  "bbs.tr": 1,
  "bbt": 1,
  "bbva": 1,
  "bc.ca": 1,
  "bc.platform.sh": 1,
  "bcg": 1,
  "bci.dnstrace.pro": 1,
  "bcn": 1,
  "bd.se": 1,
  "be": 1,
  "be.ax": 1,
  "be.eu.org": 1,
  "be.gy": 1,
  "bearalvahki.no": 1,
  "beardu.no": 1,
  "beats": 1,
  "beauty": 1,
  "beauxarts.museum": 1,
  "bedzin.pl": 1,
  "beeldengeluid.museum": 1,
  "beep.pl": 1,
  "beer": 1,
  "beiarn.no": 1,
  "bel.tr": 1,
  "belau.pw": 1,
  "belem.br": 1,
  "bellevue.museum": 1,
  "belluno.it": 1,
  "benevento.it": 1,
  "bentley": 1,
  "beppu.oita.jp": 1,
  "berg.no": 1,
  "bergamo.it": 1,
  "bergbau.museum": 1,
  "bergen.no": 1,
  "berkeley.museum": 1,
  "berlevag.no": 1,
  "berlin": 1,
  "berlin.museum": 1,
  "bern.museum": 1,
  "beskidy.pl": 1,
  "best": 1,
  "bestbuy": 1,
  "bet": 1,
  "beta.bounty-full.com": 1,
  "betainabox.com": 1,
  "better-than.tv": 1,
  "bf": 1,
  "bg": 1,
  "bg.eu.org": 1,
  "bg.it": 1,
  "bh": 1,
  "bharti": 1,
  "bhz.br": 1,
  "bi": 1,
  "bi.it": 1,
  "bialowieza.pl": 1,
  "bialystok.pl": 1,
  "bib.br": 1,
  "bibai.hokkaido.jp": 1,
  "bible": 1,
  "bible.museum": 1,
  "bid": 1,
  "biei.hokkaido.jp": 1,
  "bielawa.pl": 1,
  "biella.it": 1,
  "bieszczady.pl": 1,
  "bievat.no": 1,
  "bifuka.hokkaido.jp": 1,
  "bihoro.hokkaido.jp": 1,
  "bike": 1,
  "bilbao.museum": 1,
  "bill.museum": 1,
  "bindal.no": 1,
  "bing": 1,
  "bingo": 1,
  "bio": 1,
  "bio.br": 1,
  "bir.ru": 1,
  "biratori.hokkaido.jp": 1,
  "birdart.museum": 1,
  "birkenes.no": 1,
  "birthplace.museum": 1,
  "bitbridge.net": 1,
  "biz": 1,
  "biz.at": 1,
  "biz.az": 1,
  "biz.bb": 1,
  "biz.cy": 1,
  "biz.dk": 1,
  "biz.et": 1,
  "biz.fj": 1,
  "biz.gl": 1,
  "biz.id": 1,
  "biz.ki": 1,
  "biz.ls": 1,
  "biz.mv": 1,
  "biz.mw": 1,
  "biz.ni": 1,
  "biz.nr": 1,
  "biz.pk": 1,
  "biz.pl": 1,
  "biz.pr": 1,
  "biz.ss": 1,
  "biz.tj": 1,
  "biz.tr": 1,
  "biz.tt": 1,
  "biz.ua": 1,
  "biz.vn": 1,
  "biz.zm": 1,
  "bizen.okayama.jp": 1,
  "bj": 1,
  "bj.cn": 1,
  "bjarkoy.no": 1,
  "bjerkreim.no": 1,
  "bjugn.no": 1,
  "bl.it": 1,
  "black": 1,
  "blackbaudcdn.net": 1,
  "blackfriday": 1,
  "blockbuster": 1,
  "blog": 1,
  "blog.bo": 1,
  "blog.br": 1,
  "blog.gt": 1,
  "blog.kg": 1,
  "blog.vu": 1,
  "blogdns.com": 1,
  "blogdns.net": 1,
  "blogdns.org": 1,
  "blogsite.org": 1,
  "blogsite.xyz": 1,
  "blogspot.ae": 1,
  "blogspot.al": 1,
  "blogspot.am": 1,
  "blogspot.ba": 1,
  "blogspot.be": 1,
  "blogspot.bg": 1,
  "blogspot.bj": 1,
  "blogspot.ca": 1,
  "blogspot.cf": 1,
  "blogspot.ch": 1,
  "blogspot.cl": 1,
  "blogspot.co.at": 1,
  "blogspot.co.id": 1,
  "blogspot.co.il": 1,
  "blogspot.co.ke": 1,
  "blogspot.co.nz": 1,
  "blogspot.co.uk": 1,
  "blogspot.co.za": 1,
  "blogspot.com": 1,
  "blogspot.com.ar": 1,
  "blogspot.com.au": 1,
  "blogspot.com.br": 1,
  "blogspot.com.by": 1,
  "blogspot.com.co": 1,
  "blogspot.com.cy": 1,
  "blogspot.com.ee": 1,
  "blogspot.com.eg": 1,
  "blogspot.com.es": 1,
  "blogspot.com.mt": 1,
  "blogspot.com.ng": 1,
  "blogspot.com.tr": 1,
  "blogspot.com.uy": 1,
  "blogspot.cv": 1,
  "blogspot.cz": 1,
  "blogspot.de": 1,
  "blogspot.dk": 1,
  "blogspot.fi": 1,
  "blogspot.fr": 1,
  "blogspot.gr": 1,
  "blogspot.hk": 1,
  "blogspot.hr": 1,
  "blogspot.hu": 1,
  "blogspot.ie": 1,
  "blogspot.in": 1,
  "blogspot.is": 1,
  "blogspot.it": 1,
  "blogspot.jp": 1,
  "blogspot.kr": 1,
  "blogspot.li": 1,
  "blogspot.lt": 1,
  "blogspot.lu": 1,
  "blogspot.md": 1,
  "blogspot.mk": 1,
  "blogspot.mr": 1,
  "blogspot.mx": 1,
  "blogspot.my": 1,
  "blogspot.nl": 1,
  "blogspot.no": 1,
  "blogspot.pe": 1,
  "blogspot.pt": 1,
  "blogspot.qa": 1,
  "blogspot.re": 1,
  "blogspot.ro": 1,
  "blogspot.rs": 1,
  "blogspot.ru": 1,
  "blogspot.se": 1,
  "blogspot.sg": 1,
  "blogspot.si": 1,
  "blogspot.sk": 1,
  "blogspot.sn": 1,
  "blogspot.td": 1,
  "blogspot.tw": 1,
  "blogspot.ug": 1,
  "blogspot.vn": 1,
  "blogsyte.com": 1,
  "bloomberg": 1,
  "bloxcms.com": 1,
  "blue": 1,
  "bm": 1,
  "bmd.br": 1,
  "bmoattachments.org": 1,
  "bms": 1,
  "bmw": 1,
  "bn": 1,
  "bn.it": 1,
  "bnpparibas": 1,
  "bnr.la": 1,
  "bo": 1,
  "bo.it": 1,
  "bo.nordland.no": 1,
  "bo.telemark.no": 1,
  "boats": 1,
  "boavista.br": 1,
  "bodo.no": 1,
  "boehringer": 1,
  "bofa": 1,
  "bokn.no": 1,
  "boldlygoingnowhere.org": 1,
  "boleslawiec.pl": 1,
  "bolivia.bo": 1,
  "bologna.it": 1,
  "bolt.hu": 1,
  "bolzano-altoadige.it": 1,
  "bolzano.it": 1,
  "bom": 1,
  "bomlo.no": 1,
  "bond": 1,
  "bonn.museum": 1,
  "boo": 1,
  "book": 1,
  "booking": 1,
  "boomla.net": 1,
  "bosch": 1,
  "bostik": 1,
  "boston": 1,
  "boston.museum": 1,
  "bot": 1,
  "botanical.museum": 1,
  "botanicalgarden.museum": 1,
  "botanicgarden.museum": 1,
  "botany.museum": 1,
  "bounceme.net": 1,
  "bounty-full.com": 1,
  "boutique": 1,
  "box": 1,
  "boxfuse.io": 1,
  "bozen-sudtirol.it": 1,
  "bozen-suedtirol.it": 1,
  "bozen.it": 1,
  "bpl.biz": 1,
  "bplaced.com": 1,
  "bplaced.de": 1,
  "bplaced.net": 1,
  "br": 1,
  "br.com": 1,
  "br.it": 1,
  "bradesco": 1,
  "brand.se": 1,
  "brandywinevalley.museum": 1,
  "brasil.museum": 1,
  "brasilia.me": 1,
  "bremanger.no": 1,
  "brescia.it": 1,
  "bridgestone": 1,
  "brindisi.it": 1,
  "bristol.museum": 1,
  "british.museum": 1,
  "britishcolumbia.museum": 1,
  "broadcast.museum": 1,
  "broadway": 1,
  "broke-it.net": 1,
  "broker": 1,
  "broker.aero": 1,
  "bronnoy.no": 1,
  "bronnoysund.no": 1,
  "brother": 1,
  "browsersafetymark.io": 1,
  "brumunddal.no": 1,
  "brunel.museum": 1,
  "brussel.museum": 1,
  "brussels": 1,
  "brussels.museum": 1,
  "bruxelles.museum": 1,
  "bryansk.su": 1,
  "bryne.no": 1,
  "bs": 1,
  "bs.it": 1,
  "bsb.br": 1,
  "bss.design": 1,
  "bt": 1,
  "bt.it": 1,
  "bu.no": 1,
  "budapest": 1,
  "budejju.no": 1,
  "bugatti": 1,
  "build": 1,
  "builders": 1,
  "building.museum": 1,
  "builtwithdark.com": 1,
  "bukhara.su": 1,
  "bulsan-sudtirol.it": 1,
  "bulsan-suedtirol.it": 1,
  "bulsan.it": 1,
  "bungoono.oita.jp": 1,
  "bungotakada.oita.jp": 1,
  "bunkyo.tokyo.jp": 1,
  "burghof.museum": 1,
  "bus.museum": 1,
  "busan.kr": 1,
  "bushey.museum": 1,
  "business": 1,
  "buy": 1,
  "buyshouses.net": 1,
  "buzen.fukuoka.jp": 1,
  "buzz": 1,
  "bv": 1,
  "bw": 1,
  "by": 1,
  "bydgoszcz.pl": 1,
  "byen.site": 1,
  "bygland.no": 1,
  "bykle.no": 1,
  "bytom.pl": 1,
  "bz": 1,
  "bz.it": 1,
  "bzh": 1,
  "c.bg": 1,
  "c.cdn77.org": 1,
  "c.la": 1,
  "c.se": 1,
  "c66.me": 1,
  "ca": 1,
  "ca-central-1.elasticbeanstalk.com": 1,
  "ca.eu.org": 1,
  "ca.it": 1,
  "ca.na": 1,
  "ca.us": 1,
  "caa.aero": 1,
  "caa.li": 1,
  "cab": 1,
  "cable-modem.org": 1,
  "cadaques.museum": 1,
  "cafe": 1,
  "cagliari.it": 1,
  "cahcesuolo.no": 1,
  "cal": 1,
  "cal.it": 1,
  "calabria.it": 1,
  "california.museum": 1,
  "call": 1,
  "caltanissetta.it": 1,
  "calvinklein": 1,
  "cam": 1,
  "cam.it": 1,
  "cambridge.museum": 1,
  "camdvr.org": 1,
  "camera": 1,
  "camp": 1,
  "campania.it": 1,
  "campidano-medio.it": 1,
  "campidanomedio.it": 1,
  "campinagrande.br": 1,
  "campinas.br": 1,
  "campobasso.it": 1,
  "can.museum": 1,
  "canada.museum": 1,
  "cancerresearch": 1,
  "canon": 1,
  "capebreton.museum": 1,
  "capetown": 1,
  "capital": 1,
  "capitalone": 1,
  "car": 1,
  "caravan": 1,
  "carbonia-iglesias.it": 1,
  "carboniaiglesias.it": 1,
  "cards": 1,
  "care": 1,
  "career": 1,
  "careers": 1,
  "cargo.aero": 1,
  "carrara-massa.it": 1,
  "carraramassa.it": 1,
  "carrd.co": 1,
  "carrier.museum": 1,
  "cars": 1,
  "cartoonart.museum": 1,
  "casa": 1,
  "casacam.net": 1,
  "casadelamoneda.museum": 1,
  "case": 1,
  "caseih": 1,
  "caserta.it": 1,
  "cash": 1,
  "casino": 1,
  "casino.hu": 1,
  "castle.museum": 1,
  "castres.museum": 1,
  "cat": 1,
  "cat.ax": 1,
  "catania.it": 1,
  "catanzaro.it": 1,
  "catering": 1,
  "catering.aero": 1,
  "catholic": 1,
  "catholic.edu.au": 1,
  "caxias.br": 1,
  "cb.it": 1,
  "cba": 1,
  "cbg.ru": 1,
  "cbn": 1,
  "cbre": 1,
  "cbs": 1,
  "cc": 1,
  "cc.ak.us": 1,
  "cc.al.us": 1,
  "cc.ar.us": 1,
  "cc.as.us": 1,
  "cc.az.us": 1,
  "cc.ca.us": 1,
  "cc.co.us": 1,
  "cc.ct.us": 1,
  "cc.dc.us": 1,
  "cc.de.us": 1,
  "cc.fl.us": 1,
  "cc.ga.us": 1,
  "cc.gu.us": 1,
  "cc.hi.us": 1,
  "cc.hn": 1,
  "cc.ia.us": 1,
  "cc.id.us": 1,
  "cc.il.us": 1,
  "cc.in.us": 1,
  "cc.ks.us": 1,
  "cc.ky.us": 1,
  "cc.la.us": 1,
  "cc.ma.us": 1,
  "cc.md.us": 1,
  "cc.me.us": 1,
  "cc.mi.us": 1,
  "cc.mn.us": 1,
  "cc.mo.us": 1,
  "cc.ms.us": 1,
  "cc.mt.us": 1,
  "cc.na": 1,
  "cc.nc.us": 1,
  "cc.nd.us": 1,
  "cc.ne.us": 1,
  "cc.nh.us": 1,
  "cc.nj.us": 1,
  "cc.nm.us": 1,
  "cc.nv.us": 1,
  "cc.ny.us": 1,
  "cc.oh.us": 1,
  "cc.ok.us": 1,
  "cc.or.us": 1,
  "cc.pa.us": 1,
  "cc.pr.us": 1,
  "cc.ri.us": 1,
  "cc.sc.us": 1,
  "cc.sd.us": 1,
  "cc.tn.us": 1,
  "cc.tx.us": 1,
  "cc.ua": 1,
  "cc.ut.us": 1,
  "cc.va.us": 1,
  "cc.vi.us": 1,
  "cc.vt.us": 1,
  "cc.wa.us": 1,
  "cc.wi.us": 1,
  "cc.wv.us": 1,
  "cc.wy.us": 1,
  "cci.fr": 1,
  "cd": 1,
  "cd.eu.org": 1,
  "cdn77-ssl.net": 1,
  "ce.gov.br": 1,
  "ce.it": 1,
  "ce.leg.br": 1,
  "ceb": 1,
  "cechire.com": 1,
  "celtic.museum": 1,
  "center": 1,
  "center.museum": 1,
  "ceo": 1,
  "cern": 1,
  "certification.aero": 1,
  "certmgr.org": 1,
  "cesena-forli.it": 1,
  "cesenaforli.it": 1,
  "cf": 1,
  "cfa": 1,
  "cfd": 1,
  "cg": 1,
  "ch": 1,
  "ch.eu.org": 1,
  "ch.it": 1,
  "ch.tc": 1,
  "chambagri.fr": 1,
  "championship.aero": 1,
  "chanel": 1,
  "channel": 1,
  "channelsdvr.net": 1,
  "charity": 1,
  "charter.aero": 1,
  "chase": 1,
  "chat": 1,
  "chattanooga.museum": 1,
  "cheap": 1,
  "cheltenham.museum": 1,
  "cherkassy.ua": 1,
  "cherkasy.ua": 1,
  "chernigov.ua": 1,
  "chernihiv.ua": 1,
  "chernivtsi.ua": 1,
  "chernovtsy.ua": 1,
  "chesapeakebay.museum": 1,
  "chiba.jp": 1,
  "chicago.museum": 1,
  "chichibu.saitama.jp": 1,
  "chieti.it": 1,
  "chigasaki.kanagawa.jp": 1,
  "chihayaakasaka.osaka.jp": 1,
  "chijiwa.nagasaki.jp": 1,
  "chikugo.fukuoka.jp": 1,
  "chikuho.fukuoka.jp": 1,
  "chikuhoku.nagano.jp": 1,
  "chikujo.fukuoka.jp": 1,
  "chikuma.nagano.jp": 1,
  "chikusei.ibaraki.jp": 1,
  "chikushino.fukuoka.jp": 1,
  "chikuzen.fukuoka.jp": 1,
  "children.museum": 1,
  "childrens.museum": 1,
  "childrensgarden.museum": 1,
  "chimkent.su": 1,
  "chino.nagano.jp": 1,
  "chintai": 1,
  "chippubetsu.hokkaido.jp": 1,
  "chiropractic.museum": 1,
  "chirurgiens-dentistes-en-france.fr": 1,
  "chirurgiens-dentistes.fr": 1,
  "chiryu.aichi.jp": 1,
  "chita.aichi.jp": 1,
  "chitose.hokkaido.jp": 1,
  "chiyoda.gunma.jp": 1,
  "chiyoda.tokyo.jp": 1,
  "chizu.tottori.jp": 1,
  "chocolate.museum": 1,
  "chofu.tokyo.jp": 1,
  "chonan.chiba.jp": 1,
  "chosei.chiba.jp": 1,
  "choshi.chiba.jp": 1,
  "choyo.kumamoto.jp": 1,
  "christiansburg.museum": 1,
  "christmas": 1,
  "chrome": 1,
  "chtr.k12.ma.us": 1,
  "chungbuk.kr": 1,
  "chungnam.kr": 1,
  "chuo.chiba.jp": 1,
  "chuo.fukuoka.jp": 1,
  "chuo.osaka.jp": 1,
  "chuo.tokyo.jp": 1,
  "chuo.yamanashi.jp": 1,
  "church": 1,
  "ci": 1,
  "ci.it": 1,
  "ciencia.bo": 1,
  "cieszyn.pl": 1,
  "cim.br": 1,
  "cincinnati.museum": 1,
  "cinema.museum": 1,
  "cipriani": 1,
  "circle": 1,
  "circus.museum": 1,
  "cisco": 1,
  "ciscofreak.com": 1,
  "cistron.nl": 1,
  "citadel": 1,
  "citi": 1,
  "citic": 1,
  "city": 1,
  "city.hu": 1,
  "cityeats": 1,
  "civilaviation.aero": 1,
  "civilisation.museum": 1,
  "civilization.museum": 1,
  "civilwar.museum": 1,
  "ck.ua": 1,
  "cl": 1,
  "cl.it": 1,
  "claims": 1,
  "clan.rip": 1,
  "cleaning": 1,
  "cleverapps.io": 1,
  "clic2000.net": 1,
  "click": 1,
  "clinic": 1,
  "clinique": 1,
  "clinton.museum": 1,
  "clock.museum": 1,
  "clothing": 1,
  "cloud": 1,
  "cloud.fedoraproject.org": 1,
  "cloud.goog": 1,
  "cloud.metacentrum.cz": 1,
  "cloud66.ws": 1,
  "cloud66.zone": 1,
  "cloudaccess.host": 1,
  "cloudaccess.net": 1,
  "cloudapp.net": 1,
  "cloudapps.digital": 1,
  "cloudcontrolapp.com": 1,
  "cloudcontrolled.com": 1,
  "cloudeity.net": 1,
  "cloudera.site": 1,
  "cloudfront.net": 1,
  "cloudfunctions.net": 1,
  "cloudjiffy.net": 1,
  "cloudns.asia": 1,
  "cloudns.biz": 1,
  "cloudns.cc": 1,
  "cloudns.club": 1,
  "cloudns.eu": 1,
  "cloudns.in": 1,
  "cloudns.info": 1,
  "cloudns.org": 1,
  "cloudns.pro": 1,
  "cloudns.pw": 1,
  "cloudns.us": 1,
  "cloudycluster.net": 1,
  "club": 1,
  "club.aero": 1,
  "club.tw": 1,
  "clubmed": 1,
  "cm": 1,
  "cn": 1,
  "cn-north-1.eb.amazonaws.com.cn": 1,
  "cn-northwest-1.eb.amazonaws.com.cn": 1,
  "cn.com": 1,
  "cn.eu.org": 1,
  "cn.it": 1,
  "cn.ua": 1,
  "cn.vu": 1,
  "cng.br": 1,
  "cnpy.gdn": 1,
  "cnt.br": 1,
  "co": 1,
  "co.ae": 1,
  "co.ag": 1,
  "co.am": 1,
  "co.ao": 1,
  "co.at": 1,
  "co.bb": 1,
  "co.bi": 1,
  "co.bn": 1,
  "co.business": 1,
  "co.bw": 1,
  "co.ca": 1,
  "co.ci": 1,
  "co.cl": 1,
  "co.cm": 1,
  "co.com": 1,
  "co.cr": 1,
  "co.cz": 1,
  "co.dk": 1,
  "co.education": 1,
  "co.events": 1,
  "co.financial": 1,
  "co.gg": 1,
  "co.gl": 1,
  "co.gy": 1,
  "co.hu": 1,
  "co.id": 1,
  "co.il": 1,
  "co.im": 1,
  "co.in": 1,
  "co.ir": 1,
  "co.it": 1,
  "co.je": 1,
  "co.jp": 1,
  "co.ke": 1,
  "co.kr": 1,
  "co.krd": 1,
  "co.lc": 1,
  "co.ls": 1,
  "co.ma": 1,
  "co.me": 1,
  "co.mg": 1,
  "co.mu": 1,
  "co.mw": 1,
  "co.mz": 1,
  "co.na": 1,
  "co.network": 1,
  "co.ni": 1,
  "co.nl": 1,
  "co.no": 1,
  "co.nz": 1,
  "co.om": 1,
  "co.pl": 1,
  "co.place": 1,
  "co.pn": 1,
  "co.pw": 1,
  "co.rs": 1,
  "co.rw": 1,
  "co.st": 1,
  "co.sz": 1,
  "co.technology": 1,
  "co.th": 1,
  "co.tj": 1,
  "co.tm": 1,
  "co.tt": 1,
  "co.tz": 1,
  "co.ua": 1,
  "co.ug": 1,
  "co.uk": 1,
  "co.us": 1,
  "co.uz": 1,
  "co.ve": 1,
  "co.vi": 1,
  "co.za": 1,
  "co.zm": 1,
  "co.zw": 1,
  "coach": 1,
  "coal.museum": 1,
  "coastaldefence.museum": 1,
  "codes": 1,
  "codespot.com": 1,
  "cody.museum": 1,
  "coffee": 1,
  "cog.mi.us": 1,
  "col.ng": 1,
  "coldwar.museum": 1,
  "collection.museum": 1,
  "college": 1,
  "collegefan.org": 1,
  "cologne": 1,
  "colonialwilliamsburg.museum": 1,
  "coloradoplateau.museum": 1,
  "columbia.museum": 1,
  "columbus.museum": 1,
  "com": 1,
  "com.ac": 1,
  "com.af": 1,
  "com.ag": 1,
  "com.ai": 1,
  "com.al": 1,
  "com.am": 1,
  "com.ar": 1,
  "com.au": 1,
  "com.aw": 1,
  "com.az": 1,
  "com.ba": 1,
  "com.bb": 1,
  "com.bh": 1,
  "com.bi": 1,
  "com.bm": 1,
  "com.bn": 1,
  "com.bo": 1,
  "com.br": 1,
  "com.bs": 1,
  "com.bt": 1,
  "com.by": 1,
  "com.bz": 1,
  "com.ci": 1,
  "com.cm": 1,
  "com.cn": 1,
  "com.co": 1,
  "com.cu": 1,
  "com.cw": 1,
  "com.cy": 1,
  "com.de": 1,
  "com.dm": 1,
  "com.do": 1,
  "com.dz": 1,
  "com.ec": 1,
  "com.ee": 1,
  "com.eg": 1,
  "com.es": 1,
  "com.et": 1,
  "com.fj": 1,
  "com.fr": 1,
  "com.ge": 1,
  "com.gh": 1,
  "com.gi": 1,
  "com.gl": 1,
  "com.gn": 1,
  "com.gp": 1,
  "com.gr": 1,
  "com.gt": 1,
  "com.gu": 1,
  "com.gy": 1,
  "com.hk": 1,
  "com.hn": 1,
  "com.hr": 1,
  "com.ht": 1,
  "com.im": 1,
  "com.io": 1,
  "com.iq": 1,
  "com.is": 1,
  "com.jo": 1,
  "com.kg": 1,
  "com.ki": 1,
  "com.km": 1,
  "com.kp": 1,
  "com.kw": 1,
  "com.ky": 1,
  "com.kz": 1,
  "com.la": 1,
  "com.lb": 1,
  "com.lc": 1,
  "com.lk": 1,
  "com.lr": 1,
  "com.lv": 1,
  "com.ly": 1,
  "com.mg": 1,
  "com.mk": 1,
  "com.ml": 1,
  "com.mo": 1,
  "com.ms": 1,
  "com.mt": 1,
  "com.mu": 1,
  "com.mv": 1,
  "com.mw": 1,
  "com.mx": 1,
  "com.my": 1,
  "com.na": 1,
  "com.nf": 1,
  "com.ng": 1,
  "com.ni": 1,
  "com.nr": 1,
  "com.om": 1,
  "com.pa": 1,
  "com.pe": 1,
  "com.pf": 1,
  "com.ph": 1,
  "com.pk": 1,
  "com.pl": 1,
  "com.pr": 1,
  "com.ps": 1,
  "com.pt": 1,
  "com.py": 1,
  "com.qa": 1,
  "com.re": 1,
  "com.ro": 1,
  "com.ru": 1,
  "com.sa": 1,
  "com.sb": 1,
  "com.sc": 1,
  "com.sd": 1,
  "com.se": 1,
  "com.sg": 1,
  "com.sh": 1,
  "com.sl": 1,
  "com.sn": 1,
  "com.so": 1,
  "com.ss": 1,
  "com.st": 1,
  "com.sv": 1,
  "com.sy": 1,
  "com.tj": 1,
  "com.tm": 1,
  "com.tn": 1,
  "com.to": 1,
  "com.tr": 1,
  "com.tt": 1,
  "com.tw": 1,
  "com.ua": 1,
  "com.ug": 1,
  "com.uy": 1,
  "com.uz": 1,
  "com.vc": 1,
  "com.ve": 1,
  "com.vi": 1,
  "com.vn": 1,
  "com.vu": 1,
  "com.ws": 1,
  "com.zm": 1,
  "comcast": 1,
  "commbank": 1,
  "commune.am": 1,
  "communication.museum": 1,
  "communications.museum": 1,
  "community": 1,
  "community-pro.de": 1,
  "community-pro.net": 1,
  "community.museum": 1,
  "como.it": 1,
  "company": 1,
  "compare": 1,
  "computer": 1,
  "computer.museum": 1,
  "computerhistory.museum": 1,
  "comsec": 1,
  "condos": 1,
  "conf.au": 1,
  "conf.lv": 1,
  "conf.se": 1,
  "conference.aero": 1,
  "conn.uk": 1,
  "construction": 1,
  "consulado.st": 1,
  "consultant.aero": 1,
  "consulting": 1,
  "consulting.aero": 1,
  "contact": 1,
  "contagem.br": 1,
  "contemporary.museum": 1,
  "contemporaryart.museum": 1,
  "contractors": 1,
  "control.aero": 1,
  "convent.museum": 1,
  "cooking": 1,
  "cookingchannel": 1,
  "cool": 1,
  "coop": 1,
  "coop.br": 1,
  "coop.ht": 1,
  "coop.km": 1,
  "coop.mv": 1,
  "coop.mw": 1,
  "coop.py": 1,
  "coop.rw": 1,
  "coop.tt": 1,
  "cooperativa.bo": 1,
  "copenhagen.museum": 1,
  "copro.uk": 1,
  "corporation.museum": 1,
  "corsica": 1,
  "corvette.museum": 1,
  "cosenza.it": 1,
  "costume.museum": 1,
  "couchpotatofries.org": 1,
  "couk.me": 1,
  "council.aero": 1,
  "country": 1,
  "countryestate.museum": 1,
  "county.museum": 1,
  "coupon": 1,
  "coupons": 1,
  "courses": 1,
  "coz.br": 1,
  "cpa": 1,
  "cpa.pro": 1,
  "cq.cn": 1,
  "cr": 1,
  "cr.it": 1,
  "cr.ua": 1,
  "crafting.xyz": 1,
  "crafts.museum": 1,
  "cranbrook.museum": 1,
  "crd.co": 1,
  "creation.museum": 1,
  "credit": 1,
  "creditcard": 1,
  "creditunion": 1,
  "cremona.it": 1,
  "crew.aero": 1,
  "cri.br": 1,
  "cri.nz": 1,
  "cricket": 1,
  "crimea.ua": 1,
  "crotone.it": 1,
  "crown": 1,
  "crs": 1,
  "cruise": 1,
  "cruises": 1,
  "cs.it": 1,
  "csc": 1,
  "csx.cc": 1,
  "ct.it": 1,
  "ct.us": 1,
  "cu": 1,
  "cuiaba.br": 1,
  "cuisinella": 1,
  "cultural.museum": 1,
  "culturalcenter.museum": 1,
  "culture.museum": 1,
  "cuneo.it": 1,
  "cupcake.is": 1,
  "curitiba.br": 1,
  "curv.dev": 1,
  "cust.dev.thingdust.io": 1,
  "cust.disrec.thingdust.io": 1,
  "cust.prod.thingdust.io": 1,
  "cust.retrosnub.co.uk": 1,
  "cust.testing.thingdust.io": 1,
  "custom.metacentrum.cz": 1,
  "customer.enonic.io": 1,
  "customer.mythic-beasts.com": 1,
  "customer.speedpartner.de": 1,
  "cv": 1,
  "cv.ua": 1,
  "cw": 1,
  "cx": 1,
  "cy": 1,
  "cy.eu.org": 1,
  "cya.gg": 1,
  "cyber.museum": 1,
  "cymru": 1,
  "cymru.museum": 1,
  "cyon.link": 1,
  "cyon.site": 1,
  "cyou": 1,
  "cz": 1,
  "cz.eu.org": 1,
  "cz.it": 1,
  "czeladz.pl": 1,
  "czest.pl": 1,
  "d.bg": 1,
  "d.gv.vc": 1,
  "d.se": 1,
  "dabur": 1,
  "dad": 1,
  "daegu.kr": 1,
  "daejeon.kr": 1,
  "daemon.panel.gg": 1,
  "dagestan.ru": 1,
  "dagestan.su": 1,
  "daigo.ibaraki.jp": 1,
  "daisen.akita.jp": 1,
  "daito.osaka.jp": 1,
  "daiwa.hiroshima.jp": 1,
  "dali.museum": 1,
  "dallas.museum": 1,
  "damnserver.com": 1,
  "dance": 1,
  "daplie.me": 1,
  "data": 1,
  "database.museum": 1,
  "date": 1,
  "date.fukushima.jp": 1,
  "date.hokkaido.jp": 1,
  "dating": 1,
  "datsun": 1,
  "dattolocal.com": 1,
  "dattolocal.net": 1,
  "dattorelay.com": 1,
  "dattoweb.com": 1,
  "davvenjarga.no": 1,
  "davvesiida.no": 1,
  "day": 1,
  "dazaifu.fukuoka.jp": 1,
  "dc.us": 1,
  "dclk": 1,
  "dd-dns.de": 1,
  "ddns.me": 1,
  "ddns.net": 1,
  "ddnsfree.com": 1,
  "ddnsgeek.com": 1,
  "ddnsking.com": 1,
  "ddnslive.com": 1,
  "ddnss.de": 1,
  "ddnss.org": 1,
  "ddr.museum": 1,
  "dds": 1,
  "de": 1,
  "de.com": 1,
  "de.cool": 1,
  "de.eu.org": 1,
  "de.gt": 1,
  "de.ls": 1,
  "de.md": 1,
  "de.us": 1,
  "deal": 1,
  "dealer": 1,
  "deals": 1,
  "deatnu.no": 1,
  "debian.net": 1,
  "decorativearts.museum": 1,
  "dedyn.io": 1,
  "def.br": 1,
  "defense.tn": 1,
  "definima.io": 1,
  "definima.net": 1,
  "degree": 1,
  "delaware.museum": 1,
  "delivery": 1,
  "dell": 1,
  "dell-ogliastra.it": 1,
  "dellogliastra.it": 1,
  "delmenhorst.museum": 1,
  "deloitte": 1,
  "delta": 1,
  "demo.jelastic.com": 1,
  "democracia.bo": 1,
  "democrat": 1,
  "demon.nl": 1,
  "denmark.museum": 1,
  "dental": 1,
  "dentist": 1,
  "dep.no": 1,
  "deporte.bo": 1,
  "depot.museum": 1,
  "des.br": 1,
  "desa.id": 1,
  "desi": 1,
  "design": 1,
  "design.aero": 1,
  "design.museum": 1,
  "det.br": 1,
  "detroit.museum": 1,
  "dev": 1,
  "dev-myqnapcloud.com": 1,
  "dev.br": 1,
  "dev.static.land": 1,
  "dev.vu": 1,
  "development.run": 1,
  "devices.resinstaging.io": 1,
  "df.gov.br": 1,
  "df.leg.br": 1,
  "dgca.aero": 1,
  "dh.bytemark.co.uk": 1,
  "dhl": 1,
  "diamonds": 1,
  "dielddanuorri.no": 1,
  "diet": 1,
  "digital": 1,
  "dinosaur.museum": 1,
  "direct": 1,
  "direct.quickconnect.to": 1,
  "directory": 1,
  "discount": 1,
  "discourse.group": 1,
  "discourse.team": 1,
  "discover": 1,
  "discovery.museum": 1,
  "dish": 1,
  "diskstation.eu": 1,
  "diskstation.me": 1,
  "diskstation.org": 1,
  "diskussionsbereich.de": 1,
  "ditchyourip.com": 1,
  "divtasvuodna.no": 1,
  "divttasvuotna.no": 1,
  "diy": 1,
  "dj": 1,
  "dk": 1,
  "dk.eu.org": 1,
  "dlugoleka.pl": 1,
  "dm": 1,
  "dn.ua": 1,
  "dnepropetrovsk.ua": 1,
  "dni.us": 1,
  "dnipropetrovsk.ua": 1,
  "dnp": 1,
  "dnsalias.com": 1,
  "dnsalias.net": 1,
  "dnsalias.org": 1,
  "dnsdojo.com": 1,
  "dnsdojo.net": 1,
  "dnsdojo.org": 1,
  "dnsfor.me": 1,
  "dnshome.de": 1,
  "dnsiskinky.com": 1,
  "dnsking.ch": 1,
  "dnsup.net": 1,
  "dnsupdate.info": 1,
  "dnsupdater.de": 1,
  "do": 1,
  "docs": 1,
  "doctor": 1,
  "does-it.net": 1,
  "doesntexist.com": 1,
  "doesntexist.org": 1,
  "dog": 1,
  "dolls.museum": 1,
  "domains": 1,
  "donetsk.ua": 1,
  "donna.no": 1,
  "donostia.museum": 1,
  "dontexist.com": 1,
  "dontexist.net": 1,
  "dontexist.org": 1,
  "doomdns.com": 1,
  "doomdns.org": 1,
  "dopaas.com": 1,
  "doshi.yamanashi.jp": 1,
  "dot": 1,
  "dovre.no": 1,
  "download": 1,
  "dp.ua": 1,
  "dr.na": 1,
  "dr.tr": 1,
  "drammen.no": 1,
  "drangedal.no": 1,
  "dray-dns.de": 1,
  "drayddns.com": 1,
  "draydns.de": 1,
  "dreamhosters.com": 1,
  "drive": 1,
  "drobak.no": 1,
  "drud.io": 1,
  "drud.us": 1,
  "dscloud.biz": 1,
  "dscloud.me": 1,
  "dscloud.mobi": 1,
  "dsmynas.com": 1,
  "dsmynas.net": 1,
  "dsmynas.org": 1,
  "dst.mi.us": 1,
  "dtv": 1,
  "dubai": 1,
  "duck": 1,
  "duckdns.org": 1,
  "dunlop": 1,
  "dupont": 1,
  "durban": 1,
  "durham.museum": 1,
  "dvag": 1,
  "dvr": 1,
  "dvrcam.info": 1,
  "dvrdns.org": 1,
  "dy.fi": 1,
  "dyn-berlin.de": 1,
  "dyn-ip24.de": 1,
  "dyn-o-saur.com": 1,
  "dyn-vpn.de": 1,
  "dyn.cosidns.de": 1,
  "dyn.ddnss.de": 1,
  "dyn.home-webserver.de": 1,
  "dyn53.io": 1,
  "dynalias.com": 1,
  "dynalias.net": 1,
  "dynalias.org": 1,
  "dynamic-dns.info": 1,
  "dynamisches-dns.de": 1,
  "dynathome.net": 1,
  "dyndns-at-home.com": 1,
  "dyndns-at-work.com": 1,
  "dyndns-blog.com": 1,
  "dyndns-free.com": 1,
  "dyndns-home.com": 1,
  "dyndns-ip.com": 1,
  "dyndns-mail.com": 1,
  "dyndns-office.com": 1,
  "dyndns-pics.com": 1,
  "dyndns-remote.com": 1,
  "dyndns-server.com": 1,
  "dyndns-web.com": 1,
  "dyndns-wiki.com": 1,
  "dyndns-work.com": 1,
  "dyndns.biz": 1,
  "dyndns.dappnode.io": 1,
  "dyndns.ddnss.de": 1,
  "dyndns.info": 1,
  "dyndns.org": 1,
  "dyndns.tv": 1,
  "dyndns.ws": 1,
  "dyndns1.de": 1,
  "dynns.com": 1,
  "dynserv.org": 1,
  "dynu.net": 1,
  "dynv6.net": 1,
  "dynvpn.de": 1,
  "dyroy.no": 1,
  "dz": 1,
  "e.bg": 1,
  "e.se": 1,
  "e12.ve": 1,
  "e164.arpa": 1,
  "e4.cz": 1,
  "earth": 1,
  "east-kazakhstan.su": 1,
  "eastafrica.museum": 1,
  "eastcoast.museum": 1,
  "eat": 1,
  "eating-organic.net": 1,
  "eaton.mi.us": 1,
  "ebetsu.hokkaido.jp": 1,
  "ebina.kanagawa.jp": 1,
  "ebino.miyazaki.jp": 1,
  "ebiz.tw": 1,
  "ec": 1,
  "echizen.fukui.jp": 1,
  "ecn.br": 1,
  "eco": 1,
  "eco.br": 1,
  "ecologia.bo": 1,
  "economia.bo": 1,
  "ed.ao": 1,
  "ed.ci": 1,
  "ed.cr": 1,
  "ed.jp": 1,
  "ed.pw": 1,
  "edeka": 1,
  "edgeapp.net": 1,
  "edgestack.me": 1,
  "edogawa.tokyo.jp": 1,
  "edu": 1,
  "edu.ac": 1,
  "edu.af": 1,
  "edu.al": 1,
  "edu.ar": 1,
  "edu.au": 1,
  "edu.az": 1,
  "edu.ba": 1,
  "edu.bb": 1,
  "edu.bh": 1,
  "edu.bi": 1,
  "edu.bm": 1,
  "edu.bn": 1,
  "edu.bo": 1,
  "edu.br": 1,
  "edu.bs": 1,
  "edu.bt": 1,
  "edu.bz": 1,
  "edu.ci": 1,
  "edu.cn": 1,
  "edu.co": 1,
  "edu.cu": 1,
  "edu.cw": 1,
  "edu.dm": 1,
  "edu.do": 1,
  "edu.dz": 1,
  "edu.ec": 1,
  "edu.ee": 1,
  "edu.eg": 1,
  "edu.es": 1,
  "edu.et": 1,
  "edu.eu.org": 1,
  "edu.ge": 1,
  "edu.gh": 1,
  "edu.gi": 1,
  "edu.gl": 1,
  "edu.gn": 1,
  "edu.gp": 1,
  "edu.gr": 1,
  "edu.gt": 1,
  "edu.gu": 1,
  "edu.gy": 1,
  "edu.hk": 1,
  "edu.hn": 1,
  "edu.ht": 1,
  "edu.in": 1,
  "edu.iq": 1,
  "edu.is": 1,
  "edu.it": 1,
  "edu.jo": 1,
  "edu.kg": 1,
  "edu.ki": 1,
  "edu.km": 1,
  "edu.kn": 1,
  "edu.kp": 1,
  "edu.krd": 1,
  "edu.kw": 1,
  "edu.ky": 1,
  "edu.kz": 1,
  "edu.la": 1,
  "edu.lb": 1,
  "edu.lc": 1,
  "edu.lk": 1,
  "edu.lr": 1,
  "edu.ls": 1,
  "edu.lv": 1,
  "edu.ly": 1,
  "edu.me": 1,
  "edu.mg": 1,
  "edu.mk": 1,
  "edu.ml": 1,
  "edu.mn": 1,
  "edu.mo": 1,
  "edu.ms": 1,
  "edu.mt": 1,
  "edu.mv": 1,
  "edu.mw": 1,
  "edu.mx": 1,
  "edu.my": 1,
  "edu.mz": 1,
  "edu.ng": 1,
  "edu.ni": 1,
  "edu.nr": 1,
  "edu.om": 1,
  "edu.pa": 1,
  "edu.pe": 1,
  "edu.pf": 1,
  "edu.ph": 1,
  "edu.pk": 1,
  "edu.pl": 1,
  "edu.pn": 1,
  "edu.pr": 1,
  "edu.ps": 1,
  "edu.pt": 1,
  "edu.py": 1,
  "edu.qa": 1,
  "edu.rs": 1,
  "edu.ru": 1,
  "edu.sa": 1,
  "edu.sb": 1,
  "edu.sc": 1,
  "edu.sd": 1,
  "edu.sg": 1,
  "edu.sl": 1,
  "edu.sn": 1,
  "edu.so": 1,
  "edu.ss": 1,
  "edu.st": 1,
  "edu.sv": 1,
  "edu.sy": 1,
  "edu.tj": 1,
  "edu.tm": 1,
  "edu.to": 1,
  "edu.tr": 1,
  "edu.tt": 1,
  "edu.tw": 1,
  "edu.ua": 1,
  "edu.uy": 1,
  "edu.vc": 1,
  "edu.ve": 1,
  "edu.vn": 1,
  "edu.vu": 1,
  "edu.ws": 1,
  "edu.za": 1,
  "edu.zm": 1,
  "education": 1,
  "education.museum": 1,
  "educational.museum": 1,
  "educator.aero": 1,
  "edugit.org": 1,
  "edunet.tn": 1,
  "ee": 1,
  "ee.eu.org": 1,
  "eg": 1,
  "egersund.no": 1,
  "egyptian.museum": 1,
  "ehime.jp": 1,
  "eid.no": 1,
  "eidfjord.no": 1,
  "eidsberg.no": 1,
  "eidskog.no": 1,
  "eidsvoll.no": 1,
  "eigersund.no": 1,
  "eiheiji.fukui.jp": 1,
  "eisenbahn.museum": 1,
  "ekloges.cy": 1,
  "elasticbeanstalk.com": 1,
  "elblag.pl": 1,
  "elburg.museum": 1,
  "elk.pl": 1,
  "elvendrell.museum": 1,
  "elverum.no": 1,
  "email": 1,
  "emb.kw": 1,
  "embaixada.st": 1,
  "embetsu.hokkaido.jp": 1,
  "embroidery.museum": 1,
  "emerck": 1,
  "emergency.aero": 1,
  "emilia-romagna.it": 1,
  "emiliaromagna.it": 1,
  "emp.br": 1,
  "empresa.bo": 1,
  "emr.it": 1,
  "en-root.fr": 1,
  "en.it": 1,
  "ena.gifu.jp": 1,
  "encyclopedic.museum": 1,
  "endofinternet.net": 1,
  "endofinternet.org": 1,
  "endoftheinternet.org": 1,
  "enebakk.no": 1,
  "energy": 1,
  "enf.br": 1,
  "eng.br": 1,
  "eng.pro": 1,
  "engerdal.no": 1,
  "engine.aero": 1,
  "engineer": 1,
  "engineer.aero": 1,
  "engineering": 1,
  "england.museum": 1,
  "eniwa.hokkaido.jp": 1,
  "enna.it": 1,
  "enonic.io": 1,
  "ens.tn": 1,
  "ent.platform.sh": 1,
  "enterprisecloud.nu": 1,
  "enterprises": 1,
  "entertainment.aero": 1,
  "entomology.museum": 1,
  "environment.museum": 1,
  "environmentalconservation.museum": 1,
  "epilepsy.museum": 1,
  "epson": 1,
  "equipment": 1,
  "equipment.aero": 1,
  "ericsson": 1,
  "erimo.hokkaido.jp": 1,
  "erni": 1,
  "erotica.hu": 1,
  "erotika.hu": 1,
  "es": 1,
  "es.ax": 1,
  "es.eu.org": 1,
  "es.gov.br": 1,
  "es.kr": 1,
  "es.leg.br": 1,
  "esan.hokkaido.jp": 1,
  "esashi.hokkaido.jp": 1,
  "esp.br": 1,
  "esq": 1,
  "essex.museum": 1,
  "est-a-la-maison.com": 1,
  "est-a-la-masion.com": 1,
  "est-le-patron.com": 1,
  "est-mon-blogueur.com": 1,
  "est.pr": 1,
  "estate": 1,
  "estate.museum": 1,
  "et": 1,
  "etajima.hiroshima.jp": 1,
  "etc.br": 1,
  "ethnology.museum": 1,
  "eti.br": 1,
  "etisalat": 1,
  "etne.no": 1,
  "etnedal.no": 1,
  "eu": 1,
  "eu-1.evennode.com": 1,
  "eu-2.evennode.com": 1,
  "eu-3.evennode.com": 1,
  "eu-4.evennode.com": 1,
  "eu-central-1.elasticbeanstalk.com": 1,
  "eu-west-1.elasticbeanstalk.com": 1,
  "eu-west-2.elasticbeanstalk.com": 1,
  "eu-west-3.elasticbeanstalk.com": 1,
  "eu.ax": 1,
  "eu.com": 1,
  "eu.int": 1,
  "eu.meteorapp.com": 1,
  "eu.org": 1,
  "eu.platform.sh": 1,
  "eun.eg": 1,
  "eurovision": 1,
  "eus": 1,
  "evenassi.no": 1,
  "evenes.no": 1,
  "events": 1,
  "evje-og-hornnes.no": 1,
  "exchange": 1,
  "exchange.aero": 1,
  "exeter.museum": 1,
  "exhibition.museum": 1,
  "exnet.su": 1,
  "expert": 1,
  "experts-comptables.fr": 1,
  "exposed": 1,
  "express": 1,
  "express.aero": 1,
  "extraspace": 1,
  "f.bg": 1,
  "f.se": 1,
  "fage": 1,
  "fail": 1,
  "fairwinds": 1,
  "faith": 1,
  "fam.pk": 1,
  "family": 1,
  "family.museum": 1,
  "familyds.com": 1,
  "familyds.net": 1,
  "familyds.org": 1,
  "fan": 1,
  "fans": 1,
  "fantasyleague.cc": 1,
  "far.br": 1,
  "farm": 1,
  "farm.museum": 1,
  "farmequipment.museum": 1,
  "farmers": 1,
  "farmers.museum": 1,
  "farmstead.museum": 1,
  "farsund.no": 1,
  "fashion": 1,
  "fast": 1,
  "fastly-terrarium.com": 1,
  "fastlylb.net": 1,
  "fastvps-server.com": 1,
  "fastvps.host": 1,
  "fastvps.site": 1,
  "fauske.no": 1,
  "fbx-os.fr": 1,
  "fbxos.fr": 1,
  "fc.it": 1,
  "fe.it": 1,
  "fed.us": 1,
  "federation.aero": 1,
  "fedex": 1,
  "fedje.no": 1,
  "fedorainfracloud.org": 1,
  "fedorapeople.org": 1,
  "feedback": 1,
  "feira.br": 1,
  "fermo.it": 1,
  "ferrara.it": 1,
  "ferrari": 1,
  "ferrero": 1,
  "feste-ip.net": 1,
  "fet.no": 1,
  "fetsund.no": 1,
  "fg.it": 1,
  "fh.se": 1,
  "fhapp.xyz": 1,
  "fhs.no": 1,
  "fhsk.se": 1,
  "fhv.se": 1,
  "fi": 1,
  "fi.cr": 1,
  "fi.eu.org": 1,
  "fi.it": 1,
  "fiat": 1,
  "fidelity": 1,
  "fido": 1,
  "fie.ee": 1,
  "field.museum": 1,
  "figueres.museum": 1,
  "filatelia.museum": 1,
  "filegear-au.me": 1,
  "filegear-de.me": 1,
  "filegear-gb.me": 1,
  "filegear-ie.me": 1,
  "filegear-jp.me": 1,
  "filegear-sg.me": 1,
  "filegear.me": 1,
  "film": 1,
  "film.hu": 1,
  "film.museum": 1,
  "fin.ci": 1,
  "fin.ec": 1,
  "fin.tn": 1,
  "final": 1,
  "finance": 1,
  "financial": 1,
  "fineart.museum": 1,
  "finearts.museum": 1,
  "finland.museum": 1,
  "finnoy.no": 1,
  "fire": 1,
  "firebaseapp.com": 1,
  "firenze.it": 1,
  "firestone": 1,
  "firewall-gateway.com": 1,
  "firewall-gateway.de": 1,
  "firewall-gateway.net": 1,
  "firm.co": 1,
  "firm.dk": 1,
  "firm.ht": 1,
  "firm.in": 1,
  "firm.nf": 1,
  "firm.ng": 1,
  "firm.ro": 1,
  "firm.ve": 1,
  "firmdale": 1,
  "fish": 1,
  "fishing": 1,
  "fit": 1,
  "fitjar.no": 1,
  "fitness": 1,
  "fj": 1,
  "fj.cn": 1,
  "fjaler.no": 1,
  "fjell.no": 1,
  "fl.us": 1,
  "fla.no": 1,
  "flakstad.no": 1,
  "flanders.museum": 1,
  "flatanger.no": 1,
  "flekkefjord.no": 1,
  "flesberg.no": 1,
  "flickr": 1,
  "flight.aero": 1,
  "flights": 1,
  "flir": 1,
  "flog.br": 1,
  "flora.no": 1,
  "florence.it": 1,
  "florida.museum": 1,
  "floripa.br": 1,
  "florist": 1,
  "floro.no": 1,
  "flowers": 1,
  "flt.cloud.muni.cz": 1,
  "fly": 1,
  "fly.dev": 1,
  "flynnhosting.net": 1,
  "fm": 1,
  "fm.br": 1,
  "fm.it": 1,
  "fm.no": 1,
  "fnd.br": 1,
  "fo": 1,
  "foggia.it": 1,
  "folkebibl.no": 1,
  "folldal.no": 1,
  "foo": 1,
  "food": 1,
  "foodnetwork": 1,
  "football": 1,
  "for-better.biz": 1,
  "for-more.biz": 1,
  "for-our.info": 1,
  "for-some.biz": 1,
  "for-the.biz": 1,
  "for.men": 1,
  "for.mom": 1,
  "for.one": 1,
  "for.sale": 1,
  "force.museum": 1,
  "ford": 1,
  "forde.no": 1,
  "forex": 1,
  "forgot.her.name": 1,
  "forgot.his.name": 1,
  "forli-cesena.it": 1,
  "forlicesena.it": 1,
  "forsale": 1,
  "forsand.no": 1,
  "fortal.br": 1,
  "fortmissoula.museum": 1,
  "fortworth.museum": 1,
  "forum": 1,
  "forum.hu": 1,
  "forumz.info": 1,
  "fosnes.no": 1,
  "fot.br": 1,
  "foundation": 1,
  "foundation.museum": 1,
  "fox": 1,
  "foz.br": 1,
  "fr": 1,
  "fr.eu.org": 1,
  "fr.it": 1,
  "frana.no": 1,
  "francaise.museum": 1,
  "frankfurt.museum": 1,
  "franziskaner.museum": 1,
  "fredrikstad.no": 1,
  "free": 1,
  "free.hr": 1,
  "freebox-os.com": 1,
  "freebox-os.fr": 1,
  "freeboxos.com": 1,
  "freeboxos.fr": 1,
  "freeddns.org": 1,
  "freeddns.us": 1,
  "freedesktop.org": 1,
  "freemasonry.museum": 1,
  "freesite.host": 1,
  "freetls.fastly.net": 1,
  "frei.no": 1,
  "freiburg.museum": 1,
  "fresenius": 1,
  "fribourg.museum": 1,
  "friuli-v-giulia.it": 1,
  "friuli-ve-giulia.it": 1,
  "friuli-vegiulia.it": 1,
  "friuli-venezia-giulia.it": 1,
  "friuli-veneziagiulia.it": 1,
  "friuli-vgiulia.it": 1,
  "friuliv-giulia.it": 1,
  "friulive-giulia.it": 1,
  "friulivegiulia.it": 1,
  "friulivenezia-giulia.it": 1,
  "friuliveneziagiulia.it": 1,
  "friulivgiulia.it": 1,
  "frl": 1,
  "frog.museum": 1,
  "frogans": 1,
  "frogn.no": 1,
  "froland.no": 1,
  "from-ak.com": 1,
  "from-al.com": 1,
  "from-ar.com": 1,
  "from-az.net": 1,
  "from-ca.com": 1,
  "from-co.net": 1,
  "from-ct.com": 1,
  "from-dc.com": 1,
  "from-de.com": 1,
  "from-fl.com": 1,
  "from-ga.com": 1,
  "from-hi.com": 1,
  "from-ia.com": 1,
  "from-id.com": 1,
  "from-il.com": 1,
  "from-in.com": 1,
  "from-ks.com": 1,
  "from-ky.com": 1,
  "from-la.net": 1,
  "from-ma.com": 1,
  "from-md.com": 1,
  "from-me.org": 1,
  "from-mi.com": 1,
  "from-mn.com": 1,
  "from-mo.com": 1,
  "from-ms.com": 1,
  "from-mt.com": 1,
  "from-nc.com": 1,
  "from-nd.com": 1,
  "from-ne.com": 1,
  "from-nh.com": 1,
  "from-nj.com": 1,
  "from-nm.com": 1,
  "from-nv.com": 1,
  "from-ny.net": 1,
  "from-oh.com": 1,
  "from-ok.com": 1,
  "from-or.com": 1,
  "from-pa.com": 1,
  "from-pr.com": 1,
  "from-ri.com": 1,
  "from-sc.com": 1,
  "from-sd.com": 1,
  "from-tn.com": 1,
  "from-tx.com": 1,
  "from-ut.com": 1,
  "from-va.com": 1,
  "from-vt.com": 1,
  "from-wa.com": 1,
  "from-wi.com": 1,
  "from-wv.com": 1,
  "from-wy.com": 1,
  "from.hr": 1,
  "frontdoor": 1,
  "frontier": 1,
  "frosinone.it": 1,
  "frosta.no": 1,
  "froya.no": 1,
  "fst.br": 1,
  "ftpaccess.cc": 1,
  "ftr": 1,
  "fuchu.hiroshima.jp": 1,
  "fuchu.tokyo.jp": 1,
  "fuchu.toyama.jp": 1,
  "fudai.iwate.jp": 1,
  "fuefuki.yamanashi.jp": 1,
  "fuel.aero": 1,
  "fuettertdasnetz.de": 1,
  "fuji.shizuoka.jp": 1,
  "fujieda.shizuoka.jp": 1,
  "fujiidera.osaka.jp": 1,
  "fujikawa.shizuoka.jp": 1,
  "fujikawa.yamanashi.jp": 1,
  "fujikawaguchiko.yamanashi.jp": 1,
  "fujimi.nagano.jp": 1,
  "fujimi.saitama.jp": 1,
  "fujimino.saitama.jp": 1,
  "fujinomiya.shizuoka.jp": 1,
  "fujioka.gunma.jp": 1,
  "fujisato.akita.jp": 1,
  "fujisawa.iwate.jp": 1,
  "fujisawa.kanagawa.jp": 1,
  "fujishiro.ibaraki.jp": 1,
  "fujitsu": 1,
  "fujixerox": 1,
  "fujiyoshida.yamanashi.jp": 1,
  "fukagawa.hokkaido.jp": 1,
  "fukaya.saitama.jp": 1,
  "fukuchi.fukuoka.jp": 1,
  "fukuchiyama.kyoto.jp": 1,
  "fukudomi.saga.jp": 1,
  "fukui.fukui.jp": 1,
  "fukui.jp": 1,
  "fukumitsu.toyama.jp": 1,
  "fukuoka.jp": 1,
  "fukuroi.shizuoka.jp": 1,
  "fukusaki.hyogo.jp": 1,
  "fukushima.fukushima.jp": 1,
  "fukushima.hokkaido.jp": 1,
  "fukushima.jp": 1,
  "fukuyama.hiroshima.jp": 1,
  "fun": 1,
  "funabashi.chiba.jp": 1,
  "funagata.yamagata.jp": 1,
  "funahashi.toyama.jp": 1,
  "fund": 1,
  "fundacio.museum": 1,
  "fuoisku.no": 1,
  "fuossko.no": 1,
  "furano.hokkaido.jp": 1,
  "furniture": 1,
  "furniture.museum": 1,
  "furubira.hokkaido.jp": 1,
  "furudono.fukushima.jp": 1,
  "furukawa.miyagi.jp": 1,
  "fusa.no": 1,
  "fuso.aichi.jp": 1,
  "fussa.tokyo.jp": 1,
  "futaba.fukushima.jp": 1,
  "futbol": 1,
  "futsu.nagasaki.jp": 1,
  "futtsu.chiba.jp": 1,
  "futurehosting.at": 1,
  "futuremailing.at": 1,
  "fvg.it": 1,
  "fyi": 1,
  "fylkesbibl.no": 1,
  "fyresdal.no": 1,
  "g.bg": 1,
  "g.se": 1,
  "g.vbrplsbx.io": 1,
  "g12.br": 1,
  "ga": 1,
  "ga.us": 1,
  "gaivuotna.no": 1,
  "gal": 1,
  "gallery": 1,
  "gallery.museum": 1,
  "gallo": 1,
  "gallup": 1,
  "galsa.no": 1,
  "gamagori.aichi.jp": 1,
  "game": 1,
  "game-host.org": 1,
  "game-server.cc": 1,
  "game.tw": 1,
  "games": 1,
  "games.hu": 1,
  "gamo.shiga.jp": 1,
  "gamvik.no": 1,
  "gangaviika.no": 1,
  "gangwon.kr": 1,
  "gap": 1,
  "garden": 1,
  "garden.museum": 1,
  "gateway.museum": 1,
  "gaular.no": 1,
  "gausdal.no": 1,
  "gay": 1,
  "gb": 1,
  "gb.com": 1,
  "gb.net": 1,
  "gbiz": 1,
  "gc.ca": 1,
  "gd": 1,
  "gd.cn": 1,
  "gda.pl": 1,
  "gdansk.pl": 1,
  "gdn": 1,
  "gdynia.pl": 1,
  "ge": 1,
  "ge.it": 1,
  "gea": 1,
  "geek.nz": 1,
  "geekgalaxy.com": 1,
  "geelvinck.museum": 1,
  "gehirn.ne.jp": 1,
  "geisei.kochi.jp": 1,
  "gemological.museum": 1,
  "gen.in": 1,
  "gen.mi.us": 1,
  "gen.ng": 1,
  "gen.nz": 1,
  "gen.tr": 1,
  "genkai.saga.jp": 1,
  "genoa.it": 1,
  "genova.it": 1,
  "gent": 1,
  "gentapps.com": 1,
  "genting": 1,
  "gentlentapis.com": 1,
  "geo.br": 1,
  "geology.museum": 1,
  "geometre-expert.fr": 1,
  "george": 1,
  "georgia.museum": 1,
  "georgia.su": 1,
  "getmyip.com": 1,
  "gets-it.net": 1,
  "gf": 1,
  "gg": 1,
  "gg.ax": 1,
  "ggee": 1,
  "ggf.br": 1,
  "gh": 1,
  "gi": 1,
  "giehtavuoatna.no": 1,
  "giessen.museum": 1,
  "gift": 1,
  "gifts": 1,
  "gifu.gifu.jp": 1,
  "gifu.jp": 1,
  "giize.com": 1,
  "gildeskal.no": 1,
  "ginan.gifu.jp": 1,
  "ginowan.okinawa.jp": 1,
  "ginoza.okinawa.jp": 1,
  "giske.no": 1,
  "git-pages.rit.edu": 1,
  "git-repos.de": 1,
  "github.io": 1,
  "githubusercontent.com": 1,
  "gitlab.io": 1,
  "gitpage.si": 1,
  "gives": 1,
  "giving": 1,
  "gjemnes.no": 1,
  "gjerdrum.no": 1,
  "gjerstad.no": 1,
  "gjesdal.no": 1,
  "gjovik.no": 1,
  "gl": 1,
  "glade": 1,
  "glas.museum": 1,
  "glass": 1,
  "glass.museum": 1,
  "gle": 1,
  "gleeze.com": 1,
  "gliding.aero": 1,
  "glitch.me": 1,
  "gliwice.pl": 1,
  "global": 1,
  "global.prod.fastly.net": 1,
  "global.ssl.fastly.net": 1,
  "globo": 1,
  "glogow.pl": 1,
  "gloppen.no": 1,
  "glug.org.uk": 1,
  "gm": 1,
  "gmail": 1,
  "gmbh": 1,
  "gmina.pl": 1,
  "gmo": 1,
  "gmx": 1,
  "gn": 1,
  "gniezno.pl": 1,
  "go.ci": 1,
  "go.cr": 1,
  "go.dyndns.org": 1,
  "go.gov.br": 1,
  "go.id": 1,
  "go.it": 1,
  "go.jp": 1,
  "go.ke": 1,
  "go.kr": 1,
  "go.leg.br": 1,
  "go.pw": 1,
  "go.th": 1,
  "go.tj": 1,
  "go.tz": 1,
  "go.ug": 1,
  "gob.ar": 1,
  "gob.bo": 1,
  "gob.cl": 1,
  "gob.do": 1,
  "gob.ec": 1,
  "gob.es": 1,
  "gob.gt": 1,
  "gob.hn": 1,
  "gob.mx": 1,
  "gob.ni": 1,
  "gob.pa": 1,
  "gob.pe": 1,
  "gob.pk": 1,
  "gob.sv": 1,
  "gob.ve": 1,
  "gobo.wakayama.jp": 1,
  "godaddy": 1,
  "godo.gifu.jp": 1,
  "goiania.br": 1,
  "goip.de": 1,
  "gojome.akita.jp": 1,
  "gok.pk": 1,
  "gokase.miyazaki.jp": 1,
  "gol.no": 1,
  "gold": 1,
  "goldpoint": 1,
  "golf": 1,
  "golffan.us": 1,
  "gon.pk": 1,
  "gonohe.aomori.jp": 1,
  "goo": 1,
  "goodyear": 1,
  "goog": 1,
  "google": 1,
  "googleapis.com": 1,
  "googlecode.com": 1,
  "gop": 1,
  "gop.pk": 1,
  "gorge.museum": 1,
  "gorizia.it": 1,
  "gorlice.pl": 1,
  "gos.pk": 1,
  "gose.nara.jp": 1,
  "gosen.niigata.jp": 1,
  "goshiki.hyogo.jp": 1,
  "got": 1,
  "gotdns.ch": 1,
  "gotdns.com": 1,
  "gotdns.org": 1,
  "gotemba.shizuoka.jp": 1,
  "goto.nagasaki.jp": 1,
  "gotpantheon.com": 1,
  "gotsu.shimane.jp": 1,
  "gouv.bj": 1,
  "gouv.ci": 1,
  "gouv.fr": 1,
  "gouv.ht": 1,
  "gouv.km": 1,
  "gouv.ml": 1,
  "gouv.sn": 1,
  "gov": 1,
  "gov.ac": 1,
  "gov.ae": 1,
  "gov.af": 1,
  "gov.al": 1,
  "gov.ar": 1,
  "gov.as": 1,
  "gov.au": 1,
  "gov.az": 1,
  "gov.ba": 1,
  "gov.bb": 1,
  "gov.bf": 1,
  "gov.bh": 1,
  "gov.bm": 1,
  "gov.bn": 1,
  "gov.br": 1,
  "gov.bs": 1,
  "gov.bt": 1,
  "gov.by": 1,
  "gov.bz": 1,
  "gov.cd": 1,
  "gov.cl": 1,
  "gov.cm": 1,
  "gov.cn": 1,
  "gov.co": 1,
  "gov.cu": 1,
  "gov.cx": 1,
  "gov.cy": 1,
  "gov.dm": 1,
  "gov.do": 1,
  "gov.dz": 1,
  "gov.ec": 1,
  "gov.ee": 1,
  "gov.eg": 1,
  "gov.et": 1,
  "gov.fj": 1,
  "gov.ge": 1,
  "gov.gh": 1,
  "gov.gi": 1,
  "gov.gn": 1,
  "gov.gr": 1,
  "gov.gu": 1,
  "gov.gy": 1,
  "gov.hk": 1,
  "gov.ie": 1,
  "gov.il": 1,
  "gov.in": 1,
  "gov.iq": 1,
  "gov.ir": 1,
  "gov.is": 1,
  "gov.it": 1,
  "gov.jo": 1,
  "gov.kg": 1,
  "gov.ki": 1,
  "gov.km": 1,
  "gov.kn": 1,
  "gov.kp": 1,
  "gov.kw": 1,
  "gov.ky": 1,
  "gov.kz": 1,
  "gov.la": 1,
  "gov.lb": 1,
  "gov.lc": 1,
  "gov.lk": 1,
  "gov.lr": 1,
  "gov.ls": 1,
  "gov.lt": 1,
  "gov.lv": 1,
  "gov.ly": 1,
  "gov.ma": 1,
  "gov.me": 1,
  "gov.mg": 1,
  "gov.mk": 1,
  "gov.ml": 1,
  "gov.mn": 1,
  "gov.mo": 1,
  "gov.mr": 1,
  "gov.ms": 1,
  "gov.mu": 1,
  "gov.mv": 1,
  "gov.mw": 1,
  "gov.my": 1,
  "gov.mz": 1,
  "gov.nc.tr": 1,
  "gov.ng": 1,
  "gov.nr": 1,
  "gov.om": 1,
  "gov.ph": 1,
  "gov.pk": 1,
  "gov.pl": 1,
  "gov.pn": 1,
  "gov.pr": 1,
  "gov.ps": 1,
  "gov.pt": 1,
  "gov.py": 1,
  "gov.qa": 1,
  "gov.rs": 1,
  "gov.ru": 1,
  "gov.rw": 1,
  "gov.sa": 1,
  "gov.sb": 1,
  "gov.sc": 1,
  "gov.scot": 1,
  "gov.sd": 1,
  "gov.sg": 1,
  "gov.sh": 1,
  "gov.sl": 1,
  "gov.so": 1,
  "gov.ss": 1,
  "gov.st": 1,
  "gov.sx": 1,
  "gov.sy": 1,
  "gov.tj": 1,
  "gov.tl": 1,
  "gov.tm": 1,
  "gov.tn": 1,
  "gov.to": 1,
  "gov.tr": 1,
  "gov.tt": 1,
  "gov.tw": 1,
  "gov.ua": 1,
  "gov.uk": 1,
  "gov.vc": 1,
  "gov.ve": 1,
  "gov.vn": 1,
  "gov.ws": 1,
  "gov.za": 1,
  "gov.zm": 1,
  "gov.zw": 1,
  "government.aero": 1,
  "govt.nz": 1,
  "gp": 1,
  "gq": 1,
  "gr": 1,
  "gr.com": 1,
  "gr.eu.org": 1,
  "gr.it": 1,
  "gr.jp": 1,
  "grainger": 1,
  "grajewo.pl": 1,
  "gran.no": 1,
  "grandrapids.museum": 1,
  "grane.no": 1,
  "granvin.no": 1,
  "graphics": 1,
  "graphox.us": 1,
  "gratangen.no": 1,
  "gratis": 1,
  "graz.museum": 1,
  "green": 1,
  "greta.fr": 1,
  "grimstad.no": 1,
  "gripe": 1,
  "griw.gov.pl": 1,
  "grocery": 1,
  "groks-the.info": 1,
  "groks-this.info": 1,
  "grondar.za": 1,
  "grong.no": 1,
  "grosseto.it": 1,
  "groundhandling.aero": 1,
  "group": 1,
  "group.aero": 1,
  "grozny.ru": 1,
  "grozny.su": 1,
  "grp.lk": 1,
  "gru.br": 1,
  "grue.no": 1,
  "gs": 1,
  "gs.aa.no": 1,
  "gs.ah.no": 1,
  "gs.bu.no": 1,
  "gs.cn": 1,
  "gs.fm.no": 1,
  "gs.hl.no": 1,
  "gs.hm.no": 1,
  "gs.jan-mayen.no": 1,
  "gs.mr.no": 1,
  "gs.nl.no": 1,
  "gs.nt.no": 1,
  "gs.of.no": 1,
  "gs.ol.no": 1,
  "gs.oslo.no": 1,
  "gs.rl.no": 1,
  "gs.sf.no": 1,
  "gs.st.no": 1,
  "gs.svalbard.no": 1,
  "gs.tm.no": 1,
  "gs.tr.no": 1,
  "gs.va.no": 1,
  "gs.vf.no": 1,
  "gsm.pl": 1,
  "gt": 1,
  "gu": 1,
  "gu.us": 1,
  "guam.gu": 1,
  "guardian": 1,
  "gub.uy": 1,
  "gucci": 1,
  "guernsey.museum": 1,
  "guge": 1,
  "guide": 1,
  "guitars": 1,
  "gujo.gifu.jp": 1,
  "gulen.no": 1,
  "gunma.jp": 1,
  "guovdageaidnu.no": 1,
  "guru": 1,
  "gushikami.okinawa.jp": 1,
  "gv.ao": 1,
  "gv.at": 1,
  "gv.vc": 1,
  "gw": 1,
  "gwangju.kr": 1,
  "gwiddle.co.uk": 1,
  "gx.cn": 1,
  "gy": 1,
  "gyeongbuk.kr": 1,
  "gyeonggi.kr": 1,
  "gyeongnam.kr": 1,
  "gyokuto.kumamoto.jp": 1,
  "gz.cn": 1,
  "h.bg": 1,
  "h.se": 1,
  "ha.cn": 1,
  "ha.no": 1,
  "habikino.osaka.jp": 1,
  "habmer.no": 1,
  "haboro.hokkaido.jp": 1,
  "hachijo.tokyo.jp": 1,
  "hachinohe.aomori.jp": 1,
  "hachioji.tokyo.jp": 1,
  "hachirogata.akita.jp": 1,
  "hadano.kanagawa.jp": 1,
  "hadsel.no": 1,
  "haebaru.okinawa.jp": 1,
  "haga.tochigi.jp": 1,
  "hagebostad.no": 1,
  "hagi.yamaguchi.jp": 1,
  "haibara.shizuoka.jp": 1,
  "hair": 1,
  "hakata.fukuoka.jp": 1,
  "hakodate.hokkaido.jp": 1,
  "hakone.kanagawa.jp": 1,
  "hakuba.nagano.jp": 1,
  "hakui.ishikawa.jp": 1,
  "hakusan.ishikawa.jp": 1,
  "halden.no": 1,
  "half.host": 1,
  "halloffame.museum": 1,
  "halsa.no": 1,
  "ham-radio-op.net": 1,
  "hamada.shimane.jp": 1,
  "hamamatsu.shizuoka.jp": 1,
  "hamar.no": 1,
  "hamaroy.no": 1,
  "hamatama.saga.jp": 1,
  "hamatonbetsu.hokkaido.jp": 1,
  "hamburg": 1,
  "hamburg.museum": 1,
  "hammarfeasta.no": 1,
  "hammerfest.no": 1,
  "hamura.tokyo.jp": 1,
  "hanamaki.iwate.jp": 1,
  "hanamigawa.chiba.jp": 1,
  "hanawa.fukushima.jp": 1,
  "handa.aichi.jp": 1,
  "handson.museum": 1,
  "hanggliding.aero": 1,
  "hangout": 1,
  "hannan.osaka.jp": 1,
  "hanno.saitama.jp": 1,
  "hanyu.saitama.jp": 1,
  "hapmir.no": 1,
  "happou.akita.jp": 1,
  "hara.nagano.jp": 1,
  "haram.no": 1,
  "hareid.no": 1,
  "harima.hyogo.jp": 1,
  "harstad.no": 1,
  "harvestcelebration.museum": 1,
  "hasama.oita.jp": 1,
  "hasami.nagasaki.jp": 1,
  "hashbang.sh": 1,
  "hashikami.aomori.jp": 1,
  "hashima.gifu.jp": 1,
  "hashimoto.wakayama.jp": 1,
  "hasuda.saitama.jp": 1,
  "hasura-app.io": 1,
  "hasura.app": 1,
  "hasvik.no": 1,
  "hatogaya.saitama.jp": 1,
  "hatoyama.saitama.jp": 1,
  "hatsukaichi.hiroshima.jp": 1,
  "hattfjelldal.no": 1,
  "haugesund.no": 1,
  "haus": 1,
  "hawaii.museum": 1,
  "hayakawa.yamanashi.jp": 1,
  "hayashima.okayama.jp": 1,
  "hazu.aichi.jp": 1,
  "hb.cldmail.ru": 1,
  "hb.cn": 1,
  "hbo": 1,
  "hdfc": 1,
  "hdfcbank": 1,
  "he.cn": 1,
  "health": 1,
  "health-carereform.com": 1,
  "health.museum": 1,
  "health.nz": 1,
  "health.vn": 1,
  "healthcare": 1,
  "heguri.nara.jp": 1,
  "heimatunduhren.museum": 1,
  "hekinan.aichi.jp": 1,
  "hellas.museum": 1,
  "help": 1,
  "helsinki": 1,
  "helsinki.museum": 1,
  "hembygdsforbund.museum": 1,
  "hemne.no": 1,
  "hemnes.no": 1,
  "hemsedal.no": 1,
  "hepforge.org": 1,
  "herad.no": 1,
  "here": 1,
  "here-for-more.info": 1,
  "heritage.museum": 1,
  "hermes": 1,
  "herokuapp.com": 1,
  "herokussl.com": 1,
  "heroy.more-og-romsdal.no": 1,
  "heroy.nordland.no": 1,
  "hgtv": 1,
  "hi.cn": 1,
  "hi.us": 1,
  "hicam.net": 1,
  "hichiso.gifu.jp": 1,
  "hida.gifu.jp": 1,
  "hidaka.hokkaido.jp": 1,
  "hidaka.kochi.jp": 1,
  "hidaka.saitama.jp": 1,
  "hidaka.wakayama.jp": 1,
  "hidora.com": 1,
  "higashi.fukuoka.jp": 1,
  "higashi.fukushima.jp": 1,
  "higashi.okinawa.jp": 1,
  "higashiagatsuma.gunma.jp": 1,
  "higashichichibu.saitama.jp": 1,
  "higashihiroshima.hiroshima.jp": 1,
  "higashiizu.shizuoka.jp": 1,
  "higashiizumo.shimane.jp": 1,
  "higashikagawa.kagawa.jp": 1,
  "higashikagura.hokkaido.jp": 1,
  "higashikawa.hokkaido.jp": 1,
  "higashikurume.tokyo.jp": 1,
  "higashimatsushima.miyagi.jp": 1,
  "higashimatsuyama.saitama.jp": 1,
  "higashimurayama.tokyo.jp": 1,
  "higashinaruse.akita.jp": 1,
  "higashine.yamagata.jp": 1,
  "higashiomi.shiga.jp": 1,
  "higashiosaka.osaka.jp": 1,
  "higashishirakawa.gifu.jp": 1,
  "higashisumiyoshi.osaka.jp": 1,
  "higashitsuno.kochi.jp": 1,
  "higashiura.aichi.jp": 1,
  "higashiyama.kyoto.jp": 1,
  "higashiyamato.tokyo.jp": 1,
  "higashiyodogawa.osaka.jp": 1,
  "higashiyoshino.nara.jp": 1,
  "hiji.oita.jp": 1,
  "hikari.yamaguchi.jp": 1,
  "hikawa.shimane.jp": 1,
  "hikimi.shimane.jp": 1,
  "hikone.shiga.jp": 1,
  "himeji.hyogo.jp": 1,
  "himeshima.oita.jp": 1,
  "himi.toyama.jp": 1,
  "hino.tokyo.jp": 1,
  "hino.tottori.jp": 1,
  "hinode.tokyo.jp": 1,
  "hinohara.tokyo.jp": 1,
  "hioki.kagoshima.jp": 1,
  "hiphop": 1,
  "hirado.nagasaki.jp": 1,
  "hiraizumi.iwate.jp": 1,
  "hirakata.osaka.jp": 1,
  "hiranai.aomori.jp": 1,
  "hirara.okinawa.jp": 1,
  "hirata.fukushima.jp": 1,
  "hiratsuka.kanagawa.jp": 1,
  "hiraya.nagano.jp": 1,
  "hirogawa.wakayama.jp": 1,
  "hirokawa.fukuoka.jp": 1,
  "hirono.fukushima.jp": 1,
  "hirono.iwate.jp": 1,
  "hiroo.hokkaido.jp": 1,
  "hirosaki.aomori.jp": 1,
  "hiroshima.jp": 1,
  "hisamitsu": 1,
  "hisayama.fukuoka.jp": 1,
  "histoire.museum": 1,
  "historical.museum": 1,
  "historicalsociety.museum": 1,
  "historichouses.museum": 1,
  "historisch.museum": 1,
  "historisches.museum": 1,
  "history.museum": 1,
  "historyofscience.museum": 1,
  "hita.oita.jp": 1,
  "hitachi": 1,
  "hitachi.ibaraki.jp": 1,
  "hitachinaka.ibaraki.jp": 1,
  "hitachiomiya.ibaraki.jp": 1,
  "hitachiota.ibaraki.jp": 1,
  "hitra.no": 1,
  "hiv": 1,
  "hizen.saga.jp": 1,
  "hjartdal.no": 1,
  "hjelmeland.no": 1,
  "hk": 1,
  "hk.cn": 1,
  "hk.com": 1,
  "hk.org": 1,
  "hkt": 1,
  "hl.cn": 1,
  "hl.no": 1,
  "hm": 1,
  "hm.no": 1,
  "hn": 1,
  "hn.cn": 1,
  "hobby-site.com": 1,
  "hobby-site.org": 1,
  "hobol.no": 1,
  "hockey": 1,
  "hof.no": 1,
  "hofu.yamaguchi.jp": 1,
  "hokkaido.jp": 1,
  "hokksund.no": 1,
  "hokuryu.hokkaido.jp": 1,
  "hokuto.hokkaido.jp": 1,
  "hokuto.yamanashi.jp": 1,
  "hol.no": 1,
  "holdings": 1,
  "hole.no": 1,
  "holiday": 1,
  "holmestrand.no": 1,
  "holtalen.no": 1,
  "home-webserver.de": 1,
  "home.dyndns.org": 1,
  "homebuilt.aero": 1,
  "homedepot": 1,
  "homedns.org": 1,
  "homeftp.net": 1,
  "homeftp.org": 1,
  "homegoods": 1,
  "homeip.net": 1,
  "homelink.one": 1,
  "homelinux.com": 1,
  "homelinux.net": 1,
  "homelinux.org": 1,
  "homeoffice.gov.uk": 1,
  "homes": 1,
  "homesecuritymac.com": 1,
  "homesecuritypc.com": 1,
  "homesense": 1,
  "homeunix.com": 1,
  "homeunix.net": 1,
  "homeunix.org": 1,
  "honai.ehime.jp": 1,
  "honbetsu.hokkaido.jp": 1,
  "honda": 1,
  "honefoss.no": 1,
  "hongo.hiroshima.jp": 1,
  "honjo.akita.jp": 1,
  "honjo.saitama.jp": 1,
  "honjyo.akita.jp": 1,
  "hopto.me": 1,
  "hopto.org": 1,
  "hornindal.no": 1,
  "horokanai.hokkaido.jp": 1,
  "horology.museum": 1,
  "horonobe.hokkaido.jp": 1,
  "horse": 1,
  "horten.no": 1,
  "hospital": 1,
  "host": 1,
  "hostedpi.com": 1,
  "hosting": 1,
  "hosting-cluster.nl": 1,
  "hostyhosting.io": 1,
  "hot": 1,
  "hotel.hu": 1,
  "hotel.lk": 1,
  "hotel.tz": 1,
  "hoteles": 1,
  "hotels": 1,
  "hotmail": 1,
  "house": 1,
  "house.museum": 1,
  "how": 1,
  "hoyanger.no": 1,
  "hoylandet.no": 1,
  "hr": 1,
  "hr.eu.org": 1,
  "hs.kr": 1,
  "hs.run": 1,
  "hs.zone": 1,
  "hsbc": 1,
  "ht": 1,
  "hu": 1,
  "hu.com": 1,
  "hu.eu.org": 1,
  "hu.net": 1,
  "hughes": 1,
  "huissier-justice.fr": 1,
  "humanities.museum": 1,
  "hurdal.no": 1,
  "hurum.no": 1,
  "hvaler.no": 1,
  "hyatt": 1,
  "hyllestad.no": 1,
  "hyogo.jp": 1,
  "hyuga.miyazaki.jp": 1,
  "hyundai": 1,
  "hzc.io": 1,
  "i.bg": 1,
  "i.ng": 1,
  "i.ph": 1,
  "i.se": 1,
  "i234.me": 1,
  "ia.us": 1,
  "iamallama.com": 1,
  "ibara.okayama.jp": 1,
  "ibaraki.ibaraki.jp": 1,
  "ibaraki.jp": 1,
  "ibaraki.osaka.jp": 1,
  "ibestad.no": 1,
  "ibigawa.gifu.jp": 1,
  "ibm": 1,
  "ic.gov.pl": 1,
  "icbc": 1,
  "ice": 1,
  "ichiba.tokushima.jp": 1,
  "ichihara.chiba.jp": 1,
  "ichikai.tochigi.jp": 1,
  "ichikawa.chiba.jp": 1,
  "ichikawa.hyogo.jp": 1,
  "ichikawamisato.yamanashi.jp": 1,
  "ichinohe.iwate.jp": 1,
  "ichinomiya.aichi.jp": 1,
  "ichinomiya.chiba.jp": 1,
  "ichinoseki.iwate.jp": 1,
  "icu": 1,
  "id": 1,
  "id.au": 1,
  "id.ir": 1,
  "id.lv": 1,
  "id.ly": 1,
  "id.us": 1,
  "ide.kyoto.jp": 1,
  "idf.il": 1,
  "idrett.no": 1,
  "idv.hk": 1,
  "idv.tw": 1,
  "ie": 1,
  "ie.eu.org": 1,
  "ieee": 1,
  "if.ua": 1,
  "ifm": 1,
  "iglesias-carbonia.it": 1,
  "iglesiascarbonia.it": 1,
  "iheya.okinawa.jp": 1,
  "iida.nagano.jp": 1,
  "iide.yamagata.jp": 1,
  "iijima.nagano.jp": 1,
  "iitate.fukushima.jp": 1,
  "iiyama.nagano.jp": 1,
  "iizuka.fukuoka.jp": 1,
  "iizuna.nagano.jp": 1,
  "ikano": 1,
  "ikaruga.nara.jp": 1,
  "ikata.ehime.jp": 1,
  "ikawa.akita.jp": 1,
  "ikeda.fukui.jp": 1,
  "ikeda.gifu.jp": 1,
  "ikeda.hokkaido.jp": 1,
  "ikeda.nagano.jp": 1,
  "ikeda.osaka.jp": 1,
  "iki.fi": 1,
  "iki.nagasaki.jp": 1,
  "ikoma.nara.jp": 1,
  "ikusaka.nagano.jp": 1,
  "il": 1,
  "il.eu.org": 1,
  "il.us": 1,
  "ilawa.pl": 1,
  "illustration.museum": 1,
  "ilovecollege.info": 1,
  "im": 1,
  "im.it": 1,
  "imabari.ehime.jp": 1,
  "imageandsound.museum": 1,
  "imakane.hokkaido.jp": 1,
  "imamat": 1,
  "imari.saga.jp": 1,
  "imb.br": 1,
  "imdb": 1,
  "imizu.toyama.jp": 1,
  "immo": 1,
  "immobilien": 1,
  "imperia.it": 1,
  "impertrix.com": 1,
  "impertrixcdn.com": 1,
  "in": 1,
  "in-addr.arpa": 1,
  "in-berlin.de": 1,
  "in-brb.de": 1,
  "in-butter.de": 1,
  "in-dsl.de": 1,
  "in-dsl.net": 1,
  "in-dsl.org": 1,
  "in-the-band.net": 1,
  "in-vpn.de": 1,
  "in-vpn.net": 1,
  "in-vpn.org": 1,
  "in.eu.org": 1,
  "in.london": 1,
  "in.na": 1,
  "in.net": 1,
  "in.ni": 1,
  "in.rs": 1,
  "in.th": 1,
  "in.ua": 1,
  "in.us": 1,
  "ina.ibaraki.jp": 1,
  "ina.nagano.jp": 1,
  "ina.saitama.jp": 1,
  "inabe.mie.jp": 1,
  "inagawa.hyogo.jp": 1,
  "inagi.tokyo.jp": 1,
  "inami.toyama.jp": 1,
  "inami.wakayama.jp": 1,
  "inashiki.ibaraki.jp": 1,
  "inatsuki.fukuoka.jp": 1,
  "inawashiro.fukushima.jp": 1,
  "inazawa.aichi.jp": 1,
  "inc": 1,
  "inc.hk": 1,
  "incheon.kr": 1,
  "ind.br": 1,
  "ind.gt": 1,
  "ind.in": 1,
  "ind.kw": 1,
  "ind.tn": 1,
  "inderoy.no": 1,
  "indian.museum": 1,
  "indiana.museum": 1,
  "indianapolis.museum": 1,
  "indianmarket.museum": 1,
  "indie.porn": 1,
  "indigena.bo": 1,
  "industria.bo": 1,
  "industries": 1,
  "ine.kyoto.jp": 1,
  "inf.br": 1,
  "inf.cu": 1,
  "inf.mk": 1,
  "inf.ua": 1,
  "infiniti": 1,
  "info": 1,
  "info.at": 1,
  "info.au": 1,
  "info.az": 1,
  "info.bb": 1,
  "info.bo": 1,
  "info.co": 1,
  "info.cx": 1,
  "info.ec": 1,
  "info.et": 1,
  "info.fj": 1,
  "info.gu": 1,
  "info.ht": 1,
  "info.hu": 1,
  "info.ke": 1,
  "info.ki": 1,
  "info.la": 1,
  "info.ls": 1,
  "info.mv": 1,
  "info.na": 1,
  "info.nf": 1,
  "info.ni": 1,
  "info.nr": 1,
  "info.pk": 1,
  "info.pl": 1,
  "info.pr": 1,
  "info.ro": 1,
  "info.sd": 1,
  "info.tn": 1,
  "info.tr": 1,
  "info.tt": 1,
  "info.tz": 1,
  "info.ve": 1,
  "info.vn": 1,
  "info.zm": 1,
  "ing": 1,
  "ing.pa": 1,
  "ingatlan.hu": 1,
  "ink": 1,
  "ino.kochi.jp": 1,
  "instantcloud.cn": 1,
  "institute": 1,
  "insurance": 1,
  "insurance.aero": 1,
  "insure": 1,
  "int": 1,
  "int.ar": 1,
  "int.az": 1,
  "int.bo": 1,
  "int.ci": 1,
  "int.co": 1,
  "int.eu.org": 1,
  "int.is": 1,
  "int.la": 1,
  "int.lk": 1,
  "int.mv": 1,
  "int.mw": 1,
  "int.ni": 1,
  "int.pt": 1,
  "int.ru": 1,
  "int.tj": 1,
  "int.tt": 1,
  "int.ve": 1,
  "int.vn": 1,
  "intel": 1,
  "intelligence.museum": 1,
  "interactive.museum": 1,
  "international": 1,
  "internet-dns.de": 1,
  "intl.tn": 1,
  "intuit": 1,
  "inuyama.aichi.jp": 1,
  "investments": 1,
  "inzai.chiba.jp": 1,
  "io": 1,
  "io.kg": 1,
  "iobb.net": 1,
  "ip6.arpa": 1,
  "ipifony.net": 1,
  "ipiranga": 1,
  "iq": 1,
  "ir": 1,
  "iraq.museum": 1,
  "iris.arpa": 1,
  "irish": 1,
  "iron.museum": 1,
  "iruma.saitama.jp": 1,
  "is": 1,
  "is-a-anarchist.com": 1,
  "is-a-blogger.com": 1,
  "is-a-bookkeeper.com": 1,
  "is-a-bruinsfan.org": 1,
  "is-a-bulls-fan.com": 1,
  "is-a-candidate.org": 1,
  "is-a-caterer.com": 1,
  "is-a-celticsfan.org": 1,
  "is-a-chef.com": 1,
  "is-a-chef.net": 1,
  "is-a-chef.org": 1,
  "is-a-conservative.com": 1,
  "is-a-cpa.com": 1,
  "is-a-cubicle-slave.com": 1,
  "is-a-democrat.com": 1,
  "is-a-designer.com": 1,
  "is-a-doctor.com": 1,
  "is-a-financialadvisor.com": 1,
  "is-a-geek.com": 1,
  "is-a-geek.net": 1,
  "is-a-geek.org": 1,
  "is-a-green.com": 1,
  "is-a-guru.com": 1,
  "is-a-hard-worker.com": 1,
  "is-a-hunter.com": 1,
  "is-a-knight.org": 1,
  "is-a-landscaper.com": 1,
  "is-a-lawyer.com": 1,
  "is-a-liberal.com": 1,
  "is-a-libertarian.com": 1,
  "is-a-linux-user.org": 1,
  "is-a-llama.com": 1,
  "is-a-musician.com": 1,
  "is-a-nascarfan.com": 1,
  "is-a-nurse.com": 1,
  "is-a-painter.com": 1,
  "is-a-patsfan.org": 1,
  "is-a-personaltrainer.com": 1,
  "is-a-photographer.com": 1,
  "is-a-player.com": 1,
  "is-a-republican.com": 1,
  "is-a-rockstar.com": 1,
  "is-a-socialist.com": 1,
  "is-a-soxfan.org": 1,
  "is-a-student.com": 1,
  "is-a-teacher.com": 1,
  "is-a-techie.com": 1,
  "is-a-therapist.com": 1,
  "is-an-accountant.com": 1,
  "is-an-actor.com": 1,
  "is-an-actress.com": 1,
  "is-an-anarchist.com": 1,
  "is-an-artist.com": 1,
  "is-an-engineer.com": 1,
  "is-an-entertainer.com": 1,
  "is-by.us": 1,
  "is-certified.com": 1,
  "is-found.org": 1,
  "is-gone.com": 1,
  "is-into-anime.com": 1,
  "is-into-cars.com": 1,
  "is-into-cartoons.com": 1,
  "is-into-games.com": 1,
  "is-leet.com": 1,
  "is-lost.org": 1,
  "is-not-certified.com": 1,
  "is-saved.org": 1,
  "is-slick.com": 1,
  "is-uberleet.com": 1,
  "is-very-bad.org": 1,
  "is-very-evil.org": 1,
  "is-very-good.org": 1,
  "is-very-nice.org": 1,
  "is-very-sweet.org": 1,
  "is-with-theband.com": 1,
  "is.eu.org": 1,
  "is.gov.pl": 1,
  "is.it": 1,
  "isa-geek.com": 1,
  "isa-geek.net": 1,
  "isa-geek.org": 1,
  "isa-hockeynut.com": 1,
  "isa.kagoshima.jp": 1,
  "isa.us": 1,
  "isahaya.nagasaki.jp": 1,
  "ise.mie.jp": 1,
  "isehara.kanagawa.jp": 1,
  "isen.kagoshima.jp": 1,
  "isernia.it": 1,
  "iserv.dev": 1,
  "isesaki.gunma.jp": 1,
  "ishigaki.okinawa.jp": 1,
  "ishikari.hokkaido.jp": 1,
  "ishikawa.fukushima.jp": 1,
  "ishikawa.jp": 1,
  "ishikawa.okinawa.jp": 1,
  "ishinomaki.miyagi.jp": 1,
  "isla.pr": 1,
  "isleofman.museum": 1,
  "ismaili": 1,
  "isshiki.aichi.jp": 1,
  "issmarterthanyou.com": 1,
  "ist": 1,
  "istanbul": 1,
  "isteingeek.de": 1,
  "istmein.de": 1,
  "isumi.chiba.jp": 1,
  "it": 1,
  "it.ao": 1,
  "it.eu.org": 1,
  "itabashi.tokyo.jp": 1,
  "itako.ibaraki.jp": 1,
  "itakura.gunma.jp": 1,
  "itami.hyogo.jp": 1,
  "itano.tokushima.jp": 1,
  "itau": 1,
  "itayanagi.aomori.jp": 1,
  "ito.shizuoka.jp": 1,
  "itoigawa.niigata.jp": 1,
  "itoman.okinawa.jp": 1,
  "its.me": 1,
  "itv": 1,
  "ivano-frankivsk.ua": 1,
  "ivanovo.su": 1,
  "iveco": 1,
  "iveland.no": 1,
  "ivgu.no": 1,
  "iwade.wakayama.jp": 1,
  "iwafune.tochigi.jp": 1,
  "iwaizumi.iwate.jp": 1,
  "iwaki.fukushima.jp": 1,
  "iwakuni.yamaguchi.jp": 1,
  "iwakura.aichi.jp": 1,
  "iwama.ibaraki.jp": 1,
  "iwamizawa.hokkaido.jp": 1,
  "iwanai.hokkaido.jp": 1,
  "iwanuma.miyagi.jp": 1,
  "iwata.shizuoka.jp": 1,
  "iwate.iwate.jp": 1,
  "iwate.jp": 1,
  "iwatsuki.saitama.jp": 1,
  "iwi.nz": 1,
  "iyo.ehime.jp": 1,
  "iz.hr": 1,
  "izena.okinawa.jp": 1,
  "izu.shizuoka.jp": 1,
  "izumi.kagoshima.jp": 1,
  "izumi.osaka.jp": 1,
  "izumiotsu.osaka.jp": 1,
  "izumisano.osaka.jp": 1,
  "izumizaki.fukushima.jp": 1,
  "izumo.shimane.jp": 1,
  "izumozaki.niigata.jp": 1,
  "izunokuni.shizuoka.jp": 1,
  "j.bg": 1,
  "j.layershift.co.uk": 1,
  "j.scaleforce.com.cy": 1,
  "jab.br": 1,
  "jaguar": 1,
  "jambyl.su": 1,
  "jamison.museum": 1,
  "jampa.br": 1,
  "jan-mayen.no": 1,
  "java": 1,
  "jaworzno.pl": 1,
  "jcb": 1,
  "jcloud.ik-server.com": 1,
  "jcp": 1,
  "jdevcloud.com": 1,
  "jdf.br": 1,
  "je": 1,
  "jeep": 1,
  "jefferson.museum": 1,
  "jeju.kr": 1,
  "jelastic.regruhosting.ru": 1,
  "jelastic.saveincloud.net": 1,
  "jelastic.team": 1,
  "jele.cloud": 1,
  "jele.club": 1,
  "jele.host": 1,
  "jele.io": 1,
  "jele.site": 1,
  "jelenia-gora.pl": 1,
  "jeonbuk.kr": 1,
  "jeonnam.kr": 1,
  "jerusalem.museum": 1,
  "jessheim.no": 1,
  "jetzt": 1,
  "jevnaker.no": 1,
  "jewelry": 1,
  "jewelry.museum": 1,
  "jewish.museum": 1,
  "jewishart.museum": 1,
  "jfk.museum": 1,
  "jgora.pl": 1,
  "jinsekikogen.hiroshima.jp": 1,
  "jio": 1,
  "jl.cn": 1,
  "jll": 1,
  "jls-sto1.elastx.net": 1,
  "jmp": 1,
  "jnj": 1,
  "jo": 1,
  "joboji.iwate.jp": 1,
  "jobs": 1,
  "jobs.tt": 1,
  "joburg": 1,
  "joetsu.niigata.jp": 1,
  "jogasz.hu": 1,
  "johana.toyama.jp": 1,
  "joinville.br": 1,
  "jolster.no": 1,
  "jondal.no": 1,
  "jor.br": 1,
  "jorpeland.no": 1,
  "joso.ibaraki.jp": 1,
  "jot": 1,
  "journal.aero": 1,
  "journalism.museum": 1,
  "journalist.aero": 1,
  "joy": 1,
  "joyo.kyoto.jp": 1,
  "jp": 1,
  "jp.eu.org": 1,
  "jp.kg": 1,
  "jp.md": 1,
  "jp.net": 1,
  "jpmorgan": 1,
  "jpn.com": 1,
  "jprs": 1,
  "js.cn": 1,
  "js.org": 1,
  "judaica.museum": 1,
  "judygarland.museum": 1,
  "juedisches.museum": 1,
  "juegos": 1,
  "juif.museum": 1,
  "juniper": 1,
  "jur.pro": 1,
  "jus.br": 1,
  "jx.cn": 1,
  "k.bg": 1,
  "k.se": 1,
  "k12.ak.us": 1,
  "k12.al.us": 1,
  "k12.ar.us": 1,
  "k12.as.us": 1,
  "k12.az.us": 1,
  "k12.ca.us": 1,
  "k12.co.us": 1,
  "k12.ct.us": 1,
  "k12.dc.us": 1,
  "k12.de.us": 1,
  "k12.ec": 1,
  "k12.fl.us": 1,
  "k12.ga.us": 1,
  "k12.gu.us": 1,
  "k12.ia.us": 1,
  "k12.id.us": 1,
  "k12.il": 1,
  "k12.il.us": 1,
  "k12.in.us": 1,
  "k12.ks.us": 1,
  "k12.ky.us": 1,
  "k12.la.us": 1,
  "k12.ma.us": 1,
  "k12.md.us": 1,
  "k12.me.us": 1,
  "k12.mi.us": 1,
  "k12.mn.us": 1,
  "k12.mo.us": 1,
  "k12.ms.us": 1,
  "k12.mt.us": 1,
  "k12.nc.us": 1,
  "k12.ne.us": 1,
  "k12.nh.us": 1,
  "k12.nj.us": 1,
  "k12.nm.us": 1,
  "k12.nv.us": 1,
  "k12.ny.us": 1,
  "k12.oh.us": 1,
  "k12.ok.us": 1,
  "k12.or.us": 1,
  "k12.pa.us": 1,
  "k12.pr.us": 1,
  "k12.sc.us": 1,
  "k12.tn.us": 1,
  "k12.tr": 1,
  "k12.tx.us": 1,
  "k12.ut.us": 1,
  "k12.va.us": 1,
  "k12.vi": 1,
  "k12.vi.us": 1,
  "k12.vt.us": 1,
  "k12.wa.us": 1,
  "k12.wi.us": 1,
  "k12.wy.us": 1,
  "kaas.gg": 1,
  "kadena.okinawa.jp": 1,
  "kadogawa.miyazaki.jp": 1,
  "kadoma.osaka.jp": 1,
  "kafjord.no": 1,
  "kaga.ishikawa.jp": 1,
  "kagami.kochi.jp": 1,
  "kagamiishi.fukushima.jp": 1,
  "kagamino.okayama.jp": 1,
  "kagawa.jp": 1,
  "kagoshima.jp": 1,
  "kagoshima.kagoshima.jp": 1,
  "kaho.fukuoka.jp": 1,
  "kahoku.ishikawa.jp": 1,
  "kahoku.yamagata.jp": 1,
  "kai.yamanashi.jp": 1,
  "kainan.tokushima.jp": 1,
  "kainan.wakayama.jp": 1,
  "kaisei.kanagawa.jp": 1,
  "kaita.hiroshima.jp": 1,
  "kaizuka.osaka.jp": 1,
  "kakamigahara.gifu.jp": 1,
  "kakegawa.shizuoka.jp": 1,
  "kakinoki.shimane.jp": 1,
  "kakogawa.hyogo.jp": 1,
  "kakuda.miyagi.jp": 1,
  "kalisz.pl": 1,
  "kalmykia.ru": 1,
  "kalmykia.su": 1,
  "kaluga.su": 1,
  "kamagaya.chiba.jp": 1,
  "kamaishi.iwate.jp": 1,
  "kamakura.kanagawa.jp": 1,
  "kameoka.kyoto.jp": 1,
  "kameyama.mie.jp": 1,
  "kami.kochi.jp": 1,
  "kami.miyagi.jp": 1,
  "kamiamakusa.kumamoto.jp": 1,
  "kamifurano.hokkaido.jp": 1,
  "kamigori.hyogo.jp": 1,
  "kamiichi.toyama.jp": 1,
  "kamiizumi.saitama.jp": 1,
  "kamijima.ehime.jp": 1,
  "kamikawa.hokkaido.jp": 1,
  "kamikawa.hyogo.jp": 1,
  "kamikawa.saitama.jp": 1,
  "kamikitayama.nara.jp": 1,
  "kamikoani.akita.jp": 1,
  "kamimine.saga.jp": 1,
  "kaminokawa.tochigi.jp": 1,
  "kaminoyama.yamagata.jp": 1,
  "kamioka.akita.jp": 1,
  "kamisato.saitama.jp": 1,
  "kamishihoro.hokkaido.jp": 1,
  "kamisu.ibaraki.jp": 1,
  "kamisunagawa.hokkaido.jp": 1,
  "kamitonda.wakayama.jp": 1,
  "kamitsue.oita.jp": 1,
  "kamo.kyoto.jp": 1,
  "kamo.niigata.jp": 1,
  "kamoenai.hokkaido.jp": 1,
  "kamogawa.chiba.jp": 1,
  "kanagawa.jp": 1,
  "kanan.osaka.jp": 1,
  "kanazawa.ishikawa.jp": 1,
  "kanegasaki.iwate.jp": 1,
  "kaneyama.fukushima.jp": 1,
  "kaneyama.yamagata.jp": 1,
  "kani.gifu.jp": 1,
  "kanie.aichi.jp": 1,
  "kanmaki.nara.jp": 1,
  "kanna.gunma.jp": 1,
  "kannami.shizuoka.jp": 1,
  "kanonji.kagawa.jp": 1,
  "kanoya.kagoshima.jp": 1,
  "kanra.gunma.jp": 1,
  "kanuma.tochigi.jp": 1,
  "kanzaki.saga.jp": 1,
  "karacol.su": 1,
  "karaganda.su": 1,
  "karasjohka.no": 1,
  "karasjok.no": 1,
  "karasuyama.tochigi.jp": 1,
  "karate.museum": 1,
  "karatsu.saga.jp": 1,
  "karelia.su": 1,
  "karikatur.museum": 1,
  "kariwa.niigata.jp": 1,
  "kariya.aichi.jp": 1,
  "karlsoy.no": 1,
  "karmoy.no": 1,
  "karpacz.pl": 1,
  "kartuzy.pl": 1,
  "karuizawa.nagano.jp": 1,
  "karumai.iwate.jp": 1,
  "kasahara.gifu.jp": 1,
  "kasai.hyogo.jp": 1,
  "kasama.ibaraki.jp": 1,
  "kasamatsu.gifu.jp": 1,
  "kasaoka.okayama.jp": 1,
  "kashiba.nara.jp": 1,
  "kashihara.nara.jp": 1,
  "kashima.ibaraki.jp": 1,
  "kashima.saga.jp": 1,
  "kashiwa.chiba.jp": 1,
  "kashiwara.osaka.jp": 1,
  "kashiwazaki.niigata.jp": 1,
  "kasserver.com": 1,
  "kasuga.fukuoka.jp": 1,
  "kasuga.hyogo.jp": 1,
  "kasugai.aichi.jp": 1,
  "kasukabe.saitama.jp": 1,
  "kasumigaura.ibaraki.jp": 1,
  "kasuya.fukuoka.jp": 1,
  "kaszuby.pl": 1,
  "katagami.akita.jp": 1,
  "katano.osaka.jp": 1,
  "katashina.gunma.jp": 1,
  "katori.chiba.jp": 1,
  "katowice.pl": 1,
  "katsuragi.nara.jp": 1,
  "katsuragi.wakayama.jp": 1,
  "katsushika.tokyo.jp": 1,
  "katsuura.chiba.jp": 1,
  "katsuyama.fukui.jp": 1,
  "kaufen": 1,
  "kautokeino.no": 1,
  "kawaba.gunma.jp": 1,
  "kawachinagano.osaka.jp": 1,
  "kawagoe.mie.jp": 1,
  "kawagoe.saitama.jp": 1,
  "kawaguchi.saitama.jp": 1,
  "kawahara.tottori.jp": 1,
  "kawai.iwate.jp": 1,
  "kawai.nara.jp": 1,
  "kawajima.saitama.jp": 1,
  "kawakami.nagano.jp": 1,
  "kawakami.nara.jp": 1,
  "kawakita.ishikawa.jp": 1,
  "kawamata.fukushima.jp": 1,
  "kawaminami.miyazaki.jp": 1,
  "kawanabe.kagoshima.jp": 1,
  "kawanehon.shizuoka.jp": 1,
  "kawanishi.hyogo.jp": 1,
  "kawanishi.nara.jp": 1,
  "kawanishi.yamagata.jp": 1,
  "kawara.fukuoka.jp": 1,
  "kawasaki.miyagi.jp": 1,
  "kawatana.nagasaki.jp": 1,
  "kawaue.gifu.jp": 1,
  "kawazu.shizuoka.jp": 1,
  "kayabe.hokkaido.jp": 1,
  "kazimierz-dolny.pl": 1,
  "kazo.saitama.jp": 1,
  "kazuno.akita.jp": 1,
  "kddi": 1,
  "ke": 1,
  "keisen.fukuoka.jp": 1,
  "kembuchi.hokkaido.jp": 1,
  "kep.tr": 1,
  "kepno.pl": 1,
  "kerryhotels": 1,
  "kerrylogistics": 1,
  "kerryproperties": 1,
  "ketrzyn.pl": 1,
  "keymachine.de": 1,
  "kfh": 1,
  "kg": 1,
  "kg.kr": 1,
  "kh.ua": 1,
  "khakassia.su": 1,
  "kharkiv.ua": 1,
  "kharkov.ua": 1,
  "kherson.ua": 1,
  "khmelnitskiy.ua": 1,
  "khmelnytskyi.ua": 1,
  "khplay.nl": 1,
  "ki": 1,
  "kia": 1,
  "kibichuo.okayama.jp": 1,
  "kicks-ass.net": 1,
  "kicks-ass.org": 1,
  "kids.museum": 1,
  "kids.us": 1,
  "kiev.ua": 1,
  "kiho.mie.jp": 1,
  "kihoku.ehime.jp": 1,
  "kijo.miyazaki.jp": 1,
  "kikonai.hokkaido.jp": 1,
  "kikuchi.kumamoto.jp": 1,
  "kikugawa.shizuoka.jp": 1,
  "kim": 1,
  "kimino.wakayama.jp": 1,
  "kimitsu.chiba.jp": 1,
  "kimobetsu.hokkaido.jp": 1,
  "kin.okinawa.jp": 1,
  "kinder": 1,
  "kindle": 1,
  "kinghost.net": 1,
  "kinko.kagoshima.jp": 1,
  "kinokawa.wakayama.jp": 1,
  "kira.aichi.jp": 1,
  "kirkenes.no": 1,
  "kirovograd.ua": 1,
  "kiryu.gunma.jp": 1,
  "kisarazu.chiba.jp": 1,
  "kishiwada.osaka.jp": 1,
  "kiso.nagano.jp": 1,
  "kisofukushima.nagano.jp": 1,
  "kisosaki.mie.jp": 1,
  "kita.kyoto.jp": 1,
  "kita.osaka.jp": 1,
  "kita.tokyo.jp": 1,
  "kitaaiki.nagano.jp": 1,
  "kitaakita.akita.jp": 1,
  "kitadaito.okinawa.jp": 1,
  "kitagata.gifu.jp": 1,
  "kitagata.saga.jp": 1,
  "kitagawa.kochi.jp": 1,
  "kitagawa.miyazaki.jp": 1,
  "kitahata.saga.jp": 1,
  "kitahiroshima.hokkaido.jp": 1,
  "kitakami.iwate.jp": 1,
  "kitakata.fukushima.jp": 1,
  "kitakata.miyazaki.jp": 1,
  "kitami.hokkaido.jp": 1,
  "kitamoto.saitama.jp": 1,
  "kitanakagusuku.okinawa.jp": 1,
  "kitashiobara.fukushima.jp": 1,
  "kitaura.miyazaki.jp": 1,
  "kitayama.wakayama.jp": 1,
  "kitchen": 1,
  "kiwa.mie.jp": 1,
  "kiwi": 1,
  "kiwi.nz": 1,
  "kiyama.saga.jp": 1,
  "kiyokawa.kanagawa.jp": 1,
  "kiyosato.hokkaido.jp": 1,
  "kiyose.tokyo.jp": 1,
  "kiyosu.aichi.jp": 1,
  "kizu.kyoto.jp": 1,
  "klabu.no": 1,
  "klepp.no": 1,
  "klodzko.pl": 1,
  "km": 1,
  "km.ua": 1,
  "kmpsp.gov.pl": 1,
  "kn": 1,
  "knightpoint.systems": 1,
  "knowsitall.info": 1,
  "knx-server.net": 1,
  "kobayashi.miyazaki.jp": 1,
  "kobierzyce.pl": 1,
  "kochi.jp": 1,
  "kochi.kochi.jp": 1,
  "kodaira.tokyo.jp": 1,
  "koebenhavn.museum": 1,
  "koeln": 1,
  "koeln.museum": 1,
  "kofu.yamanashi.jp": 1,
  "koga.fukuoka.jp": 1,
  "koga.ibaraki.jp": 1,
  "koganei.tokyo.jp": 1,
  "koge.tottori.jp": 1,
  "koka.shiga.jp": 1,
  "kokonoe.oita.jp": 1,
  "kokubunji.tokyo.jp": 1,
  "kolobrzeg.pl": 1,
  "komae.tokyo.jp": 1,
  "komagane.nagano.jp": 1,
  "komaki.aichi.jp": 1,
  "komatsu": 1,
  "komatsu.ishikawa.jp": 1,
  "komatsushima.tokushima.jp": 1,
  "komforb.se": 1,
  "kommunalforbund.se": 1,
  "kommune.no": 1,
  "komono.mie.jp": 1,
  "komoro.nagano.jp": 1,
  "komvux.se": 1,
  "konan.aichi.jp": 1,
  "konan.shiga.jp": 1,
  "kongsberg.no": 1,
  "kongsvinger.no": 1,
  "konin.pl": 1,
  "konskowola.pl": 1,
  "konsulat.gov.pl": 1,
  "konyvelo.hu": 1,
  "koori.fukushima.jp": 1,
  "kopervik.no": 1,
  "koriyama.fukushima.jp": 1,
  "koryo.nara.jp": 1,
  "kosai.shizuoka.jp": 1,
  "kosaka.akita.jp": 1,
  "kosei.shiga.jp": 1,
  "kosher": 1,
  "koshigaya.saitama.jp": 1,
  "koshimizu.hokkaido.jp": 1,
  "koshu.yamanashi.jp": 1,
  "kosuge.yamanashi.jp": 1,
  "kota.aichi.jp": 1,
  "koto.shiga.jp": 1,
  "koto.tokyo.jp": 1,
  "kotohira.kagawa.jp": 1,
  "kotoura.tottori.jp": 1,
  "kouhoku.saga.jp": 1,
  "kounosu.saitama.jp": 1,
  "kouyama.kagoshima.jp": 1,
  "kouzushima.tokyo.jp": 1,
  "koya.wakayama.jp": 1,
  "koza.wakayama.jp": 1,
  "kozagawa.wakayama.jp": 1,
  "kozaki.chiba.jp": 1,
  "kozow.com": 1,
  "kp": 1,
  "kpmg": 1,
  "kpn": 1,
  "kppsp.gov.pl": 1,
  "kr": 1,
  "kr.com": 1,
  "kr.eu.org": 1,
  "kr.it": 1,
  "kr.ua": 1,
  "kraanghke.no": 1,
  "kragero.no": 1,
  "krakow.pl": 1,
  "krasnik.pl": 1,
  "krasnodar.su": 1,
  "krd": 1,
  "kred": 1,
  "kristiansand.no": 1,
  "kristiansund.no": 1,
  "krodsherad.no": 1,
  "krokstadelva.no": 1,
  "krym.ua": 1,
  "ks.ua": 1,
  "ks.us": 1,
  "kuchinotsu.nagasaki.jp": 1,
  "kudamatsu.yamaguchi.jp": 1,
  "kudoyama.wakayama.jp": 1,
  "kui.hiroshima.jp": 1,
  "kuji.iwate.jp": 1,
  "kuju.oita.jp": 1,
  "kujukuri.chiba.jp": 1,
  "kuki.saitama.jp": 1,
  "kumagaya.saitama.jp": 1,
  "kumakogen.ehime.jp": 1,
  "kumamoto.jp": 1,
  "kumamoto.kumamoto.jp": 1,
  "kumano.hiroshima.jp": 1,
  "kumano.mie.jp": 1,
  "kumatori.osaka.jp": 1,
  "kumejima.okinawa.jp": 1,
  "kumenan.okayama.jp": 1,
  "kumiyama.kyoto.jp": 1,
  "kunigami.okinawa.jp": 1,
  "kunimi.fukushima.jp": 1,
  "kunisaki.oita.jp": 1,
  "kunitachi.tokyo.jp": 1,
  "kunitomi.miyazaki.jp": 1,
  "kunneppu.hokkaido.jp": 1,
  "kunohe.iwate.jp": 1,
  "kunst.museum": 1,
  "kunstsammlung.museum": 1,
  "kunstunddesign.museum": 1,
  "kuokgroup": 1,
  "kurashiki.okayama.jp": 1,
  "kurate.fukuoka.jp": 1,
  "kure.hiroshima.jp": 1,
  "kurgan.su": 1,
  "kuriyama.hokkaido.jp": 1,
  "kurobe.toyama.jp": 1,
  "kurogi.fukuoka.jp": 1,
  "kuroishi.aomori.jp": 1,
  "kuroiso.tochigi.jp": 1,
  "kuromatsunai.hokkaido.jp": 1,
  "kurotaki.nara.jp": 1,
  "kurume.fukuoka.jp": 1,
  "kusatsu.gunma.jp": 1,
  "kusatsu.shiga.jp": 1,
  "kushima.miyazaki.jp": 1,
  "kushimoto.wakayama.jp": 1,
  "kushiro.hokkaido.jp": 1,
  "kustanai.ru": 1,
  "kustanai.su": 1,
  "kusu.oita.jp": 1,
  "kutchan.hokkaido.jp": 1,
  "kutno.pl": 1,
  "kuwana.mie.jp": 1,
  "kuzumaki.iwate.jp": 1,
  "kv.ua": 1,
  "kvafjord.no": 1,
  "kvalsund.no": 1,
  "kvam.no": 1,
  "kvanangen.no": 1,
  "kvinesdal.no": 1,
  "kvinnherad.no": 1,
  "kviteseid.no": 1,
  "kvitsoy.no": 1,
  "kw": 1,
  "kwp.gov.pl": 1,
  "kwpsp.gov.pl": 1,
  "ky": 1,
  "ky.us": 1,
  "kyiv.ua": 1,
  "kyonan.chiba.jp": 1,
  "kyotamba.kyoto.jp": 1,
  "kyotanabe.kyoto.jp": 1,
  "kyotango.kyoto.jp": 1,
  "kyoto": 1,
  "kyoto.jp": 1,
  "kyowa.akita.jp": 1,
  "kyowa.hokkaido.jp": 1,
  "kyuragi.saga.jp": 1,
  "kz": 1,
  "l-o-g-i-n.de": 1,
  "l.bg": 1,
  "l.se": 1,
  "la": 1,
  "la-spezia.it": 1,
  "la.us": 1,
  "laakesvuemie.no": 1,
  "lab.ms": 1,
  "labor.museum": 1,
  "labour.museum": 1,
  "lacaixa": 1,
  "lahppi.no": 1,
  "lajolla.museum": 1,
  "lakas.hu": 1,
  "lamborghini": 1,
  "lamer": 1,
  "lanbib.se": 1,
  "lancashire.museum": 1,
  "lancaster": 1,
  "lancia": 1,
  "land": 1,
  "land-4-sale.us": 1,
  "landes.museum": 1,
  "landrover": 1,
  "langevag.no": 1,
  "lans.museum": 1,
  "lanxess": 1,
  "lapy.pl": 1,
  "laquila.it": 1,
  "lardal.no": 1,
  "larsson.museum": 1,
  "larvik.no": 1,
  "lasalle": 1,
  "laspezia.it": 1,
  "lat": 1,
  "latina.it": 1,
  "latino": 1,
  "latrobe": 1,
  "lavagis.no": 1,
  "lavangen.no": 1,
  "law": 1,
  "law.pro": 1,
  "law.za": 1,
  "lawyer": 1,
  "laz.it": 1,
  "lazio.it": 1,
  "lb": 1,
  "lc": 1,
  "lc.it": 1,
  "lcube-server.de": 1,
  "lds": 1,
  "le.it": 1,
  "leadpages.co": 1,
  "leangaviika.no": 1,
  "lease": 1,
  "leasing.aero": 1,
  "lebesby.no": 1,
  "lebork.pl": 1,
  "lebtimnetz.de": 1,
  "lecce.it": 1,
  "lecco.it": 1,
  "leclerc": 1,
  "leczna.pl": 1,
  "lefrak": 1,
  "leg.br": 1,
  "legal": 1,
  "legnica.pl": 1,
  "lego": 1,
  "leikanger.no": 1,
  "leirfjord.no": 1,
  "leirvik.no": 1,
  "leitungsen.de": 1,
  "leka.no": 1,
  "leksvik.no": 1,
  "lel.br": 1,
  "lelux.site": 1,
  "lenug.su": 1,
  "lenvik.no": 1,
  "lerdal.no": 1,
  "lesja.no": 1,
  "levanger.no": 1,
  "lewismiller.museum": 1,
  "lexus": 1,
  "lezajsk.pl": 1,
  "lg.jp": 1,
  "lg.ua": 1,
  "lgbt": 1,
  "li": 1,
  "li.it": 1,
  "lib.ak.us": 1,
  "lib.al.us": 1,
  "lib.ar.us": 1,
  "lib.as.us": 1,
  "lib.az.us": 1,
  "lib.ca.us": 1,
  "lib.co.us": 1,
  "lib.ct.us": 1,
  "lib.dc.us": 1,
  "lib.de.us": 1,
  "lib.ee": 1,
  "lib.fl.us": 1,
  "lib.ga.us": 1,
  "lib.gu.us": 1,
  "lib.hi.us": 1,
  "lib.ia.us": 1,
  "lib.id.us": 1,
  "lib.il.us": 1,
  "lib.in.us": 1,
  "lib.ks.us": 1,
  "lib.ky.us": 1,
  "lib.la.us": 1,
  "lib.ma.us": 1,
  "lib.md.us": 1,
  "lib.me.us": 1,
  "lib.mi.us": 1,
  "lib.mn.us": 1,
  "lib.mo.us": 1,
  "lib.ms.us": 1,
  "lib.mt.us": 1,
  "lib.nc.us": 1,
  "lib.nd.us": 1,
  "lib.ne.us": 1,
  "lib.nh.us": 1,
  "lib.nj.us": 1,
  "lib.nm.us": 1,
  "lib.nv.us": 1,
  "lib.ny.us": 1,
  "lib.oh.us": 1,
  "lib.ok.us": 1,
  "lib.or.us": 1,
  "lib.pa.us": 1,
  "lib.pr.us": 1,
  "lib.ri.us": 1,
  "lib.sc.us": 1,
  "lib.sd.us": 1,
  "lib.tn.us": 1,
  "lib.tx.us": 1,
  "lib.ut.us": 1,
  "lib.va.us": 1,
  "lib.vi.us": 1,
  "lib.vt.us": 1,
  "lib.wa.us": 1,
  "lib.wi.us": 1,
  "lib.wy.us": 1,
  "lidl": 1,
  "lier.no": 1,
  "lierne.no": 1,
  "life": 1,
  "lifeinsurance": 1,
  "lifestyle": 1,
  "lig.it": 1,
  "lighting": 1,
  "liguria.it": 1,
  "like": 1,
  "likes-pie.com": 1,
  "likescandy.com": 1,
  "lillehammer.no": 1,
  "lillesand.no": 1,
  "lilly": 1,
  "lima-city.at": 1,
  "lima-city.ch": 1,
  "lima-city.de": 1,
  "lima-city.rocks": 1,
  "lima.zone": 1,
  "limanowa.pl": 1,
  "limited": 1,
  "limo": 1,
  "lincoln": 1,
  "lincoln.museum": 1,
  "lindas.no": 1,
  "linde": 1,
  "lindesnes.no": 1,
  "link": 1,
  "linkitools.space": 1,
  "linkyard-cloud.ch": 1,
  "linkyard.cloud": 1,
  "linz.museum": 1,
  "lipsy": 1,
  "live": 1,
  "living": 1,
  "living.museum": 1,
  "livinghistory.museum": 1,
  "livorno.it": 1,
  "lixil": 1,
  "lk": 1,
  "llc": 1,
  "llp": 1,
  "ln.cn": 1,
  "lo.it": 1,
  "loabat.no": 1,
  "loan": 1,
  "loans": 1,
  "localhistory.museum": 1,
  "localhost.daplie.me": 1,
  "locker": 1,
  "locus": 1,
  "lodi.it": 1,
  "lodingen.no": 1,
  "loft": 1,
  "log.br": 1,
  "loginline.app": 1,
  "loginline.dev": 1,
  "loginline.io": 1,
  "loginline.services": 1,
  "loginline.site": 1,
  "loginto.me": 1,
  "logistics.aero": 1,
  "logoip.com": 1,
  "logoip.de": 1,
  "lol": 1,
  "lolipop.io": 1,
  "lom.it": 1,
  "lom.no": 1,
  "lombardia.it": 1,
  "lombardy.it": 1,
  "lomza.pl": 1,
  "london": 1,
  "london.cloudapps.digital": 1,
  "london.museum": 1,
  "londrina.br": 1,
  "loppa.no": 1,
  "lorenskog.no": 1,
  "losangeles.museum": 1,
  "loseyourip.com": 1,
  "loten.no": 1,
  "lotte": 1,
  "lotto": 1,
  "louvre.museum": 1,
  "love": 1,
  "lowicz.pl": 1,
  "loyalist.museum": 1,
  "lpages.co": 1,
  "lpl": 1,
  "lplfinancial": 1,
  "lpusercontent.com": 1,
  "lr": 1,
  "ls": 1,
  "lt": 1,
  "lt.eu.org": 1,
  "lt.it": 1,
  "lt.ua": 1,
  "ltd": 1,
  "ltd.co.im": 1,
  "ltd.cy": 1,
  "ltd.gi": 1,
  "ltd.hk": 1,
  "ltd.lk": 1,
  "ltd.ng": 1,
  "ltd.ua": 1,
  "ltd.uk": 1,
  "ltda": 1,
  "lu": 1,
  "lu.eu.org": 1,
  "lu.it": 1,
  "lubartow.pl": 1,
  "lubin.pl": 1,
  "lublin.pl": 1,
  "lucania.it": 1,
  "lucca.it": 1,
  "lucerne.museum": 1,
  "lug.org.uk": 1,
  "lugansk.ua": 1,
  "lugs.org.uk": 1,
  "lukow.pl": 1,
  "lund.no": 1,
  "lundbeck": 1,
  "lunner.no": 1,
  "lupin": 1,
  "luroy.no": 1,
  "luster.no": 1,
  "lutsk.ua": 1,
  "luxe": 1,
  "luxembourg.museum": 1,
  "luxury": 1,
  "luzern.museum": 1,
  "lv": 1,
  "lv.eu.org": 1,
  "lv.ua": 1,
  "lviv.ua": 1,
  "ly": 1,
  "lyngdal.no": 1,
  "lyngen.no": 1,
  "lynx.mythic-beasts.com": 1,
  "m.bg": 1,
  "m.se": 1,
  "ma": 1,
  "ma.gov.br": 1,
  "ma.leg.br": 1,
  "ma.us": 1,
  "macapa.br": 1,
  "maceio.br": 1,
  "macerata.it": 1,
  "machida.tokyo.jp": 1,
  "macys": 1,
  "mad.museum": 1,
  "madrid": 1,
  "madrid.museum": 1,
  "maebashi.gunma.jp": 1,
  "magazine.aero": 1,
  "maibara.shiga.jp": 1,
  "maif": 1,
  "mail.pl": 1,
  "maintenance.aero": 1,
  "maison": 1,
  "maizuru.kyoto.jp": 1,
  "makeup": 1,
  "makinohara.shizuoka.jp": 1,
  "makurazaki.kagoshima.jp": 1,
  "malatvuopmi.no": 1,
  "malbork.pl": 1,
  "mallorca.museum": 1,
  "malopolska.pl": 1,
  "malselv.no": 1,
  "malvik.no": 1,
  "mamurogawa.yamagata.jp": 1,
  "man": 1,
  "management": 1,
  "manaus.br": 1,
  "manchester.museum": 1,
  "mandal.no": 1,
  "mango": 1,
  "mangyshlak.su": 1,
  "maniwa.okayama.jp": 1,
  "manno.kagawa.jp": 1,
  "mansion.museum": 1,
  "mansions.museum": 1,
  "mantova.it": 1,
  "manx.museum": 1,
  "maori.nz": 1,
  "map": 1,
  "map.fastly.net": 1,
  "map.fastlylb.net": 1,
  "mar.it": 1,
  "marburg.museum": 1,
  "marche.it": 1,
  "marine.ru": 1,
  "maringa.br": 1,
  "maritime.museum": 1,
  "maritimo.museum": 1,
  "marker.no": 1,
  "market": 1,
  "marketing": 1,
  "markets": 1,
  "marnardal.no": 1,
  "marriott": 1,
  "marshalls": 1,
  "marugame.kagawa.jp": 1,
  "marumori.miyagi.jp": 1,
  "maryland.museum": 1,
  "marylhurst.museum": 1,
  "masaki.ehime.jp": 1,
  "maserati": 1,
  "masfjorden.no": 1,
  "mashike.hokkaido.jp": 1,
  "mashiki.kumamoto.jp": 1,
  "mashiko.tochigi.jp": 1,
  "masoy.no": 1,
  "massa-carrara.it": 1,
  "massacarrara.it": 1,
  "masuda.shimane.jp": 1,
  "mat.br": 1,
  "matera.it": 1,
  "matsubara.osaka.jp": 1,
  "matsubushi.saitama.jp": 1,
  "matsuda.kanagawa.jp": 1,
  "matsudo.chiba.jp": 1,
  "matsue.shimane.jp": 1,
  "matsukawa.nagano.jp": 1,
  "matsumae.hokkaido.jp": 1,
  "matsumoto.kagoshima.jp": 1,
  "matsumoto.nagano.jp": 1,
  "matsuno.ehime.jp": 1,
  "matsusaka.mie.jp": 1,
  "matsushige.tokushima.jp": 1,
  "matsushima.miyagi.jp": 1,
  "matsuura.nagasaki.jp": 1,
  "matsuyama.ehime.jp": 1,
  "matsuzaki.shizuoka.jp": 1,
  "matta-varjjat.no": 1,
  "mattel": 1,
  "mayfirst.info": 1,
  "mayfirst.org": 1,
  "mazowsze.pl": 1,
  "mazury.pl": 1,
  "mb.ca": 1,
  "mb.it": 1,
  "mba": 1,
  "mc": 1,
  "mc.ax": 1,
  "mc.eu.org": 1,
  "mc.it": 1,
  "mcdir.ru": 1,
  "mckinsey": 1,
  "md": 1,
  "md.ci": 1,
  "md.us": 1,
  "me": 1,
  "me.eu.org": 1,
  "me.it": 1,
  "me.ke": 1,
  "me.so": 1,
  "me.tc": 1,
  "me.tz": 1,
  "me.uk": 1,
  "me.us": 1,
  "me.vu": 1,
  "med": 1,
  "med.br": 1,
  "med.ec": 1,
  "med.ee": 1,
  "med.ht": 1,
  "med.ly": 1,
  "med.om": 1,
  "med.pa": 1,
  "med.pl": 1,
  "med.pro": 1,
  "med.sa": 1,
  "med.sd": 1,
  "medecin.fr": 1,
  "medecin.km": 1,
  "media": 1,
  "media.aero": 1,
  "media.hu": 1,
  "media.museum": 1,
  "media.pl": 1,
  "medical.museum": 1,
  "medicina.bo": 1,
  "medio-campidano.it": 1,
  "mediocampidano.it": 1,
  "medizinhistorisches.museum": 1,
  "meeres.museum": 1,
  "meet": 1,
  "meguro.tokyo.jp": 1,
  "mein-iserv.de": 1,
  "mein-vigor.de": 1,
  "meinforum.net": 1,
  "meiwa.gunma.jp": 1,
  "meiwa.mie.jp": 1,
  "meland.no": 1,
  "melbourne": 1,
  "meldal.no": 1,
  "melhus.no": 1,
  "meloy.no": 1,
  "members.linode.com": 1,
  "meme": 1,
  "memorial": 1,
  "memorial.museum": 1,
  "memset.net": 1,
  "men": 1,
  "menu": 1,
  "meraker.no": 1,
  "merckmsd": 1,
  "merseine.nu": 1,
  "mesaverde.museum": 1,
  "messina.it": 1,
  "meteorapp.com": 1,
  "metlife": 1,
  "mex.com": 1,
  "mg": 1,
  "mg.gov.br": 1,
  "mg.leg.br": 1,
  "mh": 1,
  "mi.it": 1,
  "mi.th": 1,
  "mi.us": 1,
  "miami": 1,
  "miasa.nagano.jp": 1,
  "miasta.pl": 1,
  "mibu.tochigi.jp": 1,
  "michigan.museum": 1,
  "microlight.aero": 1,
  "microsoft": 1,
  "midatlantic.museum": 1,
  "midori.chiba.jp": 1,
  "midori.gunma.jp": 1,
  "midsund.no": 1,
  "midtre-gauldal.no": 1,
  "mie.jp": 1,
  "mielec.pl": 1,
  "mielno.pl": 1,
  "mifune.kumamoto.jp": 1,
  "mihama.aichi.jp": 1,
  "mihama.chiba.jp": 1,
  "mihama.fukui.jp": 1,
  "mihama.mie.jp": 1,
  "mihama.wakayama.jp": 1,
  "mihara.hiroshima.jp": 1,
  "mihara.kochi.jp": 1,
  "miharu.fukushima.jp": 1,
  "miho.ibaraki.jp": 1,
  "mikasa.hokkaido.jp": 1,
  "mikawa.yamagata.jp": 1,
  "miki.hyogo.jp": 1,
  "mil": 1,
  "mil.ac": 1,
  "mil.ae": 1,
  "mil.al": 1,
  "mil.ar": 1,
  "mil.az": 1,
  "mil.ba": 1,
  "mil.bo": 1,
  "mil.br": 1,
  "mil.by": 1,
  "mil.cl": 1,
  "mil.cn": 1,
  "mil.co": 1,
  "mil.do": 1,
  "mil.ec": 1,
  "mil.eg": 1,
  "mil.fj": 1,
  "mil.ge": 1,
  "mil.gh": 1,
  "mil.gt": 1,
  "mil.hn": 1,
  "mil.id": 1,
  "mil.in": 1,
  "mil.iq": 1,
  "mil.jo": 1,
  "mil.kg": 1,
  "mil.km": 1,
  "mil.kr": 1,
  "mil.kz": 1,
  "mil.lv": 1,
  "mil.mg": 1,
  "mil.mv": 1,
  "mil.my": 1,
  "mil.mz": 1,
  "mil.ng": 1,
  "mil.ni": 1,
  "mil.no": 1,
  "mil.nz": 1,
  "mil.pe": 1,
  "mil.ph": 1,
  "mil.pl": 1,
  "mil.py": 1,
  "mil.qa": 1,
  "mil.ru": 1,
  "mil.rw": 1,
  "mil.sh": 1,
  "mil.st": 1,
  "mil.sy": 1,
  "mil.tj": 1,
  "mil.tm": 1,
  "mil.to": 1,
  "mil.tr": 1,
  "mil.tw": 1,
  "mil.tz": 1,
  "mil.uy": 1,
  "mil.vc": 1,
  "mil.ve": 1,
  "mil.za": 1,
  "mil.zm": 1,
  "mil.zw": 1,
  "milan.it": 1,
  "milano.it": 1,
  "military.museum": 1,
  "mill.museum": 1,
  "mima.tokushima.jp": 1,
  "mimata.miyazaki.jp": 1,
  "minakami.gunma.jp": 1,
  "minamata.kumamoto.jp": 1,
  "minami-alps.yamanashi.jp": 1,
  "minami.fukuoka.jp": 1,
  "minami.kyoto.jp": 1,
  "minami.tokushima.jp": 1,
  "minamiaiki.nagano.jp": 1,
  "minamiashigara.kanagawa.jp": 1,
  "minamiawaji.hyogo.jp": 1,
  "minamiboso.chiba.jp": 1,
  "minamidaito.okinawa.jp": 1,
  "minamiechizen.fukui.jp": 1,
  "minamifurano.hokkaido.jp": 1,
  "minamiise.mie.jp": 1,
  "minamiizu.shizuoka.jp": 1,
  "minamimaki.nagano.jp": 1,
  "minamiminowa.nagano.jp": 1,
  "minamioguni.kumamoto.jp": 1,
  "minamisanriku.miyagi.jp": 1,
  "minamitane.kagoshima.jp": 1,
  "minamiuonuma.niigata.jp": 1,
  "minamiyamashiro.kyoto.jp": 1,
  "minano.saitama.jp": 1,
  "minato.osaka.jp": 1,
  "minato.tokyo.jp": 1,
  "mincom.tn": 1,
  "mine.nu": 1,
  "miners.museum": 1,
  "mini": 1,
  "mining.museum": 1,
  "miniserver.com": 1,
  "minnesota.museum": 1,
  "mino.gifu.jp": 1,
  "minobu.yamanashi.jp": 1,
  "minoh.osaka.jp": 1,
  "minokamo.gifu.jp": 1,
  "minowa.nagano.jp": 1,
  "mint": 1,
  "mintere.site": 1,
  "mircloud.host": 1,
  "misaki.okayama.jp": 1,
  "misaki.osaka.jp": 1,
  "misasa.tottori.jp": 1,
  "misato.akita.jp": 1,
  "misato.miyagi.jp": 1,
  "misato.saitama.jp": 1,
  "misato.shimane.jp": 1,
  "misato.wakayama.jp": 1,
  "misawa.aomori.jp": 1,
  "misconfused.org": 1,
  "mishima.fukushima.jp": 1,
  "mishima.shizuoka.jp": 1,
  "missile.museum": 1,
  "missoula.museum": 1,
  "misugi.mie.jp": 1,
  "mit": 1,
  "mitaka.tokyo.jp": 1,
  "mitake.gifu.jp": 1,
  "mitane.akita.jp": 1,
  "mito.ibaraki.jp": 1,
  "mitou.yamaguchi.jp": 1,
  "mitoyo.kagawa.jp": 1,
  "mitsubishi": 1,
  "mitsue.nara.jp": 1,
  "mitsuke.niigata.jp": 1,
  "miura.kanagawa.jp": 1,
  "miyada.nagano.jp": 1,
  "miyagi.jp": 1,
  "miyake.nara.jp": 1,
  "miyako.fukuoka.jp": 1,
  "miyako.iwate.jp": 1,
  "miyakonojo.miyazaki.jp": 1,
  "miyama.fukuoka.jp": 1,
  "miyama.mie.jp": 1,
  "miyashiro.saitama.jp": 1,
  "miyawaka.fukuoka.jp": 1,
  "miyazaki.jp": 1,
  "miyazaki.miyazaki.jp": 1,
  "miyazu.kyoto.jp": 1,
  "miyoshi.aichi.jp": 1,
  "miyoshi.hiroshima.jp": 1,
  "miyoshi.saitama.jp": 1,
  "miyoshi.tokushima.jp": 1,
  "miyota.nagano.jp": 1,
  "mizuho.tokyo.jp": 1,
  "mizumaki.fukuoka.jp": 1,
  "mizunami.gifu.jp": 1,
  "mizusawa.iwate.jp": 1,
  "mjondalen.no": 1,
  "mk": 1,
  "mk.eu.org": 1,
  "mk.ua": 1,
  "ml": 1,
  "mlb": 1,
  "mlbfan.org": 1,
  "mls": 1,
  "mma": 1,
  "mmafan.biz": 1,
  "mn": 1,
  "mn.it": 1,
  "mn.us": 1,
  "mo": 1,
  "mo-i-rana.no": 1,
  "mo-siemens.io": 1,
  "mo.cn": 1,
  "mo.it": 1,
  "mo.us": 1,
  "moareke.no": 1,
  "mobara.chiba.jp": 1,
  "mobi": 1,
  "mobi.gp": 1,
  "mobi.ke": 1,
  "mobi.na": 1,
  "mobi.ng": 1,
  "mobi.tt": 1,
  "mobi.tz": 1,
  "mobile": 1,
  "mochizuki.nagano.jp": 1,
  "mod.gi": 1,
  "moda": 1,
  "modalen.no": 1,
  "modelling.aero": 1,
  "modena.it": 1,
  "modern.museum": 1,
  "modum.no": 1,
  "moe": 1,
  "moi": 1,
  "moka.tochigi.jp": 1,
  "mol.it": 1,
  "molde.no": 1,
  "molise.it": 1,
  "mom": 1,
  "moma.museum": 1,
  "mombetsu.hokkaido.jp": 1,
  "monash": 1,
  "money": 1,
  "money.museum": 1,
  "monmouth.museum": 1,
  "monster": 1,
  "monticello.museum": 1,
  "montreal.museum": 1,
  "monza-brianza.it": 1,
  "monza-e-della-brianza.it": 1,
  "monza.it": 1,
  "monzabrianza.it": 1,
  "monzaebrianza.it": 1,
  "monzaedellabrianza.it": 1,
  "moonscale.net": 1,
  "mordovia.ru": 1,
  "mordovia.su": 1,
  "morena.br": 1,
  "moriguchi.osaka.jp": 1,
  "morimachi.shizuoka.jp": 1,
  "morioka.iwate.jp": 1,
  "moriya.ibaraki.jp": 1,
  "moriyama.shiga.jp": 1,
  "moriyoshi.akita.jp": 1,
  "mormon": 1,
  "morotsuka.miyazaki.jp": 1,
  "moroyama.saitama.jp": 1,
  "mortgage": 1,
  "moscow": 1,
  "moscow.museum": 1,
  "moseushi.hokkaido.jp": 1,
  "mosjoen.no": 1,
  "moskenes.no": 1,
  "moss.no": 1,
  "mosvik.no": 1,
  "motegi.tochigi.jp": 1,
  "moto": 1,
  "motobu.okinawa.jp": 1,
  "motorcycle.museum": 1,
  "motorcycles": 1,
  "motosu.gifu.jp": 1,
  "motoyama.kochi.jp": 1,
  "mov": 1,
  "movie": 1,
  "movimiento.bo": 1,
  "mozilla-iot.org": 1,
  "mp": 1,
  "mp.br": 1,
  "mq": 1,
  "mr": 1,
  "mr.no": 1,
  "mragowo.pl": 1,
  "ms": 1,
  "ms.gov.br": 1,
  "ms.it": 1,
  "ms.kr": 1,
  "ms.leg.br": 1,
  "ms.us": 1,
  "msd": 1,
  "msk.ru": 1,
  "msk.su": 1,
  "mt": 1,
  "mt.eu.org": 1,
  "mt.gov.br": 1,
  "mt.it": 1,
  "mt.leg.br": 1,
  "mt.us": 1,
  "mtn": 1,
  "mtr": 1,
  "mu": 1,
  "muenchen.museum": 1,
  "muenster.museum": 1,
  "mugi.tokushima.jp": 1,
  "muika.niigata.jp": 1,
  "mukawa.hokkaido.jp": 1,
  "muko.kyoto.jp": 1,
  "mulhouse.museum": 1,
  "munakata.fukuoka.jp": 1,
  "muncie.museum": 1,
  "muni.il": 1,
  "muosat.no": 1,
  "mup.gov.pl": 1,
  "murakami.niigata.jp": 1,
  "murata.miyagi.jp": 1,
  "murayama.yamagata.jp": 1,
  "murmansk.su": 1,
  "muroran.hokkaido.jp": 1,
  "muroto.kochi.jp": 1,
  "mus.br": 1,
  "mus.mi.us": 1,
  "musashimurayama.tokyo.jp": 1,
  "musashino.tokyo.jp": 1,
  "museet.museum": 1,
  "museum": 1,
  "museum.mv": 1,
  "museum.mw": 1,
  "museum.no": 1,
  "museum.om": 1,
  "museum.tt": 1,
  "museumcenter.museum": 1,
  "museumvereniging.museum": 1,
  "music.museum": 1,
  "musica.ar": 1,
  "musica.bo": 1,
  "mutsu.aomori.jp": 1,
  "mutsuzawa.chiba.jp": 1,
  "mutual": 1,
  "mv": 1,
  "mw": 1,
  "mw.gov.pl": 1,
  "mx": 1,
  "mx.na": 1,
  "my": 1,
  "my-firewall.org": 1,
  "my-gateway.de": 1,
  "my-router.de": 1,
  "my-vigor.de": 1,
  "my-wan.de": 1,
  "my.eu.org": 1,
  "my.id": 1,
  "myactivedirectory.com": 1,
  "myasustor.com": 1,
  "mycd.eu": 1,
  "mydatto.com": 1,
  "mydatto.net": 1,
  "myddns.rocks": 1,
  "mydissent.net": 1,
  "mydobiss.com": 1,
  "mydrobo.com": 1,
  "myds.me": 1,
  "myeffect.net": 1,
  "myfast.host": 1,
  "myfast.space": 1,
  "myfirewall.org": 1,
  "myforum.community": 1,
  "myfritz.net": 1,
  "myftp.biz": 1,
  "myftp.org": 1,
  "myhome-server.de": 1,
  "myiphost.com": 1,
  "myjino.ru": 1,
  "mykolaiv.ua": 1,
  "mymailer.com.tw": 1,
  "mymediapc.net": 1,
  "myoko.niigata.jp": 1,
  "mypep.link": 1,
  "mypets.ws": 1,
  "myphotos.cc": 1,
  "mypi.co": 1,
  "mypsx.net": 1,
  "myqnapcloud.com": 1,
  "myravendb.com": 1,
  "mysecuritycamera.com": 1,
  "mysecuritycamera.net": 1,
  "mysecuritycamera.org": 1,
  "myshopblocks.com": 1,
  "mytis.ru": 1,
  "mytuleap.com": 1,
  "myvnc.com": 1,
  "mywire.org": 1,
  "mz": 1,
  "n.bg": 1,
  "n.se": 1,
  "n4t.co": 1,
  "na": 1,
  "na.it": 1,
  "na4u.ru": 1,
  "naamesjevuemie.no": 1,
  "nab": 1,
  "nabari.mie.jp": 1,
  "nachikatsuura.wakayama.jp": 1,
  "nagahama.shiga.jp": 1,
  "nagai.yamagata.jp": 1,
  "nagano.jp": 1,
  "nagano.nagano.jp": 1,
  "naganohara.gunma.jp": 1,
  "nagaoka.niigata.jp": 1,
  "nagaokakyo.kyoto.jp": 1,
  "nagara.chiba.jp": 1,
  "nagareyama.chiba.jp": 1,
  "nagasaki.jp": 1,
  "nagasaki.nagasaki.jp": 1,
  "nagasu.kumamoto.jp": 1,
  "nagato.yamaguchi.jp": 1,
  "nagatoro.saitama.jp": 1,
  "nagawa.nagano.jp": 1,
  "nagi.okayama.jp": 1,
  "nagiso.nagano.jp": 1,
  "nago.okinawa.jp": 1,
  "nagoya": 1,
  "naha.okinawa.jp": 1,
  "nahari.kochi.jp": 1,
  "naie.hokkaido.jp": 1,
  "naka.hiroshima.jp": 1,
  "naka.ibaraki.jp": 1,
  "nakadomari.aomori.jp": 1,
  "nakagawa.fukuoka.jp": 1,
  "nakagawa.hokkaido.jp": 1,
  "nakagawa.nagano.jp": 1,
  "nakagawa.tokushima.jp": 1,
  "nakagusuku.okinawa.jp": 1,
  "nakagyo.kyoto.jp": 1,
  "nakai.kanagawa.jp": 1,
  "nakama.fukuoka.jp": 1,
  "nakamichi.yamanashi.jp": 1,
  "nakamura.kochi.jp": 1,
  "nakaniikawa.toyama.jp": 1,
  "nakano.nagano.jp": 1,
  "nakano.tokyo.jp": 1,
  "nakanojo.gunma.jp": 1,
  "nakanoto.ishikawa.jp": 1,
  "nakasatsunai.hokkaido.jp": 1,
  "nakatane.kagoshima.jp": 1,
  "nakatombetsu.hokkaido.jp": 1,
  "nakatsugawa.gifu.jp": 1,
  "nakayama.yamagata.jp": 1,
  "nakijin.okinawa.jp": 1,
  "naklo.pl": 1,
  "nalchik.ru": 1,
  "nalchik.su": 1,
  "namdalseid.no": 1,
  "name": 1,
  "name.az": 1,
  "name.cy": 1,
  "name.eg": 1,
  "name.et": 1,
  "name.fj": 1,
  "name.hr": 1,
  "name.jo": 1,
  "name.mk": 1,
  "name.mv": 1,
  "name.my": 1,
  "name.na": 1,
  "name.ng": 1,
  "name.pr": 1,
  "name.qa": 1,
  "name.tj": 1,
  "name.tr": 1,
  "name.tt": 1,
  "name.vn": 1,
  "namegata.ibaraki.jp": 1,
  "namegawa.saitama.jp": 1,
  "namerikawa.toyama.jp": 1,
  "namie.fukushima.jp": 1,
  "namikata.ehime.jp": 1,
  "namsos.no": 1,
  "namsskogan.no": 1,
  "nanae.hokkaido.jp": 1,
  "nanao.ishikawa.jp": 1,
  "nanbu.tottori.jp": 1,
  "nanbu.yamanashi.jp": 1,
  "nango.fukushima.jp": 1,
  "nanjo.okinawa.jp": 1,
  "nankoku.kochi.jp": 1,
  "nanmoku.gunma.jp": 1,
  "nannestad.no": 1,
  "nanporo.hokkaido.jp": 1,
  "nantan.kyoto.jp": 1,
  "nanto.toyama.jp": 1,
  "nanyo.yamagata.jp": 1,
  "naoshima.kagawa.jp": 1,
  "naples.it": 1,
  "napoli.it": 1,
  "nara.jp": 1,
  "nara.nara.jp": 1,
  "narashino.chiba.jp": 1,
  "narita.chiba.jp": 1,
  "naroy.no": 1,
  "narusawa.yamanashi.jp": 1,
  "naruto.tokushima.jp": 1,
  "narviika.no": 1,
  "narvik.no": 1,
  "nasu.tochigi.jp": 1,
  "nasushiobara.tochigi.jp": 1,
  "nat.tn": 1,
  "natal.br": 1,
  "national.museum": 1,
  "nationalfirearms.museum": 1,
  "nationalheritage.museum": 1,
  "nationwide": 1,
  "nativeamerican.museum": 1,
  "natori.miyagi.jp": 1,
  "natura": 1,
  "natural.bo": 1,
  "naturalhistory.museum": 1,
  "naturalhistorymuseum.museum": 1,
  "naturalsciences.museum": 1,
  "naturbruksgymn.se": 1,
  "nature.museum": 1,
  "naturhistorisches.museum": 1,
  "natuurwetenschappen.museum": 1,
  "naumburg.museum": 1,
  "naustdal.no": 1,
  "naval.museum": 1,
  "navigation.aero": 1,
  "navoi.su": 1,
  "navuotna.no": 1,
  "navy": 1,
  "nayoro.hokkaido.jp": 1,
  "nb.ca": 1,
  "nba": 1,
  "nc": 1,
  "nc.tr": 1,
  "nc.us": 1,
  "nctu.me": 1,
  "nd.us": 1,
  "ne": 1,
  "ne.jp": 1,
  "ne.ke": 1,
  "ne.kr": 1,
  "ne.pw": 1,
  "ne.tz": 1,
  "ne.ug": 1,
  "ne.us": 1,
  "neat-url.com": 1,
  "nebraska.museum": 1,
  "nec": 1,
  "nedre-eiker.no": 1,
  "neko.am": 1,
  "nemuro.hokkaido.jp": 1,
  "nerdpol.ovh": 1,
  "nerima.tokyo.jp": 1,
  "nes.akershus.no": 1,
  "nes.buskerud.no": 1,
  "nesna.no": 1,
  "nesodden.no": 1,
  "nesoddtangen.no": 1,
  "nesseby.no": 1,
  "nesset.no": 1,
  "net": 1,
  "net-freaks.com": 1,
  "net.ac": 1,
  "net.ae": 1,
  "net.af": 1,
  "net.ag": 1,
  "net.ai": 1,
  "net.al": 1,
  "net.am": 1,
  "net.ar": 1,
  "net.au": 1,
  "net.az": 1,
  "net.ba": 1,
  "net.bb": 1,
  "net.bh": 1,
  "net.bm": 1,
  "net.bn": 1,
  "net.bo": 1,
  "net.br": 1,
  "net.bs": 1,
  "net.bt": 1,
  "net.bz": 1,
  "net.ci": 1,
  "net.cm": 1,
  "net.cn": 1,
  "net.co": 1,
  "net.cu": 1,
  "net.cw": 1,
  "net.cy": 1,
  "net.dm": 1,
  "net.do": 1,
  "net.dz": 1,
  "net.ec": 1,
  "net.eg": 1,
  "net.et": 1,
  "net.eu.org": 1,
  "net.fj": 1,
  "net.ge": 1,
  "net.gg": 1,
  "net.gl": 1,
  "net.gn": 1,
  "net.gp": 1,
  "net.gr": 1,
  "net.gt": 1,
  "net.gu": 1,
  "net.gy": 1,
  "net.hk": 1,
  "net.hn": 1,
  "net.ht": 1,
  "net.id": 1,
  "net.il": 1,
  "net.im": 1,
  "net.in": 1,
  "net.iq": 1,
  "net.ir": 1,
  "net.is": 1,
  "net.je": 1,
  "net.jo": 1,
  "net.kg": 1,
  "net.ki": 1,
  "net.kn": 1,
  "net.kw": 1,
  "net.ky": 1,
  "net.kz": 1,
  "net.la": 1,
  "net.lb": 1,
  "net.lc": 1,
  "net.lk": 1,
  "net.lr": 1,
  "net.ls": 1,
  "net.lv": 1,
  "net.ly": 1,
  "net.ma": 1,
  "net.me": 1,
  "net.mk": 1,
  "net.ml": 1,
  "net.mo": 1,
  "net.ms": 1,
  "net.mt": 1,
  "net.mu": 1,
  "net.mv": 1,
  "net.mw": 1,
  "net.mx": 1,
  "net.my": 1,
  "net.mz": 1,
  "net.nf": 1,
  "net.ng": 1,
  "net.ni": 1,
  "net.nr": 1,
  "net.nz": 1,
  "net.om": 1,
  "net.pa": 1,
  "net.pe": 1,
  "net.ph": 1,
  "net.pk": 1,
  "net.pl": 1,
  "net.pn": 1,
  "net.pr": 1,
  "net.ps": 1,
  "net.pt": 1,
  "net.py": 1,
  "net.qa": 1,
  "net.ru": 1,
  "net.rw": 1,
  "net.sa": 1,
  "net.sb": 1,
  "net.sc": 1,
  "net.sd": 1,
  "net.sg": 1,
  "net.sh": 1,
  "net.sl": 1,
  "net.so": 1,
  "net.ss": 1,
  "net.st": 1,
  "net.sy": 1,
  "net.th": 1,
  "net.tj": 1,
  "net.tm": 1,
  "net.tn": 1,
  "net.to": 1,
  "net.tr": 1,
  "net.tt": 1,
  "net.tw": 1,
  "net.ua": 1,
  "net.uk": 1,
  "net.uy": 1,
  "net.uz": 1,
  "net.vc": 1,
  "net.ve": 1,
  "net.vi": 1,
  "net.vn": 1,
  "net.vu": 1,
  "net.ws": 1,
  "net.za": 1,
  "net.zm": 1,
  "netbank": 1,
  "netflix": 1,
  "netlify.app": 1,
  "network": 1,
  "neues.museum": 1,
  "neustar": 1,
  "new": 1,
  "newhampshire.museum": 1,
  "newholland": 1,
  "newjersey.museum": 1,
  "newmexico.museum": 1,
  "newport.museum": 1,
  "news": 1,
  "news.hu": 1,
  "newspaper.museum": 1,
  "newyork.museum": 1,
  "next": 1,
  "nextdirect": 1,
  "nexus": 1,
  "neyagawa.osaka.jp": 1,
  "nf": 1,
  "nf.ca": 1,
  "nfl": 1,
  "nflfan.org": 1,
  "nfshost.com": 1,
  "ng": 1,
  "ng.city": 1,
  "ng.eu.org": 1,
  "ng.ink": 1,
  "ng.school": 1,
  "ngo": 1,
  "ngo.lk": 1,
  "ngo.ng": 1,
  "ngo.ph": 1,
  "ngo.za": 1,
  "ngrok.io": 1,
  "nh-serv.co.uk": 1,
  "nh.us": 1,
  "nhk": 1,
  "nhlfan.net": 1,
  "nhs.uk": 1,
  "ni": 1,
  "nic.in": 1,
  "nic.tj": 1,
  "nic.za": 1,
  "nichinan.miyazaki.jp": 1,
  "nichinan.tottori.jp": 1,
  "nico": 1,
  "nid.io": 1,
  "niepce.museum": 1,
  "nieruchomosci.pl": 1,
  "niigata.jp": 1,
  "niigata.niigata.jp": 1,
  "niihama.ehime.jp": 1,
  "niikappu.hokkaido.jp": 1,
  "niimi.okayama.jp": 1,
  "niiza.saitama.jp": 1,
  "nikaho.akita.jp": 1,
  "nike": 1,
  "niki.hokkaido.jp": 1,
  "nikko.tochigi.jp": 1,
  "nikolaev.ua": 1,
  "nikon": 1,
  "ninja": 1,
  "ninohe.iwate.jp": 1,
  "ninomiya.kanagawa.jp": 1,
  "nirasaki.yamanashi.jp": 1,
  "nis.za": 1,
  "nishi.fukuoka.jp": 1,
  "nishi.osaka.jp": 1,
  "nishiaizu.fukushima.jp": 1,
  "nishiarita.saga.jp": 1,
  "nishiawakura.okayama.jp": 1,
  "nishiazai.shiga.jp": 1,
  "nishigo.fukushima.jp": 1,
  "nishihara.kumamoto.jp": 1,
  "nishihara.okinawa.jp": 1,
  "nishiizu.shizuoka.jp": 1,
  "nishikata.tochigi.jp": 1,
  "nishikatsura.yamanashi.jp": 1,
  "nishikawa.yamagata.jp": 1,
  "nishimera.miyazaki.jp": 1,
  "nishinomiya.hyogo.jp": 1,
  "nishinoomote.kagoshima.jp": 1,
  "nishinoshima.shimane.jp": 1,
  "nishio.aichi.jp": 1,
  "nishiokoppe.hokkaido.jp": 1,
  "nishitosa.kochi.jp": 1,
  "nishiwaki.hyogo.jp": 1,
  "nissan": 1,
  "nissay": 1,
  "nissedal.no": 1,
  "nisshin.aichi.jp": 1,
  "niteroi.br": 1,
  "nittedal.no": 1,
  "niyodogawa.kochi.jp": 1,
  "nj.us": 1,
  "nl": 1,
  "nl.ca": 1,
  "nl.ci": 1,
  "nl.eu.org": 1,
  "nl.no": 1,
  "nm.cn": 1,
  "nm.us": 1,
  "no": 1,
  "no-ip.biz": 1,
  "no-ip.ca": 1,
  "no-ip.co.uk": 1,
  "no-ip.info": 1,
  "no-ip.net": 1,
  "no-ip.org": 1,
  "no.com": 1,
  "no.eu.org": 1,
  "no.it": 1,
  "nobeoka.miyazaki.jp": 1,
  "noboribetsu.hokkaido.jp": 1,
  "noda.chiba.jp": 1,
  "noda.iwate.jp": 1,
  "nodum.co": 1,
  "nodum.io": 1,
  "nogata.fukuoka.jp": 1,
  "nogi.tochigi.jp": 1,
  "noheji.aomori.jp": 1,
  "noho.st": 1,
  "nohost.me": 1,
  "noip.me": 1,
  "noip.us": 1,
  "nokia": 1,
  "nom.ad": 1,
  "nom.ae": 1,
  "nom.af": 1,
  "nom.ag": 1,
  "nom.ai": 1,
  "nom.al": 1,
  "nom.bz": 1,
  "nom.cl": 1,
  "nom.co": 1,
  "nom.es": 1,
  "nom.fr": 1,
  "nom.gd": 1,
  "nom.ge": 1,
  "nom.gl": 1,
  "nom.gt": 1,
  "nom.hn": 1,
  "nom.im": 1,
  "nom.ke": 1,
  "nom.km": 1,
  "nom.li": 1,
  "nom.lv": 1,
  "nom.mg": 1,
  "nom.mk": 1,
  "nom.nc": 1,
  "nom.ni": 1,
  "nom.nu": 1,
  "nom.pa": 1,
  "nom.pe": 1,
  "nom.pl": 1,
  "nom.pw": 1,
  "nom.qa": 1,
  "nom.re": 1,
  "nom.ro": 1,
  "nom.rs": 1,
  "nom.si": 1,
  "nom.st": 1,
  "nom.tj": 1,
  "nom.tm": 1,
  "nom.ug": 1,
  "nom.uy": 1,
  "nom.vc": 1,
  "nom.vg": 1,
  "nom.za": 1,
  "nombre.bo": 1,
  "nome.pt": 1,
  "nomi.ishikawa.jp": 1,
  "nonoichi.ishikawa.jp": 1,
  "nord-aurdal.no": 1,
  "nord-fron.no": 1,
  "nord-odal.no": 1,
  "norddal.no": 1,
  "nordkapp.no": 1,
  "nordre-land.no": 1,
  "nordreisa.no": 1,
  "nore-og-uvdal.no": 1,
  "norfolk.museum": 1,
  "north-kazakhstan.su": 1,
  "north.museum": 1,
  "northwesternmutual": 1,
  "norton": 1,
  "nose.osaka.jp": 1,
  "nosegawa.nara.jp": 1,
  "noshiro.akita.jp": 1,
  "not.br": 1,
  "notaires.fr": 1,
  "notaires.km": 1,
  "noticias.bo": 1,
  "noto.ishikawa.jp": 1,
  "notodden.no": 1,
  "notogawa.shiga.jp": 1,
  "notteroy.no": 1,
  "nov.ru": 1,
  "nov.su": 1,
  "novara.it": 1,
  "now": 1,
  "now-dns.net": 1,
  "now-dns.org": 1,
  "now-dns.top": 1,
  "now.sh": 1,
  "nowaruda.pl": 1,
  "nowruz": 1,
  "nowtv": 1,
  "nozawaonsen.nagano.jp": 1,
  "nr": 1,
  "nra": 1,
  "nrw": 1,
  "nrw.museum": 1,
  "ns.ca": 1,
  "nsn.us": 1,
  "nsupdate.info": 1,
  "nsw.au": 1,
  "nsw.edu.au": 1,
  "nt.au": 1,
  "nt.ca": 1,
  "nt.edu.au": 1,
  "nt.no": 1,
  "nt.ro": 1,
  "ntdll.top": 1,
  "ntr.br": 1,
  "ntt": 1,
  "nu": 1,
  "nu.ca": 1,
  "nu.it": 1,
  "numata.gunma.jp": 1,
  "numata.hokkaido.jp": 1,
  "numazu.shizuoka.jp": 1,
  "nuoro.it": 1,
  "nv.us": 1,
  "nx.cn": 1,
  "ny.us": 1,
  "nyaa.am": 1,
  "nyan.to": 1,
  "nyc": 1,
  "nyc.mn": 1,
  "nyc.museum": 1,
  "nym.by": 1,
  "nym.bz": 1,
  "nym.ec": 1,
  "nym.gr": 1,
  "nym.gy": 1,
  "nym.hk": 1,
  "nym.ie": 1,
  "nym.kz": 1,
  "nym.la": 1,
  "nym.lc": 1,
  "nym.li": 1,
  "nym.lt": 1,
  "nym.lu": 1,
  "nym.me": 1,
  "nym.mn": 1,
  "nym.mx": 1,
  "nym.nz": 1,
  "nym.pe": 1,
  "nym.pt": 1,
  "nym.ro": 1,
  "nym.sk": 1,
  "nym.su": 1,
  "nym.sx": 1,
  "nym.tw": 1,
  "nyny.museum": 1,
  "nysa.pl": 1,
  "nyuzen.toyama.jp": 1,
  "nz": 1,
  "nz.eu.org": 1,
  "o.bg": 1,
  "o.se": 1,
  "oamishirasato.chiba.jp": 1,
  "oarai.ibaraki.jp": 1,
  "obama.fukui.jp": 1,
  "obama.nagasaki.jp": 1,
  "obanazawa.yamagata.jp": 1,
  "obi": 1,
  "obihiro.hokkaido.jp": 1,
  "obira.hokkaido.jp": 1,
  "obninsk.su": 1,
  "observer": 1,
  "obu.aichi.jp": 1,
  "obuse.nagano.jp": 1,
  "oceanographic.museum": 1,
  "oceanographique.museum": 1,
  "ocelot.mythic-beasts.com": 1,
  "ochi.kochi.jp": 1,
  "od.ua": 1,
  "odate.akita.jp": 1,
  "odawara.kanagawa.jp": 1,
  "odda.no": 1,
  "odesa.ua": 1,
  "odessa.ua": 1,
  "odo.br": 1,
  "oe.yamagata.jp": 1,
  "of.by": 1,
  "of.fashion": 1,
  "of.football": 1,
  "of.london": 1,
  "of.no": 1,
  "of.work": 1,
  "off": 1,
  "off.ai": 1,
  "office": 1,
  "office-on-the.net": 1,
  "official.academy": 1,
  "ofunato.iwate.jp": 1,
  "og.ao": 1,
  "og.it": 1,
  "oga.akita.jp": 1,
  "ogaki.gifu.jp": 1,
  "ogano.saitama.jp": 1,
  "ogasawara.tokyo.jp": 1,
  "ogata.akita.jp": 1,
  "ogawa.ibaraki.jp": 1,
  "ogawa.nagano.jp": 1,
  "ogawa.saitama.jp": 1,
  "ogawara.miyagi.jp": 1,
  "ogi.saga.jp": 1,
  "ogimi.okinawa.jp": 1,
  "ogliastra.it": 1,
  "ogori.fukuoka.jp": 1,
  "ogose.saitama.jp": 1,
  "oguchi.aichi.jp": 1,
  "oguni.kumamoto.jp": 1,
  "oguni.yamagata.jp": 1,
  "oh.us": 1,
  "oharu.aichi.jp": 1,
  "ohda.shimane.jp": 1,
  "ohi.fukui.jp": 1,
  "ohira.miyagi.jp": 1,
  "ohira.tochigi.jp": 1,
  "ohkura.yamagata.jp": 1,
  "ohtawara.tochigi.jp": 1,
  "oi.kanagawa.jp": 1,
  "oirase.aomori.jp": 1,
  "oirm.gov.pl": 1,
  "oishida.yamagata.jp": 1,
  "oiso.kanagawa.jp": 1,
  "oita.jp": 1,
  "oita.oita.jp": 1,
  "oizumi.gunma.jp": 1,
  "oji.nara.jp": 1,
  "ojiya.niigata.jp": 1,
  "ok.us": 1,
  "okagaki.fukuoka.jp": 1,
  "okawa.fukuoka.jp": 1,
  "okawa.kochi.jp": 1,
  "okaya.nagano.jp": 1,
  "okayama.jp": 1,
  "okayama.okayama.jp": 1,
  "okazaki.aichi.jp": 1,
  "okegawa.saitama.jp": 1,
  "oketo.hokkaido.jp": 1,
  "oki.fukuoka.jp": 1,
  "okinawa": 1,
  "okinawa.jp": 1,
  "okinawa.okinawa.jp": 1,
  "okinoshima.shimane.jp": 1,
  "okoppe.hokkaido.jp": 1,
  "oksnes.no": 1,
  "okuizumo.shimane.jp": 1,
  "okuma.fukushima.jp": 1,
  "okutama.tokyo.jp": 1,
  "ol.no": 1,
  "olawa.pl": 1,
  "olayan": 1,
  "olayangroup": 1,
  "olbia-tempio.it": 1,
  "olbiatempio.it": 1,
  "oldnavy": 1,
  "olecko.pl": 1,
  "olkusz.pl": 1,
  "ollo": 1,
  "olsztyn.pl": 1,
  "om": 1,
  "omachi.nagano.jp": 1,
  "omachi.saga.jp": 1,
  "omaezaki.shizuoka.jp": 1,
  "omaha.museum": 1,
  "omasvuotna.no": 1,
  "ome.tokyo.jp": 1,
  "omega": 1,
  "omi.nagano.jp": 1,
  "omi.niigata.jp": 1,
  "omigawa.chiba.jp": 1,
  "omihachiman.shiga.jp": 1,
  "omitama.ibaraki.jp": 1,
  "omiya.saitama.jp": 1,
  "omotego.fukushima.jp": 1,
  "omura.nagasaki.jp": 1,
  "omuta.fukuoka.jp": 1,
  "on-aptible.com": 1,
  "on-the-web.tv": 1,
  "on-web.fr": 1,
  "on.ca": 1,
  "on.fashion": 1,
  "onagawa.miyagi.jp": 1,
  "one": 1,
  "onfabrica.com": 1,
  "ong": 1,
  "ong.br": 1,
  "onga.fukuoka.jp": 1,
  "onion": 1,
  "onjuku.chiba.jp": 1,
  "onl": 1,
  "online": 1,
  "online.museum": 1,
  "online.th": 1,
  "onna.okinawa.jp": 1,
  "ono.fukui.jp": 1,
  "ono.fukushima.jp": 1,
  "ono.hyogo.jp": 1,
  "onojo.fukuoka.jp": 1,
  "onomichi.hiroshima.jp": 1,
  "onred.one": 1,
  "onrender.com": 1,
  "ontario.museum": 1,
  "onthewifi.com": 1,
  "onyourside": 1,
  "onza.mythic-beasts.com": 1,
  "ooguy.com": 1,
  "ookuwa.nagano.jp": 1,
  "ooo": 1,
  "ooshika.nagano.jp": 1,
  "open": 1,
  "openair.museum": 1,
  "opencraft.hosting": 1,
  "opensocial.site": 1,
  "operaunite.com": 1,
  "opoczno.pl": 1,
  "opole.pl": 1,
  "oppdal.no": 1,
  "oppegard.no": 1,
  "or.at": 1,
  "or.bi": 1,
  "or.ci": 1,
  "or.cr": 1,
  "or.id": 1,
  "or.it": 1,
  "or.jp": 1,
  "or.ke": 1,
  "or.kr": 1,
  "or.mu": 1,
  "or.na": 1,
  "or.pw": 1,
  "or.th": 1,
  "or.tz": 1,
  "or.ug": 1,
  "or.us": 1,
  "ora.gunma.jp": 1,
  "oracle": 1,
  "orange": 1,
  "oregon.museum": 1,
  "oregontrail.museum": 1,
  "org": 1,
  "org.ac": 1,
  "org.ae": 1,
  "org.af": 1,
  "org.ag": 1,
  "org.ai": 1,
  "org.al": 1,
  "org.am": 1,
  "org.ar": 1,
  "org.au": 1,
  "org.az": 1,
  "org.ba": 1,
  "org.bb": 1,
  "org.bh": 1,
  "org.bi": 1,
  "org.bm": 1,
  "org.bn": 1,
  "org.bo": 1,
  "org.br": 1,
  "org.bs": 1,
  "org.bt": 1,
  "org.bw": 1,
  "org.bz": 1,
  "org.ci": 1,
  "org.cn": 1,
  "org.co": 1,
  "org.cu": 1,
  "org.cw": 1,
  "org.cy": 1,
  "org.dm": 1,
  "org.do": 1,
  "org.dz": 1,
  "org.ec": 1,
  "org.ee": 1,
  "org.eg": 1,
  "org.es": 1,
  "org.et": 1,
  "org.fj": 1,
  "org.ge": 1,
  "org.gg": 1,
  "org.gh": 1,
  "org.gi": 1,
  "org.gl": 1,
  "org.gn": 1,
  "org.gp": 1,
  "org.gr": 1,
  "org.gt": 1,
  "org.gu": 1,
  "org.gy": 1,
  "org.hk": 1,
  "org.hn": 1,
  "org.ht": 1,
  "org.hu": 1,
  "org.il": 1,
  "org.im": 1,
  "org.in": 1,
  "org.iq": 1,
  "org.ir": 1,
  "org.is": 1,
  "org.je": 1,
  "org.jo": 1,
  "org.kg": 1,
  "org.ki": 1,
  "org.km": 1,
  "org.kn": 1,
  "org.kp": 1,
  "org.kw": 1,
  "org.ky": 1,
  "org.kz": 1,
  "org.la": 1,
  "org.lb": 1,
  "org.lc": 1,
  "org.lk": 1,
  "org.lr": 1,
  "org.ls": 1,
  "org.lv": 1,
  "org.ly": 1,
  "org.ma": 1,
  "org.me": 1,
  "org.mg": 1,
  "org.mk": 1,
  "org.ml": 1,
  "org.mn": 1,
  "org.mo": 1,
  "org.ms": 1,
  "org.mt": 1,
  "org.mu": 1,
  "org.mv": 1,
  "org.mw": 1,
  "org.mx": 1,
  "org.my": 1,
  "org.mz": 1,
  "org.na": 1,
  "org.ng": 1,
  "org.ni": 1,
  "org.nr": 1,
  "org.nz": 1,
  "org.om": 1,
  "org.pa": 1,
  "org.pe": 1,
  "org.pf": 1,
  "org.ph": 1,
  "org.pk": 1,
  "org.pl": 1,
  "org.pn": 1,
  "org.pr": 1,
  "org.ps": 1,
  "org.pt": 1,
  "org.py": 1,
  "org.qa": 1,
  "org.ro": 1,
  "org.rs": 1,
  "org.ru": 1,
  "org.rw": 1,
  "org.sa": 1,
  "org.sb": 1,
  "org.sc": 1,
  "org.sd": 1,
  "org.se": 1,
  "org.sg": 1,
  "org.sh": 1,
  "org.sl": 1,
  "org.sn": 1,
  "org.so": 1,
  "org.ss": 1,
  "org.st": 1,
  "org.sv": 1,
  "org.sy": 1,
  "org.sz": 1,
  "org.tj": 1,
  "org.tm": 1,
  "org.tn": 1,
  "org.to": 1,
  "org.tr": 1,
  "org.tt": 1,
  "org.tw": 1,
  "org.ua": 1,
  "org.ug": 1,
  "org.uk": 1,
  "org.uy": 1,
  "org.uz": 1,
  "org.vc": 1,
  "org.ve": 1,
  "org.vi": 1,
  "org.vn": 1,
  "org.vu": 1,
  "org.ws": 1,
  "org.za": 1,
  "org.zm": 1,
  "org.zw": 1,
  "organic": 1,
  "origins": 1,
  "oristano.it": 1,
  "orkanger.no": 1,
  "orkdal.no": 1,
  "orland.no": 1,
  "orskog.no": 1,
  "orsta.no": 1,
  "orx.biz": 1,
  "os.hedmark.no": 1,
  "os.hordaland.no": 1,
  "osaka": 1,
  "osaka.jp": 1,
  "osakasayama.osaka.jp": 1,
  "osaki.miyagi.jp": 1,
  "osakikamijima.hiroshima.jp": 1,
  "osasco.br": 1,
  "osen.no": 1,
  "oseto.nagasaki.jp": 1,
  "oshima.tokyo.jp": 1,
  "oshima.yamaguchi.jp": 1,
  "oshino.yamanashi.jp": 1,
  "oshu.iwate.jp": 1,
  "oslo.no": 1,
  "osoyro.no": 1,
  "osteroy.no": 1,
  "ostre-toten.no": 1,
  "ostroda.pl": 1,
  "ostroleka.pl": 1,
  "ostrowiec.pl": 1,
  "ostrowwlkp.pl": 1,
  "ot.it": 1,
  "ota.gunma.jp": 1,
  "ota.tokyo.jp": 1,
  "otago.museum": 1,
  "otake.hiroshima.jp": 1,
  "otaki.chiba.jp": 1,
  "otaki.nagano.jp": 1,
  "otaki.saitama.jp": 1,
  "otama.fukushima.jp": 1,
  "otari.nagano.jp": 1,
  "otaru.hokkaido.jp": 1,
  "other.nf": 1,
  "oto.fukuoka.jp": 1,
  "otobe.hokkaido.jp": 1,
  "otofuke.hokkaido.jp": 1,
  "otoineppu.hokkaido.jp": 1,
  "otoyo.kochi.jp": 1,
  "otsu.shiga.jp": 1,
  "otsuchi.iwate.jp": 1,
  "otsuka": 1,
  "otsuki.kochi.jp": 1,
  "otsuki.yamanashi.jp": 1,
  "ott": 1,
  "ouchi.saga.jp": 1,
  "ouda.nara.jp": 1,
  "oum.gov.pl": 1,
  "oumu.hokkaido.jp": 1,
  "outsystemscloud.com": 1,
  "overhalla.no": 1,
  "ovh": 1,
  "ovre-eiker.no": 1,
  "owani.aomori.jp": 1,
  "owariasahi.aichi.jp": 1,
  "own.pm": 1,
  "ownip.net": 1,
  "ownprovider.com": 1,
  "ox.rs": 1,
  "oxford.museum": 1,
  "oy.lc": 1,
  "oya.to": 1,
  "oyabe.toyama.jp": 1,
  "oyama.tochigi.jp": 1,
  "oyamazaki.kyoto.jp": 1,
  "oyer.no": 1,
  "oygarden.no": 1,
  "oyodo.nara.jp": 1,
  "oystre-slidre.no": 1,
  "oz.au": 1,
  "ozora.hokkaido.jp": 1,
  "ozu.ehime.jp": 1,
  "ozu.kumamoto.jp": 1,
  "p.bg": 1,
  "p.se": 1,
  "pa": 1,
  "pa.gov.br": 1,
  "pa.gov.pl": 1,
  "pa.it": 1,
  "pa.leg.br": 1,
  "pa.us": 1,
  "pacific.museum": 1,
  "paderborn.museum": 1,
  "padova.it": 1,
  "padua.it": 1,
  "page": 1,
  "pagefrontapp.com": 1,
  "pages.wiardweb.com": 1,
  "pagespeedmobilizer.com": 1,
  "pagexl.com": 1,
  "palace.museum": 1,
  "paleo.museum": 1,
  "palermo.it": 1,
  "palmas.br": 1,
  "palmsprings.museum": 1,
  "panama.museum": 1,
  "panasonic": 1,
  "panel.gg": 1,
  "pantheonsite.io": 1,
  "parachuting.aero": 1,
  "paragliding.aero": 1,
  "paris": 1,
  "paris.eu.org": 1,
  "paris.museum": 1,
  "parliament.cy": 1,
  "parliament.nz": 1,
  "parma.it": 1,
  "paroch.k12.ma.us": 1,
  "pars": 1,
  "parti.se": 1,
  "partners": 1,
  "parts": 1,
  "party": 1,
  "pasadena.museum": 1,
  "passagens": 1,
  "passenger-association.aero": 1,
  "patria.bo": 1,
  "pavia.it": 1,
  "pay": 1,
  "pb.ao": 1,
  "pb.gov.br": 1,
  "pb.leg.br": 1,
  "pc.it": 1,
  "pc.pl": 1,
  "pccw": 1,
  "pcloud.host": 1,
  "pd.it": 1,
  "pdns.page": 1,
  "pe": 1,
  "pe.ca": 1,
  "pe.gov.br": 1,
  "pe.it": 1,
  "pe.kr": 1,
  "pe.leg.br": 1,
  "penza.su": 1,
  "per.la": 1,
  "per.nf": 1,
  "per.sg": 1,
  "perso.ht": 1,
  "perso.sn": 1,
  "perso.tn": 1,
  "perspecta.cloud": 1,
  "perugia.it": 1,
  "pesaro-urbino.it": 1,
  "pesarourbino.it": 1,
  "pescara.it": 1,
  "pet": 1,
  "pf": 1,
  "pfizer": 1,
  "pg.it": 1,
  "pgafan.net": 1,
  "pgfog.com": 1,
  "ph": 1,
  "pharmacien.fr": 1,
  "pharmaciens.km": 1,
  "pharmacy": 1,
  "pharmacy.museum": 1,
  "phd": 1,
  "philadelphia.museum": 1,
  "philadelphiaarea.museum": 1,
  "philately.museum": 1,
  "philips": 1,
  "phoenix.museum": 1,
  "phone": 1,
  "photo": 1,
  "photography": 1,
  "photography.museum": 1,
  "photos": 1,
  "physio": 1,
  "pi.gov.br": 1,
  "pi.it": 1,
  "pi.leg.br": 1,
  "piacenza.it": 1,
  "pics": 1,
  "pictet": 1,
  "pictures": 1,
  "pid": 1,
  "piedmont.it": 1,
  "piemonte.it": 1,
  "pila.pl": 1,
  "pilot.aero": 1,
  "pilots.museum": 1,
  "pimienta.org": 1,
  "pin": 1,
  "pinb.gov.pl": 1,
  "ping": 1,
  "pink": 1,
  "pioneer": 1,
  "pippu.hokkaido.jp": 1,
  "pisa.it": 1,
  "pistoia.it": 1,
  "pisz.pl": 1,
  "pittsburgh.museum": 1,
  "piw.gov.pl": 1,
  "pixolino.com": 1,
  "pizza": 1,
  "pk": 1,
  "pl": 1,
  "pl.eu.org": 1,
  "pl.ua": 1,
  "place": 1,
  "planetarium.museum": 1,
  "plantation.museum": 1,
  "plants.museum": 1,
  "platter-app.com": 1,
  "platter-app.dev": 1,
  "platterp.us": 1,
  "play": 1,
  "playstation": 1,
  "playstation-cloud.com": 1,
  "plaza.museum": 1,
  "plc.co.im": 1,
  "plc.ly": 1,
  "plc.uk": 1,
  "plesk.page": 1,
  "pleskns.com": 1,
  "plo.ps": 1,
  "plumbing": 1,
  "plurinacional.bo": 1,
  "plus": 1,
  "pm": 1,
  "pmn.it": 1,
  "pn": 1,
  "pn.it": 1,
  "pnc": 1,
  "po.gov.pl": 1,
  "po.it": 1,
  "poa.br": 1,
  "podhale.pl": 1,
  "podlasie.pl": 1,
  "podzone.net": 1,
  "podzone.org": 1,
  "pohl": 1,
  "point2this.com": 1,
  "pointto.us": 1,
  "poivron.org": 1,
  "poker": 1,
  "pokrovsk.su": 1,
  "pol.dz": 1,
  "pol.ht": 1,
  "pol.tr": 1,
  "police.uk": 1,
  "politica.bo": 1,
  "politie": 1,
  "polkowice.pl": 1,
  "poltava.ua": 1,
  "pomorskie.pl": 1,
  "pomorze.pl": 1,
  "poniatowa.pl": 1,
  "ponpes.id": 1,
  "pony.club": 1,
  "pordenone.it": 1,
  "porn": 1,
  "porsanger.no": 1,
  "porsangu.no": 1,
  "porsgrunn.no": 1,
  "port.fr": 1,
  "portal.museum": 1,
  "portland.museum": 1,
  "portlligat.museum": 1,
  "post": 1,
  "posts-and-telecommunications.museum": 1,
  "potager.org": 1,
  "potenza.it": 1,
  "powiat.pl": 1,
  "poznan.pl": 1,
  "pp.az": 1,
  "pp.ru": 1,
  "pp.se": 1,
  "pp.ua": 1,
  "ppg.br": 1,
  "pr": 1,
  "pr.gov.br": 1,
  "pr.it": 1,
  "pr.leg.br": 1,
  "pr.us": 1,
  "pramerica": 1,
  "prato.it": 1,
  "praxi": 1,
  "prd.fr": 1,
  "prd.km": 1,
  "prd.mg": 1,
  "preservation.museum": 1,
  "presidio.museum": 1,
  "press": 1,
  "press.aero": 1,
  "press.cy": 1,
  "press.ma": 1,
  "press.museum": 1,
  "press.se": 1,
  "presse.ci": 1,
  "presse.km": 1,
  "presse.ml": 1,
  "pri.ee": 1,
  "prime": 1,
  "principe.st": 1,
  "priv.at": 1,
  "priv.hu": 1,
  "priv.me": 1,
  "priv.no": 1,
  "priv.pl": 1,
  "privatizehealthinsurance.net": 1,
  "pro": 1,
  "pro.az": 1,
  "pro.br": 1,
  "pro.cy": 1,
  "pro.ec": 1,
  "pro.fj": 1,
  "pro.ht": 1,
  "pro.mv": 1,
  "pro.na": 1,
  "pro.om": 1,
  "pro.pr": 1,
  "pro.tt": 1,
  "pro.vn": 1,
  "prochowice.pl": 1,
  "prod": 1,
  "production.aero": 1,
  "productions": 1,
  "prof": 1,
  "prof.pr": 1,
  "profesional.bo": 1,
  "progressive": 1,
  "project.museum": 1,
  "promo": 1,
  "properties": 1,
  "property": 1,
  "protection": 1,
  "protonet.io": 1,
  "pru": 1,
  "prudential": 1,
  "pruszkow.pl": 1,
  "prvcy.page": 1,
  "przeworsk.pl": 1,
  "ps": 1,
  "psc.br": 1,
  "psi.br": 1,
  "psp.gov.pl": 1,
  "psse.gov.pl": 1,
  "pt": 1,
  "pt.eu.org": 1,
  "pt.it": 1,
  "ptplus.fit": 1,
  "pu.it": 1,
  "pub": 1,
  "pub.sa": 1,
  "publ.pt": 1,
  "public.museum": 1,
  "publishproxy.com": 1,
  "pubol.museum": 1,
  "pubtls.org": 1,
  "pueblo.bo": 1,
  "pug.it": 1,
  "puglia.it": 1,
  "pulawy.pl": 1,
  "pup.gov.pl": 1,
  "pv.it": 1,
  "pvh.br": 1,
  "pvt.ge": 1,
  "pvt.k12.ma.us": 1,
  "pw": 1,
  "pwc": 1,
  "py": 1,
  "pyatigorsk.ru": 1,
  "pz.it": 1,
  "q-a.eu.org": 1,
  "q.bg": 1,
  "qa": 1,
  "qa2.com": 1,
  "qbuser.com": 1,
  "qc.ca": 1,
  "qc.com": 1,
  "qcx.io": 1,
  "qh.cn": 1,
  "qld.au": 1,
  "qld.edu.au": 1,
  "qld.gov.au": 1,
  "qpon": 1,
  "qsl.br": 1,
  "qualifioapp.com": 1,
  "quebec": 1,
  "quebec.museum": 1,
  "quest": 1,
  "quicksytes.com": 1,
  "qvc": 1,
  "r.bg": 1,
  "r.cdn77.net": 1,
  "r.se": 1,
  "ra.it": 1,
  "racing": 1,
  "rackmaze.com": 1,
  "rackmaze.net": 1,
  "rade.no": 1,
  "radio": 1,
  "radio.br": 1,
  "radom.pl": 1,
  "radoy.no": 1,
  "ragusa.it": 1,
  "rahkkeravju.no": 1,
  "raholt.no": 1,
  "raid": 1,
  "railroad.museum": 1,
  "railway.museum": 1,
  "raisa.no": 1,
  "rakkestad.no": 1,
  "ralingen.no": 1,
  "rana.no": 1,
  "randaberg.no": 1,
  "rankoshi.hokkaido.jp": 1,
  "ranzan.saitama.jp": 1,
  "ras.ru": 1,
  "rauma.no": 1,
  "ravendb.community": 1,
  "ravendb.me": 1,
  "ravendb.run": 1,
  "ravenna.it": 1,
  "rawa-maz.pl": 1,
  "rc.it": 1,
  "rdv.to": 1,
  "re": 1,
  "re.it": 1,
  "re.kr": 1,
  "read": 1,
  "read-books.org": 1,
  "readmyblog.org": 1,
  "readthedocs.io": 1,
  "realestate": 1,
  "realestate.pl": 1,
  "realm.cz": 1,
  "realtor": 1,
  "realty": 1,
  "rebun.hokkaido.jp": 1,
  "rec.br": 1,
  "rec.co": 1,
  "rec.nf": 1,
  "rec.ro": 1,
  "rec.ve": 1,
  "recht.pro": 1,
  "recife.br": 1,
  "recipes": 1,
  "recreation.aero": 1,
  "red": 1,
  "red.sv": 1,
  "redirectme.net": 1,
  "redstone": 1,
  "redumbrella": 1,
  "reg.dk": 1,
  "reggio-calabria.it": 1,
  "reggio-emilia.it": 1,
  "reggiocalabria.it": 1,
  "reggioemilia.it": 1,
  "rehab": 1,
  "reise": 1,
  "reisen": 1,
  "reit": 1,
  "reklam.hu": 1,
  "rel.ht": 1,
  "rel.pl": 1,
  "reliance": 1,
  "remotewd.com": 1,
  "ren": 1,
  "rendalen.no": 1,
  "rennebu.no": 1,
  "rennesoy.no": 1,
  "rent": 1,
  "rentals": 1,
  "rep.br": 1,
  "rep.kp": 1,
  "repair": 1,
  "repbody.aero": 1,
  "repl.co": 1,
  "repl.run": 1,
  "report": 1,
  "republican": 1,
  "res.aero": 1,
  "res.in": 1,
  "research.aero": 1,
  "research.museum": 1,
  "resindevice.io": 1,
  "resistance.museum": 1,
  "rest": 1,
  "restaurant": 1,
  "review": 1,
  "reviews": 1,
  "revista.bo": 1,
  "rexroth": 1,
  "rg.it": 1,
  "rhcloud.com": 1,
  "ri.it": 1,
  "ri.us": 1,
  "ribeirao.br": 1,
  "rich": 1,
  "richardli": 1,
  "ricoh": 1,
  "rieti.it": 1,
  "rifu.miyagi.jp": 1,
  "riik.ee": 1,
  "rikubetsu.hokkaido.jp": 1,
  "rikuzentakata.iwate.jp": 1,
  "ril": 1,
  "rimini.it": 1,
  "rindal.no": 1,
  "ringebu.no": 1,
  "ringerike.no": 1,
  "ringsaker.no": 1,
  "rio": 1,
  "rio.br": 1,
  "riobranco.br": 1,
  "riodejaneiro.museum": 1,
  "riopreto.br": 1,
  "rip": 1,
  "rishiri.hokkaido.jp": 1,
  "rishirifuji.hokkaido.jp": 1,
  "risor.no": 1,
  "rissa.no": 1,
  "ritto.shiga.jp": 1,
  "rivne.ua": 1,
  "rj.gov.br": 1,
  "rj.leg.br": 1,
  "rl.no": 1,
  "rm.it": 1,
  "rmit": 1,
  "rn.gov.br": 1,
  "rn.it": 1,
  "rn.leg.br": 1,
  "rnrt.tn": 1,
  "rns.tn": 1,
  "rnu.tn": 1,
  "ro": 1,
  "ro.eu.org": 1,
  "ro.gov.br": 1,
  "ro.im": 1,
  "ro.it": 1,
  "ro.leg.br": 1,
  "roan.no": 1,
  "rocher": 1,
  "rochester.museum": 1,
  "rockart.museum": 1,
  "rocks": 1,
  "rodeo": 1,
  "rodoy.no": 1,
  "rogers": 1,
  "rokunohe.aomori.jp": 1,
  "rollag.no": 1,
  "roma.it": 1,
  "roma.museum": 1,
  "rome.it": 1,
  "romsa.no": 1,
  "romskog.no": 1,
  "room": 1,
  "roros.no": 1,
  "rost.no": 1,
  "rotorcraft.aero": 1,
  "router.management": 1,
  "rovigo.it": 1,
  "rovno.ua": 1,
  "royken.no": 1,
  "royrvik.no": 1,
  "rr.gov.br": 1,
  "rr.leg.br": 1,
  "rs": 1,
  "rs.gov.br": 1,
  "rs.leg.br": 1,
  "rsc.cdn77.org": 1,
  "rsvp": 1,
  "ru": 1,
  "ru.com": 1,
  "ru.eu.org": 1,
  "ru.net": 1,
  "rugby": 1,
  "ruhr": 1,
  "run": 1,
  "run.app": 1,
  "ruovat.no": 1,
  "russia.museum": 1,
  "rv.ua": 1,
  "rw": 1,
  "rwe": 1,
  "rybnik.pl": 1,
  "rygge.no": 1,
  "ryokami.saitama.jp": 1,
  "ryugasaki.ibaraki.jp": 1,
  "ryukyu": 1,
  "ryuoh.shiga.jp": 1,
  "rzeszow.pl": 1,
  "rzgw.gov.pl": 1,
  "s.bg": 1,
  "s.se": 1,
  "s3-ap-northeast-1.amazonaws.com": 1,
  "s3-ap-northeast-2.amazonaws.com": 1,
  "s3-ap-south-1.amazonaws.com": 1,
  "s3-ap-southeast-1.amazonaws.com": 1,
  "s3-ap-southeast-2.amazonaws.com": 1,
  "s3-ca-central-1.amazonaws.com": 1,
  "s3-eu-central-1.amazonaws.com": 1,
  "s3-eu-west-1.amazonaws.com": 1,
  "s3-eu-west-2.amazonaws.com": 1,
  "s3-eu-west-3.amazonaws.com": 1,
  "s3-external-1.amazonaws.com": 1,
  "s3-fips-us-gov-west-1.amazonaws.com": 1,
  "s3-sa-east-1.amazonaws.com": 1,
  "s3-us-east-2.amazonaws.com": 1,
  "s3-us-gov-west-1.amazonaws.com": 1,
  "s3-us-west-1.amazonaws.com": 1,
  "s3-us-west-2.amazonaws.com": 1,
  "s3-website-ap-northeast-1.amazonaws.com": 1,
  "s3-website-ap-southeast-1.amazonaws.com": 1,
  "s3-website-ap-southeast-2.amazonaws.com": 1,
  "s3-website-eu-west-1.amazonaws.com": 1,
  "s3-website-sa-east-1.amazonaws.com": 1,
  "s3-website-us-east-1.amazonaws.com": 1,
  "s3-website-us-west-1.amazonaws.com": 1,
  "s3-website-us-west-2.amazonaws.com": 1,
  "s3-website.ap-northeast-2.amazonaws.com": 1,
  "s3-website.ap-south-1.amazonaws.com": 1,
  "s3-website.ca-central-1.amazonaws.com": 1,
  "s3-website.eu-central-1.amazonaws.com": 1,
  "s3-website.eu-west-2.amazonaws.com": 1,
  "s3-website.eu-west-3.amazonaws.com": 1,
  "s3-website.us-east-2.amazonaws.com": 1,
  "s3.amazonaws.com": 1,
  "s3.ap-northeast-2.amazonaws.com": 1,
  "s3.ap-south-1.amazonaws.com": 1,
  "s3.ca-central-1.amazonaws.com": 1,
  "s3.cn-north-1.amazonaws.com.cn": 1,
  "s3.dualstack.ap-northeast-1.amazonaws.com": 1,
  "s3.dualstack.ap-northeast-2.amazonaws.com": 1,
  "s3.dualstack.ap-south-1.amazonaws.com": 1,
  "s3.dualstack.ap-southeast-1.amazonaws.com": 1,
  "s3.dualstack.ap-southeast-2.amazonaws.com": 1,
  "s3.dualstack.ca-central-1.amazonaws.com": 1,
  "s3.dualstack.eu-central-1.amazonaws.com": 1,
  "s3.dualstack.eu-west-1.amazonaws.com": 1,
  "s3.dualstack.eu-west-2.amazonaws.com": 1,
  "s3.dualstack.eu-west-3.amazonaws.com": 1,
  "s3.dualstack.sa-east-1.amazonaws.com": 1,
  "s3.dualstack.us-east-1.amazonaws.com": 1,
  "s3.dualstack.us-east-2.amazonaws.com": 1,
  "s3.eu-central-1.amazonaws.com": 1,
  "s3.eu-west-2.amazonaws.com": 1,
  "s3.eu-west-3.amazonaws.com": 1,
  "s3.us-east-2.amazonaws.com": 1,
  "sa": 1,
  "sa-east-1.elasticbeanstalk.com": 1,
  "sa.au": 1,
  "sa.com": 1,
  "sa.cr": 1,
  "sa.edu.au": 1,
  "sa.gov.au": 1,
  "sa.gov.pl": 1,
  "sa.it": 1,
  "saarland": 1,
  "sabae.fukui.jp": 1,
  "sado.niigata.jp": 1,
  "safe": 1,
  "safety": 1,
  "safety.aero": 1,
  "saga.jp": 1,
  "saga.saga.jp": 1,
  "sagae.yamagata.jp": 1,
  "sagamihara.kanagawa.jp": 1,
  "saigawa.fukuoka.jp": 1,
  "saijo.ehime.jp": 1,
  "saikai.nagasaki.jp": 1,
  "saiki.oita.jp": 1,
  "saintlouis.museum": 1,
  "saitama.jp": 1,
  "saitama.saitama.jp": 1,
  "saito.miyazaki.jp": 1,
  "saka.hiroshima.jp": 1,
  "sakado.saitama.jp": 1,
  "sakae.chiba.jp": 1,
  "sakae.nagano.jp": 1,
  "sakahogi.gifu.jp": 1,
  "sakai.fukui.jp": 1,
  "sakai.ibaraki.jp": 1,
  "sakai.osaka.jp": 1,
  "sakaiminato.tottori.jp": 1,
  "sakaki.nagano.jp": 1,
  "sakata.yamagata.jp": 1,
  "sakawa.kochi.jp": 1,
  "sakegawa.yamagata.jp": 1,
  "saku.nagano.jp": 1,
  "sakuho.nagano.jp": 1,
  "sakura": 1,
  "sakura.chiba.jp": 1,
  "sakura.tochigi.jp": 1,
  "sakuragawa.ibaraki.jp": 1,
  "sakurai.nara.jp": 1,
  "sakyo.kyoto.jp": 1,
  "salangen.no": 1,
  "salat.no": 1,
  "sale": 1,
  "salem.museum": 1,
  "salerno.it": 1,
  "salon": 1,
  "saltdal.no": 1,
  "salud.bo": 1,
  "salvador.br": 1,
  "salvadordali.museum": 1,
  "salzburg.museum": 1,
  "samegawa.fukushima.jp": 1,
  "samnanger.no": 1,
  "sampa.br": 1,
  "samsclub": 1,
  "samsung": 1,
  "samukawa.kanagawa.jp": 1,
  "sanagochi.tokushima.jp": 1,
  "sanda.hyogo.jp": 1,
  "sandcats.io": 1,
  "sande.more-og-romsdal.no": 1,
  "sande.vestfold.no": 1,
  "sande.xn--mre-og-romsdal-qqb.no": 1,
  "sandefjord.no": 1,
  "sandiego.museum": 1,
  "sandnes.no": 1,
  "sandnessjoen.no": 1,
  "sandoy.no": 1,
  "sandvik": 1,
  "sandvikcoromant": 1,
  "sanfrancisco.museum": 1,
  "sango.nara.jp": 1,
  "sanjo.niigata.jp": 1,
  "sannan.hyogo.jp": 1,
  "sannohe.aomori.jp": 1,
  "sano.tochigi.jp": 1,
  "sanofi": 1,
  "sanok.pl": 1,
  "santabarbara.museum": 1,
  "santacruz.museum": 1,
  "santafe.museum": 1,
  "santamaria.br": 1,
  "santoandre.br": 1,
  "sanuki.kagawa.jp": 1,
  "saobernardo.br": 1,
  "saogonca.br": 1,
  "saotome.st": 1,
  "sap": 1,
  "sar.it": 1,
  "sardegna.it": 1,
  "sardinia.it": 1,
  "sarl": 1,
  "saroma.hokkaido.jp": 1,
  "sarpsborg.no": 1,
  "sarufutsu.hokkaido.jp": 1,
  "sas": 1,
  "sasaguri.fukuoka.jp": 1,
  "sasayama.hyogo.jp": 1,
  "sasebo.nagasaki.jp": 1,
  "saskatchewan.museum": 1,
  "sassari.it": 1,
  "satosho.okayama.jp": 1,
  "satsumasendai.kagoshima.jp": 1,
  "satte.saitama.jp": 1,
  "satx.museum": 1,
  "sauda.no": 1,
  "sauherad.no": 1,
  "savannahga.museum": 1,
  "save": 1,
  "saves-the-whales.com": 1,
  "savona.it": 1,
  "saxo": 1,
  "sayama.osaka.jp": 1,
  "sayama.saitama.jp": 1,
  "sayo.hyogo.jp": 1,
  "sb": 1,
  "sb.ua": 1,
  "sbi": 1,
  "sbs": 1,
  "sc": 1,
  "sc.cn": 1,
  "sc.gov.br": 1,
  "sc.ke": 1,
  "sc.kr": 1,
  "sc.leg.br": 1,
  "sc.ls": 1,
  "sc.tz": 1,
  "sc.ug": 1,
  "sc.us": 1,
  "sca": 1,
  "scapp.io": 1,
  "scb": 1,
  "sch.ae": 1,
  "sch.id": 1,
  "sch.ir": 1,
  "sch.jo": 1,
  "sch.lk": 1,
  "sch.ly": 1,
  "sch.ng": 1,
  "sch.qa": 1,
  "sch.sa": 1,
  "sch.so": 1,
  "sch.zm": 1,
  "schaeffler": 1,
  "schlesisches.museum": 1,
  "schmidt": 1,
  "schoenbrunn.museum": 1,
  "schokokeks.net": 1,
  "schokoladen.museum": 1,
  "scholarships": 1,
  "school": 1,
  "school.museum": 1,
  "school.na": 1,
  "school.nz": 1,
  "school.za": 1,
  "schools.nsw.edu.au": 1,
  "schule": 1,
  "schulserver.de": 1,
  "schwarz": 1,
  "schweiz.museum": 1,
  "sci.eg": 1,
  "science": 1,
  "science-fiction.museum": 1,
  "science.museum": 1,
  "scienceandhistory.museum": 1,
  "scienceandindustry.museum": 1,
  "sciencecenter.museum": 1,
  "sciencecenters.museum": 1,
  "sciencehistory.museum": 1,
  "sciences.museum": 1,
  "sciencesnaturelles.museum": 1,
  "scientist.aero": 1,
  "scjohnson": 1,
  "scot": 1,
  "scotland.museum": 1,
  "scrapper-site.net": 1,
  "scrapping.cc": 1,
  "scrysec.com": 1,
  "sd": 1,
  "sd.cn": 1,
  "sd.us": 1,
  "sdn.gov.pl": 1,
  "se": 1,
  "se.eu.org": 1,
  "se.gov.br": 1,
  "se.leg.br": 1,
  "se.net": 1,
  "seaport.museum": 1,
  "search": 1,
  "seat": 1,
  "sebastopol.ua": 1,
  "sec.ps": 1,
  "secure": 1,
  "security": 1,
  "securitytactics.com": 1,
  "seek": 1,
  "seg.br": 1,
  "seidat.net": 1,
  "seihi.nagasaki.jp": 1,
  "seika.kyoto.jp": 1,
  "seiro.niigata.jp": 1,
  "seirou.niigata.jp": 1,
  "seiyo.ehime.jp": 1,
  "sejny.pl": 1,
  "seki.gifu.jp": 1,
  "sekigahara.gifu.jp": 1,
  "sekikawa.niigata.jp": 1,
  "sel.no": 1,
  "selbu.no": 1,
  "select": 1,
  "selfip.biz": 1,
  "selfip.com": 1,
  "selfip.info": 1,
  "selfip.net": 1,
  "selfip.org": 1,
  "selje.no": 1,
  "seljord.no": 1,
  "sells-for-less.com": 1,
  "sells-for-u.com": 1,
  "sells-it.net": 1,
  "sellsyourhome.org": 1,
  "semboku.akita.jp": 1,
  "semine.miyagi.jp": 1,
  "sener": 1,
  "sennan.osaka.jp": 1,
  "senseering.net": 1,
  "seoul.kr": 1,
  "sera.hiroshima.jp": 1,
  "seranishi.hiroshima.jp": 1,
  "servebbs.com": 1,
  "servebbs.net": 1,
  "servebbs.org": 1,
  "servebeer.com": 1,
  "serveblog.net": 1,
  "servecounterstrike.com": 1,
  "serveexchange.com": 1,
  "serveftp.com": 1,
  "serveftp.net": 1,
  "serveftp.org": 1,
  "servegame.com": 1,
  "servegame.org": 1,
  "servehalflife.com": 1,
  "servehttp.com": 1,
  "servehumour.com": 1,
  "serveirc.com": 1,
  "serveminecraft.net": 1,
  "servemp3.com": 1,
  "servep2p.com": 1,
  "servepics.com": 1,
  "servequake.com": 1,
  "servesarcasm.com": 1,
  "service.gov.uk": 1,
  "services": 1,
  "services.aero": 1,
  "ses": 1,
  "setagaya.tokyo.jp": 1,
  "seto.aichi.jp": 1,
  "setouchi.okayama.jp": 1,
  "settlement.museum": 1,
  "settlers.museum": 1,
  "settsu.osaka.jp": 1,
  "sevastopol.ua": 1,
  "seven": 1,
  "sew": 1,
  "sex": 1,
  "sex.hu": 1,
  "sex.pl": 1,
  "sexy": 1,
  "sf.no": 1,
  "sfr": 1,
  "sg": 1,
  "sh": 1,
  "sh.cn": 1,
  "shacknet.nu": 1,
  "shakotan.hokkaido.jp": 1,
  "shangrila": 1,
  "shari.hokkaido.jp": 1,
  "sharp": 1,
  "shaw": 1,
  "shell": 1,
  "shell.museum": 1,
  "sherbrooke.museum": 1,
  "shia": 1,
  "shibata.miyagi.jp": 1,
  "shibata.niigata.jp": 1,
  "shibecha.hokkaido.jp": 1,
  "shibetsu.hokkaido.jp": 1,
  "shibukawa.gunma.jp": 1,
  "shibuya.tokyo.jp": 1,
  "shichikashuku.miyagi.jp": 1,
  "shichinohe.aomori.jp": 1,
  "shiftedit.io": 1,
  "shiga.jp": 1,
  "shiiba.miyazaki.jp": 1,
  "shijonawate.osaka.jp": 1,
  "shika.ishikawa.jp": 1,
  "shikabe.hokkaido.jp": 1,
  "shikama.miyagi.jp": 1,
  "shikaoi.hokkaido.jp": 1,
  "shikatsu.aichi.jp": 1,
  "shiki.saitama.jp": 1,
  "shikokuchuo.ehime.jp": 1,
  "shiksha": 1,
  "shima.mie.jp": 1,
  "shimabara.nagasaki.jp": 1,
  "shimada.shizuoka.jp": 1,
  "shimamaki.hokkaido.jp": 1,
  "shimamoto.osaka.jp": 1,
  "shimane.jp": 1,
  "shimane.shimane.jp": 1,
  "shimizu.hokkaido.jp": 1,
  "shimizu.shizuoka.jp": 1,
  "shimoda.shizuoka.jp": 1,
  "shimodate.ibaraki.jp": 1,
  "shimofusa.chiba.jp": 1,
  "shimogo.fukushima.jp": 1,
  "shimoichi.nara.jp": 1,
  "shimoji.okinawa.jp": 1,
  "shimokawa.hokkaido.jp": 1,
  "shimokitayama.nara.jp": 1,
  "shimonita.gunma.jp": 1,
  "shimonoseki.yamaguchi.jp": 1,
  "shimosuwa.nagano.jp": 1,
  "shimotsuke.tochigi.jp": 1,
  "shimotsuma.ibaraki.jp": 1,
  "shinagawa.tokyo.jp": 1,
  "shinanomachi.nagano.jp": 1,
  "shingo.aomori.jp": 1,
  "shingu.fukuoka.jp": 1,
  "shingu.hyogo.jp": 1,
  "shingu.wakayama.jp": 1,
  "shinichi.hiroshima.jp": 1,
  "shinjo.nara.jp": 1,
  "shinjo.okayama.jp": 1,
  "shinjo.yamagata.jp": 1,
  "shinjuku.tokyo.jp": 1,
  "shinkamigoto.nagasaki.jp": 1,
  "shinonsen.hyogo.jp": 1,
  "shinshinotsu.hokkaido.jp": 1,
  "shinshiro.aichi.jp": 1,
  "shinto.gunma.jp": 1,
  "shintoku.hokkaido.jp": 1,
  "shintomi.miyazaki.jp": 1,
  "shinyoshitomi.fukuoka.jp": 1,
  "shiogama.miyagi.jp": 1,
  "shiojiri.nagano.jp": 1,
  "shioya.tochigi.jp": 1,
  "shirahama.wakayama.jp": 1,
  "shirakawa.fukushima.jp": 1,
  "shirakawa.gifu.jp": 1,
  "shirako.chiba.jp": 1,
  "shiranuka.hokkaido.jp": 1,
  "shiraoi.hokkaido.jp": 1,
  "shiraoka.saitama.jp": 1,
  "shirataka.yamagata.jp": 1,
  "shiriuchi.hokkaido.jp": 1,
  "shiroi.chiba.jp": 1,
  "shiroishi.miyagi.jp": 1,
  "shiroishi.saga.jp": 1,
  "shirosato.ibaraki.jp": 1,
  "shishikui.tokushima.jp": 1,
  "shiso.hyogo.jp": 1,
  "shisui.chiba.jp": 1,
  "shitara.aichi.jp": 1,
  "shiwa.iwate.jp": 1,
  "shizukuishi.iwate.jp": 1,
  "shizuoka.jp": 1,
  "shizuoka.shizuoka.jp": 1,
  "shobara.hiroshima.jp": 1,
  "shoes": 1,
  "shonai.fukuoka.jp": 1,
  "shonai.yamagata.jp": 1,
  "shoo.okayama.jp": 1,
  "shop": 1,
  "shop.ht": 1,
  "shop.hu": 1,
  "shop.pl": 1,
  "shop.ro": 1,
  "shop.th": 1,
  "shopitsite.com": 1,
  "shopping": 1,
  "shopware.store": 1,
  "shouji": 1,
  "show": 1,
  "show.aero": 1,
  "showa.fukushima.jp": 1,
  "showa.gunma.jp": 1,
  "showa.yamanashi.jp": 1,
  "showtime": 1,
  "shriram": 1,
  "shunan.yamaguchi.jp": 1,
  "shw.io": 1,
  "si": 1,
  "si.eu.org": 1,
  "si.it": 1,
  "sibenik.museum": 1,
  "sic.it": 1,
  "sicilia.it": 1,
  "sicily.it": 1,
  "siellak.no": 1,
  "siena.it": 1,
  "sigdal.no": 1,
  "siljan.no": 1,
  "silk": 1,
  "silk.museum": 1,
  "simple-url.com": 1,
  "sina": 1,
  "sinaapp.com": 1,
  "singles": 1,
  "siracusa.it": 1,
  "sirdal.no": 1,
  "site": 1,
  "siteleaf.net": 1,
  "sites.static.land": 1,
  "sj": 1,
  "sjc.br": 1,
  "sk": 1,
  "sk.ca": 1,
  "sk.eu.org": 1,
  "skanit.no": 1,
  "skanland.no": 1,
  "skaun.no": 1,
  "skedsmo.no": 1,
  "skedsmokorset.no": 1,
  "ski": 1,
  "ski.museum": 1,
  "ski.no": 1,
  "skien.no": 1,
  "skierva.no": 1,
  "skin": 1,
  "skiptvet.no": 1,
  "skjak.no": 1,
  "skjervoy.no": 1,
  "sklep.pl": 1,
  "sko.gov.pl": 1,
  "skoczow.pl": 1,
  "skodje.no": 1,
  "skole.museum": 1,
  "sky": 1,
  "skydiving.aero": 1,
  "skygearapp.com": 1,
  "skype": 1,
  "sl": 1,
  "slask.pl": 1,
  "slattum.no": 1,
  "sld.do": 1,
  "sld.pa": 1,
  "slg.br": 1,
  "sling": 1,
  "slupsk.pl": 1,
  "slz.br": 1,
  "sm": 1,
  "sm.ua": 1,
  "smart": 1,
  "smile": 1,
  "smola.no": 1,
  "sn": 1,
  "sn.cn": 1,
  "snaase.no": 1,
  "snasa.no": 1,
  "sncf": 1,
  "snillfjord.no": 1,
  "snoasa.no": 1,
  "so": 1,
  "so.gov.pl": 1,
  "so.it": 1,
  "sobetsu.hokkaido.jp": 1,
  "soc.lk": 1,
  "soc.srcf.net": 1,
  "soccer": 1,
  "sochi.su": 1,
  "social": 1,
  "society.museum": 1,
  "sodegaura.chiba.jp": 1,
  "soeda.fukuoka.jp": 1,
  "softbank": 1,
  "software": 1,
  "software.aero": 1,
  "sogndal.no": 1,
  "sogne.no": 1,
  "sohu": 1,
  "soja.okayama.jp": 1,
  "soka.saitama.jp": 1,
  "sokndal.no": 1,
  "sola.no": 1,
  "solar": 1,
  "sologne.museum": 1,
  "solund.no": 1,
  "solutions": 1,
  "soma.fukushima.jp": 1,
  "somna.no": 1,
  "sondre-land.no": 1,
  "sondrio.it": 1,
  "song": 1,
  "songdalen.no": 1,
  "soni.nara.jp": 1,
  "sony": 1,
  "soo.kagoshima.jp": 1,
  "sopot.pl": 1,
  "sor-aurdal.no": 1,
  "sor-fron.no": 1,
  "sor-odal.no": 1,
  "sor-varanger.no": 1,
  "sorfold.no": 1,
  "sorocaba.br": 1,
  "sorreisa.no": 1,
  "sortland.no": 1,
  "sorum.no": 1,
  "sos.pl": 1,
  "sosa.chiba.jp": 1,
  "sosnowiec.pl": 1,
  "soundandvision.museum": 1,
  "soundcast.me": 1,
  "southcarolina.museum": 1,
  "southwest.museum": 1,
  "sowa.ibaraki.jp": 1,
  "soy": 1,
  "sp.gov.br": 1,
  "sp.it": 1,
  "sp.leg.br": 1,
  "spa": 1,
  "space": 1,
  "space-to-rent.com": 1,
  "space.museum": 1,
  "spacekit.io": 1,
  "spb.ru": 1,
  "spb.su": 1,
  "spdns.de": 1,
  "spdns.eu": 1,
  "spdns.org": 1,
  "sphinx.mythic-beasts.com": 1,
  "spjelkavik.no": 1,
  "sport": 1,
  "sport.hu": 1,
  "spot": 1,
  "spreadbetting": 1,
  "spy.museum": 1,
  "spydeberg.no": 1,
  "square.museum": 1,
  "square7.ch": 1,
  "square7.de": 1,
  "square7.net": 1,
  "sr": 1,
  "sr.gov.pl": 1,
  "sr.it": 1,
  "srl": 1,
  "srv.br": 1,
  "ss": 1,
  "ss.it": 1,
  "ssl.origin.cdn77-secure.org": 1,
  "st": 1,
  "st.no": 1,
  "stackhero-network.com": 1,
  "stada": 1,
  "stadt.museum": 1,
  "stage.nodeart.io": 1,
  "staging.onred.one": 1,
  "stalbans.museum": 1,
  "stalowa-wola.pl": 1,
  "stange.no": 1,
  "staples": 1,
  "star": 1,
  "starachowice.pl": 1,
  "stargard.pl": 1,
  "starnberg.museum": 1,
  "starostwo.gov.pl": 1,
  "stat.no": 1,
  "state.museum": 1,
  "statebank": 1,
  "statefarm": 1,
  "stateofdelaware.museum": 1,
  "stathelle.no": 1,
  "static-access.net": 1,
  "static.land": 1,
  "static.observableusercontent.com": 1,
  "station.museum": 1,
  "stavanger.no": 1,
  "stavern.no": 1,
  "stc": 1,
  "stcgroup": 1,
  "steam.museum": 1,
  "steiermark.museum": 1,
  "steigen.no": 1,
  "steinkjer.no": 1,
  "sth.ac.at": 1,
  "stjohn.museum": 1,
  "stjordal.no": 1,
  "stjordalshalsen.no": 1,
  "stockholm": 1,
  "stockholm.museum": 1,
  "stokke.no": 1,
  "stor-elvdal.no": 1,
  "storage": 1,
  "storage.yandexcloud.net": 1,
  "stord.no": 1,
  "stordal.no": 1,
  "store": 1,
  "store.bb": 1,
  "store.dk": 1,
  "store.nf": 1,
  "store.ro": 1,
  "store.st": 1,
  "store.ve": 1,
  "storfjord.no": 1,
  "storj.farm": 1,
  "stpetersburg.museum": 1,
  "strand.no": 1,
  "stranda.no": 1,
  "stream": 1,
  "stryn.no": 1,
  "student.aero": 1,
  "studio": 1,
  "study": 1,
  "stuff-4-sale.org": 1,
  "stuff-4-sale.us": 1,
  "stufftoread.com": 1,
  "stuttgart.museum": 1,
  "style": 1,
  "su": 1,
  "sucks": 1,
  "sue.fukuoka.jp": 1,
  "suedtirol.it": 1,
  "suginami.tokyo.jp": 1,
  "sugito.saitama.jp": 1,
  "suifu.ibaraki.jp": 1,
  "suisse.museum": 1,
  "suita.osaka.jp": 1,
  "sukagawa.fukushima.jp": 1,
  "sukumo.kochi.jp": 1,
  "sula.no": 1,
  "suldal.no": 1,
  "suli.hu": 1,
  "sumida.tokyo.jp": 1,
  "sumita.iwate.jp": 1,
  "sumoto.hyogo.jp": 1,
  "sumoto.kumamoto.jp": 1,
  "sumy.ua": 1,
  "sunagawa.hokkaido.jp": 1,
  "sund.no": 1,
  "sunndal.no": 1,
  "supplies": 1,
  "supply": 1,
  "support": 1,
  "surf": 1,
  "surgeonshall.museum": 1,
  "surgery": 1,
  "surnadal.no": 1,
  "surrey.museum": 1,
  "susaki.kochi.jp": 1,
  "susono.shizuoka.jp": 1,
  "suwa.nagano.jp": 1,
  "suwalki.pl": 1,
  "suzaka.nagano.jp": 1,
  "suzu.ishikawa.jp": 1,
  "suzuka.mie.jp": 1,
  "suzuki": 1,
  "sv": 1,
  "sv.it": 1,
  "svalbard.no": 1,
  "sveio.no": 1,
  "svelvik.no": 1,
  "svizzera.museum": 1,
  "svn-repos.de": 1,
  "swatch": 1,
  "sweden.museum": 1,
  "sweetpepper.org": 1,
  "swidnica.pl": 1,
  "swidnik.pl": 1,
  "swiebodzin.pl": 1,
  "swiftcover": 1,
  "swinoujscie.pl": 1,
  "swiss": 1,
  "sx": 1,
  "sx.cn": 1,
  "sy": 1,
  "sydney": 1,
  "sydney.museum": 1,
  "sykkylven.no": 1,
  "syncloud.it": 1,
  "syno-ds.de": 1,
  "synology-diskstation.de": 1,
  "synology-ds.de": 1,
  "synology.me": 1,
  "systems": 1,
  "sytes.net": 1,
  "sz": 1,
  "szczecin.pl": 1,
  "szczytno.pl": 1,
  "szex.hu": 1,
  "szkola.pl": 1,
  "t.bg": 1,
  "t.se": 1,
  "t3l3p0rt.net": 1,
  "ta.it": 1,
  "taa.it": 1,
  "tab": 1,
  "tabayama.yamanashi.jp": 1,
  "tabuse.yamaguchi.jp": 1,
  "tachiarai.fukuoka.jp": 1,
  "tachikawa.tokyo.jp": 1,
  "tadaoka.osaka.jp": 1,
  "tado.mie.jp": 1,
  "tadotsu.kagawa.jp": 1,
  "tagajo.miyagi.jp": 1,
  "tagami.niigata.jp": 1,
  "tagawa.fukuoka.jp": 1,
  "tahara.aichi.jp": 1,
  "taifun-dns.de": 1,
  "taiji.wakayama.jp": 1,
  "taiki.hokkaido.jp": 1,
  "taiki.mie.jp": 1,
  "tainai.niigata.jp": 1,
  "taipei": 1,
  "taira.toyama.jp": 1,
  "taishi.hyogo.jp": 1,
  "taishi.osaka.jp": 1,
  "taishin.fukushima.jp": 1,
  "taito.tokyo.jp": 1,
  "taiwa.miyagi.jp": 1,
  "tajimi.gifu.jp": 1,
  "tajiri.osaka.jp": 1,
  "taka.hyogo.jp": 1,
  "takagi.nagano.jp": 1,
  "takahagi.ibaraki.jp": 1,
  "takahama.aichi.jp": 1,
  "takahama.fukui.jp": 1,
  "takaharu.miyazaki.jp": 1,
  "takahashi.okayama.jp": 1,
  "takahata.yamagata.jp": 1,
  "takaishi.osaka.jp": 1,
  "takamatsu.kagawa.jp": 1,
  "takamori.kumamoto.jp": 1,
  "takamori.nagano.jp": 1,
  "takanabe.miyazaki.jp": 1,
  "takanezawa.tochigi.jp": 1,
  "takaoka.toyama.jp": 1,
  "takarazuka.hyogo.jp": 1,
  "takasago.hyogo.jp": 1,
  "takasaki.gunma.jp": 1,
  "takashima.shiga.jp": 1,
  "takasu.hokkaido.jp": 1,
  "takata.fukuoka.jp": 1,
  "takatori.nara.jp": 1,
  "takatsuki.osaka.jp": 1,
  "takatsuki.shiga.jp": 1,
  "takayama.gifu.jp": 1,
  "takayama.gunma.jp": 1,
  "takayama.nagano.jp": 1,
  "takazaki.miyazaki.jp": 1,
  "takehara.hiroshima.jp": 1,
  "taketa.oita.jp": 1,
  "taketomi.okinawa.jp": 1,
  "taki.mie.jp": 1,
  "takikawa.hokkaido.jp": 1,
  "takino.hyogo.jp": 1,
  "takinoue.hokkaido.jp": 1,
  "takko.aomori.jp": 1,
  "tako.chiba.jp": 1,
  "taku.saga.jp": 1,
  "talk": 1,
  "tama.tokyo.jp": 1,
  "tamakawa.fukushima.jp": 1,
  "tamaki.mie.jp": 1,
  "tamamura.gunma.jp": 1,
  "tamano.okayama.jp": 1,
  "tamatsukuri.ibaraki.jp": 1,
  "tamayu.shimane.jp": 1,
  "tamba.hyogo.jp": 1,
  "tana.no": 1,
  "tanabe.kyoto.jp": 1,
  "tanabe.wakayama.jp": 1,
  "tanagura.fukushima.jp": 1,
  "tananger.no": 1,
  "tank.museum": 1,
  "tanohata.iwate.jp": 1,
  "taobao": 1,
  "tara.saga.jp": 1,
  "tarama.okinawa.jp": 1,
  "taranto.it": 1,
  "target": 1,
  "targi.pl": 1,
  "tarnobrzeg.pl": 1,
  "tarui.gifu.jp": 1,
  "tarumizu.kagoshima.jp": 1,
  "tas.au": 1,
  "tas.edu.au": 1,
  "tas.gov.au": 1,
  "tashkent.su": 1,
  "tatamotors": 1,
  "tatar": 1,
  "tatebayashi.gunma.jp": 1,
  "tateshina.nagano.jp": 1,
  "tateyama.chiba.jp": 1,
  "tateyama.toyama.jp": 1,
  "tatsuno.hyogo.jp": 1,
  "tatsuno.nagano.jp": 1,
  "tattoo": 1,
  "tawaramoto.nara.jp": 1,
  "tax": 1,
  "taxi": 1,
  "taxi.br": 1,
  "tc": 1,
  "tc.br": 1,
  "tci": 1,
  "tcm.museum": 1,
  "tcp4.me": 1,
  "td": 1,
  "tdk": 1,
  "te.it": 1,
  "te.ua": 1,
  "teaches-yoga.com": 1,
  "team": 1,
  "tec.br": 1,
  "tec.mi.us": 1,
  "tec.ve": 1,
  "tech": 1,
  "technology": 1,
  "technology.museum": 1,
  "tecnologia.bo": 1,
  "tel": 1,
  "tel.tr": 1,
  "tele.amune.org": 1,
  "telebit.app": 1,
  "telebit.io": 1,
  "telekommunikation.museum": 1,
  "television.museum": 1,
  "temasek": 1,
  "temp-dns.com": 1,
  "tempio-olbia.it": 1,
  "tempioolbia.it": 1,
  "tendo.yamagata.jp": 1,
  "tenei.fukushima.jp": 1,
  "tenkawa.nara.jp": 1,
  "tennis": 1,
  "tenri.nara.jp": 1,
  "teo.br": 1,
  "teramo.it": 1,
  "termez.su": 1,
  "terni.it": 1,
  "ternopil.ua": 1,
  "teshikaga.hokkaido.jp": 1,
  "test-iserv.de": 1,
  "test.ru": 1,
  "test.tj": 1,
  "teva": 1,
  "texas.museum": 1,
  "textile.museum": 1,
  "tf": 1,
  "tg": 1,
  "tgory.pl": 1,
  "th": 1,
  "thd": 1,
  "the.br": 1,
  "theater": 1,
  "theater.museum": 1,
  "theatre": 1,
  "theworkpc.com": 1,
  "thingdustdata.com": 1,
  "thruhere.net": 1,
  "tiaa": 1,
  "tickets": 1,
  "tienda": 1,
  "tiffany": 1,
  "time.museum": 1,
  "time.no": 1,
  "timekeeping.museum": 1,
  "tingvoll.no": 1,
  "tinn.no": 1,
  "tips": 1,
  "tires": 1,
  "tirol": 1,
  "tj": 1,
  "tj.cn": 1,
  "tjeldsund.no": 1,
  "tjmaxx": 1,
  "tjome.no": 1,
  "tjx": 1,
  "tk": 1,
  "tkmaxx": 1,
  "tksat.bo": 1,
  "tl": 1,
  "tm": 1,
  "tm.cy": 1,
  "tm.fr": 1,
  "tm.hu": 1,
  "tm.km": 1,
  "tm.mc": 1,
  "tm.mg": 1,
  "tm.no": 1,
  "tm.pl": 1,
  "tm.ro": 1,
  "tm.se": 1,
  "tm.za": 1,
  "tmall": 1,
  "tmp.br": 1,
  "tn": 1,
  "tn.it": 1,
  "tn.us": 1,
  "to": 1,
  "to.gov.br": 1,
  "to.gt": 1,
  "to.it": 1,
  "to.leg.br": 1,
  "to.md": 1,
  "to.work": 1,
  "toba.mie.jp": 1,
  "tobe.ehime.jp": 1,
  "tobetsu.hokkaido.jp": 1,
  "tobishima.aichi.jp": 1,
  "tochigi.jp": 1,
  "tochigi.tochigi.jp": 1,
  "tochio.niigata.jp": 1,
  "toda.saitama.jp": 1,
  "today": 1,
  "toei.aichi.jp": 1,
  "toga.toyama.jp": 1,
  "togakushi.nagano.jp": 1,
  "togane.chiba.jp": 1,
  "togitsu.nagasaki.jp": 1,
  "togliatti.su": 1,
  "togo.aichi.jp": 1,
  "togura.nagano.jp": 1,
  "tohma.hokkaido.jp": 1,
  "tohnosho.chiba.jp": 1,
  "toho.fukuoka.jp": 1,
  "tokai.aichi.jp": 1,
  "tokai.ibaraki.jp": 1,
  "tokamachi.niigata.jp": 1,
  "tokashiki.okinawa.jp": 1,
  "toki.gifu.jp": 1,
  "tokigawa.saitama.jp": 1,
  "tokke.no": 1,
  "tokoname.aichi.jp": 1,
  "tokorozawa.saitama.jp": 1,
  "tokushima.jp": 1,
  "tokushima.tokushima.jp": 1,
  "tokuyama.yamaguchi.jp": 1,
  "tokyo": 1,
  "tokyo.jp": 1,
  "tolga.no": 1,
  "tomakomai.hokkaido.jp": 1,
  "tomari.hokkaido.jp": 1,
  "tome.miyagi.jp": 1,
  "tomi.nagano.jp": 1,
  "tomigusuku.okinawa.jp": 1,
  "tomika.gifu.jp": 1,
  "tomioka.gunma.jp": 1,
  "tomisato.chiba.jp": 1,
  "tomiya.miyagi.jp": 1,
  "tomobe.ibaraki.jp": 1,
  "tonaki.okinawa.jp": 1,
  "tonami.toyama.jp": 1,
  "tondabayashi.osaka.jp": 1,
  "tone.ibaraki.jp": 1,
  "tono.iwate.jp": 1,
  "tonosho.kagawa.jp": 1,
  "tonsberg.no": 1,
  "toolforge.org": 1,
  "tools": 1,
  "toon.ehime.jp": 1,
  "top": 1,
  "topology.museum": 1,
  "torahime.shiga.jp": 1,
  "toray": 1,
  "toride.ibaraki.jp": 1,
  "torino.it": 1,
  "torino.museum": 1,
  "torsken.no": 1,
  "tos.it": 1,
  "tosa.kochi.jp": 1,
  "tosashimizu.kochi.jp": 1,
  "toscana.it": 1,
  "toshiba": 1,
  "toshima.tokyo.jp": 1,
  "tosu.saga.jp": 1,
  "total": 1,
  "tottori.jp": 1,
  "tottori.tottori.jp": 1,
  "touch.museum": 1,
  "tourism.pl": 1,
  "tourism.tn": 1,
  "tours": 1,
  "towada.aomori.jp": 1,
  "town": 1,
  "town.museum": 1,
  "townnews-staging.com": 1,
  "toya.hokkaido.jp": 1,
  "toyako.hokkaido.jp": 1,
  "toyama.jp": 1,
  "toyama.toyama.jp": 1,
  "toyo.kochi.jp": 1,
  "toyoake.aichi.jp": 1,
  "toyohashi.aichi.jp": 1,
  "toyokawa.aichi.jp": 1,
  "toyonaka.osaka.jp": 1,
  "toyone.aichi.jp": 1,
  "toyono.osaka.jp": 1,
  "toyooka.hyogo.jp": 1,
  "toyosato.shiga.jp": 1,
  "toyota": 1,
  "toyota.aichi.jp": 1,
  "toyota.yamaguchi.jp": 1,
  "toyotomi.hokkaido.jp": 1,
  "toyotsu.fukuoka.jp": 1,
  "toyoura.hokkaido.jp": 1,
  "toys": 1,
  "tozawa.yamagata.jp": 1,
  "tozsde.hu": 1,
  "tp.it": 1,
  "tr": 1,
  "tr.eu.org": 1,
  "tr.it": 1,
  "tr.no": 1,
  "tra.kp": 1,
  "trade": 1,
  "trader.aero": 1,
  "trading": 1,
  "trading.aero": 1,
  "traeumtgerade.de": 1,
  "trafficplex.cloud": 1,
  "trainer.aero": 1,
  "training": 1,
  "trana.no": 1,
  "tranby.no": 1,
  "trani-andria-barletta.it": 1,
  "trani-barletta-andria.it": 1,
  "traniandriabarletta.it": 1,
  "tranibarlettaandria.it": 1,
  "tranoy.no": 1,
  "transport.museum": 1,
  "transporte.bo": 1,
  "trapani.it": 1,
  "travel": 1,
  "travel.pl": 1,
  "travel.tt": 1,
  "travelchannel": 1,
  "travelers": 1,
  "travelersinsurance": 1,
  "trd.br": 1,
  "tree.museum": 1,
  "trentin-sud-tirol.it": 1,
  "trentin-sudtirol.it": 1,
  "trentin-sued-tirol.it": 1,
  "trentin-suedtirol.it": 1,
  "trentino-a-adige.it": 1,
  "trentino-aadige.it": 1,
  "trentino-alto-adige.it": 1,
  "trentino-altoadige.it": 1,
  "trentino-s-tirol.it": 1,
  "trentino-stirol.it": 1,
  "trentino-sud-tirol.it": 1,
  "trentino-sudtirol.it": 1,
  "trentino-sued-tirol.it": 1,
  "trentino-suedtirol.it": 1,
  "trentino.it": 1,
  "trentinoa-adige.it": 1,
  "trentinoaadige.it": 1,
  "trentinoalto-adige.it": 1,
  "trentinoaltoadige.it": 1,
  "trentinos-tirol.it": 1,
  "trentinostirol.it": 1,
  "trentinosud-tirol.it": 1,
  "trentinosudtirol.it": 1,
  "trentinosued-tirol.it": 1,
  "trentinosuedtirol.it": 1,
  "trentinsud-tirol.it": 1,
  "trentinsudtirol.it": 1,
  "trentinsued-tirol.it": 1,
  "trentinsuedtirol.it": 1,
  "trento.it": 1,
  "treviso.it": 1,
  "trieste.it": 1,
  "troandin.no": 1,
  "trogstad.no": 1,
  "troitsk.su": 1,
  "trolley.museum": 1,
  "tromsa.no": 1,
  "tromso.no": 1,
  "trondheim.no": 1,
  "trust": 1,
  "trust.museum": 1,
  "trustee.museum": 1,
  "trv": 1,
  "trycloudflare.com": 1,
  "trysil.no": 1,
  "ts.it": 1,
  "tselinograd.su": 1,
  "tsk.tr": 1,
  "tsu.mie.jp": 1,
  "tsubame.niigata.jp": 1,
  "tsubata.ishikawa.jp": 1,
  "tsubetsu.hokkaido.jp": 1,
  "tsuchiura.ibaraki.jp": 1,
  "tsuga.tochigi.jp": 1,
  "tsugaru.aomori.jp": 1,
  "tsuiki.fukuoka.jp": 1,
  "tsukigata.hokkaido.jp": 1,
  "tsukiyono.gunma.jp": 1,
  "tsukuba.ibaraki.jp": 1,
  "tsukui.kanagawa.jp": 1,
  "tsukumi.oita.jp": 1,
  "tsumagoi.gunma.jp": 1,
  "tsunan.niigata.jp": 1,
  "tsuno.kochi.jp": 1,
  "tsuno.miyazaki.jp": 1,
  "tsuru.yamanashi.jp": 1,
  "tsuruga.fukui.jp": 1,
  "tsurugashima.saitama.jp": 1,
  "tsurugi.ishikawa.jp": 1,
  "tsuruoka.yamagata.jp": 1,
  "tsuruta.aomori.jp": 1,
  "tsushima.aichi.jp": 1,
  "tsushima.nagasaki.jp": 1,
  "tsuwano.shimane.jp": 1,
  "tsuyama.okayama.jp": 1,
  "tt": 1,
  "tt.im": 1,
  "tube": 1,
  "tui": 1,
  "tula.su": 1,
  "tunes": 1,
  "tunk.org": 1,
  "tur.ar": 1,
  "tur.br": 1,
  "turek.pl": 1,
  "turen.tn": 1,
  "turin.it": 1,
  "turystyka.pl": 1,
  "tuscany.it": 1,
  "tushu": 1,
  "tuva.su": 1,
  "tuxfamily.org": 1,
  "tv": 1,
  "tv.bb": 1,
  "tv.bo": 1,
  "tv.br": 1,
  "tv.im": 1,
  "tv.it": 1,
  "tv.kg": 1,
  "tv.na": 1,
  "tv.sd": 1,
  "tv.tr": 1,
  "tv.tz": 1,
  "tvedestrand.no": 1,
  "tvs": 1,
  "tw": 1,
  "tw.cn": 1,
  "twmail.cc": 1,
  "twmail.net": 1,
  "twmail.org": 1,
  "tx.us": 1,
  "tychy.pl": 1,
  "tydal.no": 1,
  "tynset.no": 1,
  "tysfjord.no": 1,
  "tysnes.no": 1,
  "tysvar.no": 1,
  "tz": 1,
  "u.bg": 1,
  "u.channelsdvr.net": 1,
  "u.se": 1,
  "u2-local.xnbay.com": 1,
  "u2.xnbay.com": 1,
  "ua": 1,
  "ua.rs": 1,
  "ubank": 1,
  "ube.yamaguchi.jp": 1,
  "uber.space": 1,
  "ubs": 1,
  "uchihara.ibaraki.jp": 1,
  "uchiko.ehime.jp": 1,
  "uchinada.ishikawa.jp": 1,
  "uchinomi.kagawa.jp": 1,
  "ud.it": 1,
  "uda.nara.jp": 1,
  "udi.br": 1,
  "udine.it": 1,
  "udono.mie.jp": 1,
  "ueda.nagano.jp": 1,
  "ueno.gunma.jp": 1,
  "uenohara.yamanashi.jp": 1,
  "ufcfan.org": 1,
  "ug": 1,
  "ug.gov.pl": 1,
  "ugim.gov.pl": 1,
  "uhren.museum": 1,
  "ui.nabu.casa": 1,
  "uji.kyoto.jp": 1,
  "ujiie.tochigi.jp": 1,
  "ujitawara.kyoto.jp": 1,
  "uk": 1,
  "uk.com": 1,
  "uk.eu.org": 1,
  "uk.kg": 1,
  "uk.net": 1,
  "uk0.bigv.io": 1,
  "ukco.me": 1,
  "uki.kumamoto.jp": 1,
  "ukiha.fukuoka.jp": 1,
  "uklugs.org": 1,
  "ullensaker.no": 1,
  "ullensvang.no": 1,
  "ulm.museum": 1,
  "ulsan.kr": 1,
  "ulvik.no": 1,
  "um.gov.pl": 1,
  "umaji.kochi.jp": 1,
  "umb.it": 1,
  "umbria.it": 1,
  "umi.fukuoka.jp": 1,
  "umig.gov.pl": 1,
  "unazuki.toyama.jp": 1,
  "undersea.museum": 1,
  "uni5.net": 1,
  "unicom": 1,
  "union.aero": 1,
  "univ.sn": 1,
  "university": 1,
  "university.museum": 1,
  "unjarga.no": 1,
  "unnan.shimane.jp": 1,
  "uno": 1,
  "unusualperson.com": 1,
  "unzen.nagasaki.jp": 1,
  "uol": 1,
  "uonuma.niigata.jp": 1,
  "uozu.toyama.jp": 1,
  "upow.gov.pl": 1,
  "uppo.gov.pl": 1,
  "ups": 1,
  "urakawa.hokkaido.jp": 1,
  "urasoe.okinawa.jp": 1,
  "urausu.hokkaido.jp": 1,
  "urawa.saitama.jp": 1,
  "urayasu.chiba.jp": 1,
  "urbino-pesaro.it": 1,
  "urbinopesaro.it": 1,
  "ureshino.mie.jp": 1,
  "uri.arpa": 1,
  "url.tw": 1,
  "urn.arpa": 1,
  "urown.cloud": 1,
  "uruma.okinawa.jp": 1,
  "uryu.hokkaido.jp": 1,
  "us": 1,
  "us-1.evennode.com": 1,
  "us-2.evennode.com": 1,
  "us-3.evennode.com": 1,
  "us-4.evennode.com": 1,
  "us-east-1.amazonaws.com": 1,
  "us-east-1.elasticbeanstalk.com": 1,
  "us-east-2.elasticbeanstalk.com": 1,
  "us-gov-west-1.elasticbeanstalk.com": 1,
  "us-west-1.elasticbeanstalk.com": 1,
  "us-west-2.elasticbeanstalk.com": 1,
  "us.ax": 1,
  "us.com": 1,
  "us.eu.org": 1,
  "us.gov.pl": 1,
  "us.kg": 1,
  "us.na": 1,
  "us.org": 1,
  "us.platform.sh": 1,
  "usa.museum": 1,
  "usa.oita.jp": 1,
  "usantiques.museum": 1,
  "usarts.museum": 1,
  "uscountryestate.museum": 1,
  "usculture.museum": 1,
  "usdecorativearts.museum": 1,
  "user.aseinet.ne.jp": 1,
  "user.party.eus": 1,
  "user.srcf.net": 1,
  "usercontent.jp": 1,
  "usgarden.museum": 1,
  "ushiku.ibaraki.jp": 1,
  "ushistory.museum": 1,
  "ushuaia.museum": 1,
  "uslivinghistory.museum": 1,
  "usr.cloud.muni.cz": 1,
  "ustka.pl": 1,
  "usui.fukuoka.jp": 1,
  "usuki.oita.jp": 1,
  "ut.us": 1,
  "utah.museum": 1,
  "utashinai.hokkaido.jp": 1,
  "utazas.hu": 1,
  "utazu.kagawa.jp": 1,
  "uto.kumamoto.jp": 1,
  "utsira.no": 1,
  "utsunomiya.tochigi.jp": 1,
  "utwente.io": 1,
  "uvic.museum": 1,
  "uw.gov.pl": 1,
  "uwajima.ehime.jp": 1,
  "uwu.ai": 1,
  "uwu.nu": 1,
  "uy": 1,
  "uy.com": 1,
  "uz": 1,
  "uz.ua": 1,
  "uzhgorod.ua": 1,
  "uzs.gov.pl": 1,
  "v-info.info": 1,
  "v.bg": 1,
  "v.ua": 1,
  "va": 1,
  "va.it": 1,
  "va.no": 1,
  "va.us": 1,
  "vaapste.no": 1,
  "vacations": 1,
  "vadso.no": 1,
  "vaga.no": 1,
  "vagan.no": 1,
  "vagsoy.no": 1,
  "vaksdal.no": 1,
  "val-d-aosta.it": 1,
  "val-daosta.it": 1,
  "vald-aosta.it": 1,
  "valdaosta.it": 1,
  "valer.hedmark.no": 1,
  "valer.ostfold.no": 1,
  "valle-aosta.it": 1,
  "valle-d-aosta.it": 1,
  "valle-daosta.it": 1,
  "valle.no": 1,
  "valleaosta.it": 1,
  "valled-aosta.it": 1,
  "valledaosta.it": 1,
  "vallee-aoste.it": 1,
  "vallee-d-aoste.it": 1,
  "valleeaoste.it": 1,
  "valleedaoste.it": 1,
  "valley.museum": 1,
  "vana": 1,
  "vang.no": 1,
  "vanguard": 1,
  "vantaa.museum": 1,
  "vanylven.no": 1,
  "vao.it": 1,
  "vapor.cloud": 1,
  "vaporcloud.io": 1,
  "vardo.no": 1,
  "varese.it": 1,
  "varggat.no": 1,
  "varoy.no": 1,
  "vb.it": 1,
  "vc": 1,
  "vc.it": 1,
  "vda.it": 1,
  "ve": 1,
  "ve.it": 1,
  "vefsn.no": 1,
  "vega.no": 1,
  "vegarshei.no": 1,
  "vegas": 1,
  "ven.it": 1,
  "veneto.it": 1,
  "venezia.it": 1,
  "venice.it": 1,
  "vennesla.no": 1,
  "ventures": 1,
  "verbania.it": 1,
  "vercel.app": 1,
  "vercel.dev": 1,
  "vercelli.it": 1,
  "verdal.no": 1,
  "verisign": 1,
  "verona.it": 1,
  "verran.no": 1,
  "versailles.museum": 1,
  "versicherung": 1,
  "vestby.no": 1,
  "vestnes.no": 1,
  "vestre-slidre.no": 1,
  "vestre-toten.no": 1,
  "vestvagoy.no": 1,
  "vet": 1,
  "vet.br": 1,
  "veterinaire.fr": 1,
  "veterinaire.km": 1,
  "vevelstad.no": 1,
  "vf.no": 1,
  "vg": 1,
  "vgs.no": 1,
  "vi": 1,
  "vi.it": 1,
  "vi.us": 1,
  "viajes": 1,
  "vibo-valentia.it": 1,
  "vibovalentia.it": 1,
  "vic.au": 1,
  "vic.edu.au": 1,
  "vic.gov.au": 1,
  "vicenza.it": 1,
  "video": 1,
  "video.hu": 1,
  "vig": 1,
  "vik.no": 1,
  "viking": 1,
  "viking.museum": 1,
  "vikna.no": 1,
  "village.museum": 1,
  "villas": 1,
  "vin": 1,
  "vindafjord.no": 1,
  "vinnica.ua": 1,
  "vinnytsia.ua": 1,
  "vip": 1,
  "vipsinaapp.com": 1,
  "virgin": 1,
  "virginia.museum": 1,
  "virtual-user.de": 1,
  "virtual.museum": 1,
  "virtualserver.io": 1,
  "virtualuser.de": 1,
  "virtueeldomein.nl": 1,
  "virtuel.museum": 1,
  "visa": 1,
  "vision": 1,
  "viterbo.it": 1,
  "viva": 1,
  "vivo": 1,
  "vix.br": 1,
  "vlaanderen": 1,
  "vlaanderen.museum": 1,
  "vladikavkaz.ru": 1,
  "vladikavkaz.su": 1,
  "vladimir.ru": 1,
  "vladimir.su": 1,
  "vlog.br": 1,
  "vm.bytemark.co.uk": 1,
  "vn": 1,
  "vn.ua": 1,
  "voagat.no": 1,
  "vodka": 1,
  "volda.no": 1,
  "volkenkunde.museum": 1,
  "volkswagen": 1,
  "vologda.su": 1,
  "volvo": 1,
  "volyn.ua": 1,
  "voorloper.cloud": 1,
  "voss.no": 1,
  "vossevangen.no": 1,
  "vote": 1,
  "voting": 1,
  "voto": 1,
  "voyage": 1,
  "vpndns.net": 1,
  "vpnplus.to": 1,
  "vps.mcdir.ru": 1,
  "vr.it": 1,
  "vs.it": 1,
  "vs.mythic-beasts.com": 1,
  "vt.it": 1,
  "vt.us": 1,
  "vu": 1,
  "vuelos": 1,
  "vv.it": 1,
  "vxl.sh": 1,
  "w.bg": 1,
  "w.se": 1,
  "wa.au": 1,
  "wa.edu.au": 1,
  "wa.gov.au": 1,
  "wa.us": 1,
  "wada.nagano.jp": 1,
  "wafflecell.com": 1,
  "wajiki.tokushima.jp": 1,
  "wajima.ishikawa.jp": 1,
  "wakasa.fukui.jp": 1,
  "wakasa.tottori.jp": 1,
  "wakayama.jp": 1,
  "wakayama.wakayama.jp": 1,
  "wake.okayama.jp": 1,
  "wakkanai.hokkaido.jp": 1,
  "wakuya.miyagi.jp": 1,
  "walbrzych.pl": 1,
  "wales": 1,
  "wales.museum": 1,
  "wallonie.museum": 1,
  "walmart": 1,
  "walter": 1,
  "wang": 1,
  "wanggou": 1,
  "wanouchi.gifu.jp": 1,
  "war.museum": 1,
  "warabi.saitama.jp": 1,
  "warmia.pl": 1,
  "warszawa.pl": 1,
  "washingtondc.museum": 1,
  "washtenaw.mi.us": 1,
  "wassamu.hokkaido.jp": 1,
  "watarai.mie.jp": 1,
  "watari.miyagi.jp": 1,
  "watch": 1,
  "watch-and-clock.museum": 1,
  "watchandclock.museum": 1,
  "watches": 1,
  "waw.pl": 1,
  "wazuka.kyoto.jp": 1,
  "we.bs": 1,
  "we.tc": 1,
  "weather": 1,
  "weatherchannel": 1,
  "web.app": 1,
  "web.bo": 1,
  "web.co": 1,
  "web.do": 1,
  "web.gu": 1,
  "web.id": 1,
  "web.lk": 1,
  "web.nf": 1,
  "web.ni": 1,
  "web.pk": 1,
  "web.tj": 1,
  "web.tr": 1,
  "web.ve": 1,
  "web.za": 1,
  "webcam": 1,
  "weber": 1,
  "webhop.biz": 1,
  "webhop.info": 1,
  "webhop.me": 1,
  "webhop.net": 1,
  "webhop.org": 1,
  "webhosting.be": 1,
  "webredirect.org": 1,
  "website": 1,
  "website.yandexcloud.net": 1,
  "webspace.rocks": 1,
  "wed": 1,
  "wedding": 1,
  "wedeploy.io": 1,
  "wedeploy.me": 1,
  "wedeploy.sh": 1,
  "wegrow.pl": 1,
  "weibo": 1,
  "weir": 1,
  "wellbeingzone.co.uk": 1,
  "wellbeingzone.eu": 1,
  "western.museum": 1,
  "westfalen.museum": 1,
  "wf": 1,
  "whaling.museum": 1,
  "whoswho": 1,
  "wi.us": 1,
  "wielun.pl": 1,
  "wien": 1,
  "wien.funkfeuer.at": 1,
  "wif.gov.pl": 1,
  "wiih.gov.pl": 1,
  "wiki": 1,
  "wiki.bo": 1,
  "wiki.br": 1,
  "wildlife.museum": 1,
  "williamhill": 1,
  "williamsburg.museum": 1,
  "win": 1,
  "winb.gov.pl": 1,
  "windmill.museum": 1,
  "windows": 1,
  "wine": 1,
  "winners": 1,
  "wios.gov.pl": 1,
  "witd.gov.pl": 1,
  "withgoogle.com": 1,
  "withyoutube.com": 1,
  "wiw.gov.pl": 1,
  "wlocl.pl": 1,
  "wloclawek.pl": 1,
  "wmcloud.org": 1,
  "wme": 1,
  "wmflabs.org": 1,
  "wnext.app": 1,
  "wodzislaw.pl": 1,
  "wolomin.pl": 1,
  "wolterskluwer": 1,
  "woodside": 1,
  "work": 1,
  "workers.dev": 1,
  "workinggroup.aero": 1,
  "workisboring.com": 1,
  "works": 1,
  "works.aero": 1,
  "workshop.museum": 1,
  "world": 1,
  "worse-than.tv": 1,
  "wow": 1,
  "wpdevcloud.com": 1,
  "wpenginepowered.com": 1,
  "writesthisblog.com": 1,
  "wroc.pl": 1,
  "wroclaw.pl": 1,
  "ws": 1,
  "ws.na": 1,
  "wsa.gov.pl": 1,
  "wskr.gov.pl": 1,
  "wtc": 1,
  "wtf": 1,
  "wuoz.gov.pl": 1,
  "wv.us": 1,
  "www.ro": 1,
  "wy.us": 1,
  "wzmiuw.gov.pl": 1,
  "x.bg": 1,
  "x.mythic-beasts.com": 1,
  "x.se": 1,
  "x443.pw": 1,
  "xbox": 1,
  "xen.prgmr.com": 1,
  "xenapponazure.com": 1,
  "xerox": 1,
  "xfinity": 1,
  "xihuan": 1,
  "xin": 1,
  "xj.cn": 1,
  "xn--0trq7p7nn.jp": 1,
  "xn--11b4c3d": 1,
  "xn--12c1fe0br.xn--o3cw4h": 1,
  "xn--12cfi8ixb8l.xn--o3cw4h": 1,
  "xn--12co0c3b4eva.xn--o3cw4h": 1,
  "xn--1ck2e1b": 1,
  "xn--1ctwo.jp": 1,
  "xn--1lqs03n.jp": 1,
  "xn--1lqs71d.jp": 1,
  "xn--1qqw23a": 1,
  "xn--2m4a15e.jp": 1,
  "xn--2scrj9c": 1,
  "xn--30rr7y": 1,
  "xn--32vp30h.jp": 1,
  "xn--3bst00m": 1,
  "xn--3ds443g": 1,
  "xn--3e0b707e": 1,
  "xn--3hcrj9c": 1,
  "xn--3oq18vl8pn36a": 1,
  "xn--3pxu8k": 1,
  "xn--42c2d9a": 1,
  "xn--45br5cyl": 1,
  "xn--45brj9c": 1,
  "xn--45q11c": 1,
  "xn--4gbrim": 1,
  "xn--4it168d.jp": 1,
  "xn--4it797k.jp": 1,
  "xn--4pvxs.jp": 1,
  "xn--54b7fta0cc": 1,
  "xn--55qw42g": 1,
  "xn--55qx5d": 1,
  "xn--55qx5d.cn": 1,
  "xn--55qx5d.hk": 1,
  "xn--55qx5d.xn--j6w193g": 1,
  "xn--5js045d.jp": 1,
  "xn--5rtp49c.jp": 1,
  "xn--5rtq34k.jp": 1,
  "xn--5su34j936bgsg": 1,
  "xn--5tzm5g": 1,
  "xn--6btw5a.jp": 1,
  "xn--6frz82g": 1,
  "xn--6orx2r.jp": 1,
  "xn--6qq986b3xl": 1,
  "xn--7t0a264c.jp": 1,
  "xn--80adxhks": 1,
  "xn--80ao21a": 1,
  "xn--80aqecdr1a": 1,
  "xn--80asehdb": 1,
  "xn--80aswg": 1,
  "xn--80au.xn--90a3ac": 1,
  "xn--8ltr62k.jp": 1,
  "xn--8pvr4u.jp": 1,
  "xn--8y0a063a": 1,
  "xn--90a3ac": 1,
  "xn--90ae": 1,
  "xn--90ais": 1,
  "xn--90azh.xn--90a3ac": 1,
  "xn--9dbhblg6di.museum": 1,
  "xn--9dbq2a": 1,
  "xn--9et52u": 1,
  "xn--9krt00a": 1,
  "xn--andy-ira.no": 1,
  "xn--aroport-bya.ci": 1,
  "xn--asky-ira.no": 1,
  "xn--aurskog-hland-jnb.no": 1,
  "xn--avery-yua.no": 1,
  "xn--b-5ga.nordland.no": 1,
  "xn--b-5ga.telemark.no": 1,
  "xn--b4w605ferd": 1,
  "xn--balsan-sdtirol-nsb.it": 1,
  "xn--bck1b9a5dre4c": 1,
  "xn--bdddj-mrabd.no": 1,
  "xn--bearalvhki-y4a.no": 1,
  "xn--berlevg-jxa.no": 1,
  "xn--bhcavuotna-s4a.no": 1,
  "xn--bhccavuotna-k7a.no": 1,
  "xn--bidr-5nac.no": 1,
  "xn--bievt-0qa.no": 1,
  "xn--bjarky-fya.no": 1,
  "xn--bjddar-pta.no": 1,
  "xn--blt-elab.no": 1,
  "xn--bmlo-gra.no": 1,
  "xn--bod-2na.no": 1,
  "xn--bozen-sdtirol-2ob.it": 1,
  "xn--brnny-wuac.no": 1,
  "xn--brnnysund-m8ac.no": 1,
  "xn--brum-voa.no": 1,
  "xn--btsfjord-9za.no": 1,
  "xn--bulsan-sdtirol-nsb.it": 1,
  "xn--c1avg": 1,
  "xn--c1avg.xn--90a3ac": 1,
  "xn--c2br7g": 1,
  "xn--c3s14m.jp": 1,
  "xn--cck2b3b": 1,
  "xn--cckwcxetd": 1,
  "xn--cesena-forl-mcb.it": 1,
  "xn--cesenaforl-i8a.it": 1,
  "xn--cg4bki": 1,
  "xn--ciqpn.hk": 1,
  "xn--clchc0ea0b2g2a9gcd": 1,
  "xn--comunicaes-v6a2o.museum": 1,
  "xn--correios-e-telecomunicaes-ghc29a.museum": 1,
  "xn--czr694b": 1,
  "xn--czrs0t": 1,
  "xn--czru2d": 1,
  "xn--czrw28b.tw": 1,
  "xn--d1acj3b": 1,
  "xn--d1alf": 1,
  "xn--d1at.xn--90a3ac": 1,
  "xn--d5qv7z876c.jp": 1,
  "xn--davvenjrga-y4a.no": 1,
  "xn--djrs72d6uy.jp": 1,
  "xn--djty4k.jp": 1,
  "xn--dnna-gra.no": 1,
  "xn--drbak-wua.no": 1,
  "xn--dyry-ira.no": 1,
  "xn--e1a4c": 1,
  "xn--eckvdtc9d": 1,
  "xn--efvn9s.jp": 1,
  "xn--efvy88h": 1,
  "xn--ehqz56n.jp": 1,
  "xn--elqq16h.jp": 1,
  "xn--eveni-0qa01ga.no": 1,
  "xn--f6qx53a.jp": 1,
  "xn--fct429k": 1,
  "xn--fhbei": 1,
  "xn--finny-yua.no": 1,
  "xn--fiq228c5hs": 1,
  "xn--fiq64b": 1,
  "xn--fiqs8s": 1,
  "xn--fiqz9s": 1,
  "xn--fjord-lra.no": 1,
  "xn--fjq720a": 1,
  "xn--fl-zia.no": 1,
  "xn--flor-jra.no": 1,
  "xn--flw351e": 1,
  "xn--forl-cesena-fcb.it": 1,
  "xn--forlcesena-c8a.it": 1,
  "xn--fpcrj9c3d": 1,
  "xn--frde-gra.no": 1,
  "xn--frna-woa.no": 1,
  "xn--frya-hra.no": 1,
  "xn--fzc2c9e2c": 1,
  "xn--fzys8d69uvgm": 1,
  "xn--g2xx48c": 1,
  "xn--gckr3f0f": 1,
  "xn--gecrj9c": 1,
  "xn--ggaviika-8ya47h.no": 1,
  "xn--gildeskl-g0a.no": 1,
  "xn--givuotna-8ya.no": 1,
  "xn--gjvik-wua.no": 1,
  "xn--gk3at1e": 1,
  "xn--gls-elac.no": 1,
  "xn--gmq050i.hk": 1,
  "xn--gmqw5a.hk": 1,
  "xn--gmqw5a.xn--j6w193g": 1,
  "xn--h-2fa.no": 1,
  "xn--h1aegh.museum": 1,
  "xn--h2breg3eve": 1,
  "xn--h2brj9c": 1,
  "xn--h2brj9c8c": 1,
  "xn--h3cuzk1di.xn--o3cw4h": 1,
  "xn--hbmer-xqa.no": 1,
  "xn--hcesuolo-7ya35b.no": 1,
  "xn--hery-ira.nordland.no": 1,
  "xn--hery-ira.xn--mre-og-romsdal-qqb.no": 1,
  "xn--hgebostad-g3a.no": 1,
  "xn--hkkinen-5wa.fi": 1,
  "xn--hmmrfeasta-s4ac.no": 1,
  "xn--hnefoss-q1a.no": 1,
  "xn--hobl-ira.no": 1,
  "xn--holtlen-hxa.no": 1,
  "xn--hpmir-xqa.no": 1,
  "xn--hxt814e": 1,
  "xn--hyanger-q1a.no": 1,
  "xn--hylandet-54a.no": 1,
  "xn--i1b6b1a6a2e": 1,
  "xn--imr513n": 1,
  "xn--indery-fya.no": 1,
  "xn--io0a7i": 1,
  "xn--io0a7i.cn": 1,
  "xn--io0a7i.hk": 1,
  "xn--j1aef": 1,
  "xn--j1amh": 1,
  "xn--j6w193g": 1,
  "xn--jlq480n2rg": 1,
  "xn--jlq61u9w7b": 1,
  "xn--jlster-bya.no": 1,
  "xn--jrpeland-54a.no": 1,
  "xn--jvr189m": 1,
  "xn--k7yn95e.jp": 1,
  "xn--karmy-yua.no": 1,
  "xn--kbrq7o.jp": 1,
  "xn--kcrx77d1x4a": 1,
  "xn--kfjord-iua.no": 1,
  "xn--klbu-woa.no": 1,
  "xn--klt787d.jp": 1,
  "xn--kltp7d.jp": 1,
  "xn--kltx9a.jp": 1,
  "xn--klty5x.jp": 1,
  "xn--koluokta-7ya57h.no": 1,
  "xn--kprw13d": 1,
  "xn--kpry57d": 1,
  "xn--kput3i": 1,
  "xn--krager-gya.no": 1,
  "xn--kranghke-b0a.no": 1,
  "xn--krdsherad-m8a.no": 1,
  "xn--krehamn-dxa.no": 1,
  "xn--krjohka-hwab49j.no": 1,
  "xn--ksnes-uua.no": 1,
  "xn--kvfjord-nxa.no": 1,
  "xn--kvitsy-fya.no": 1,
  "xn--kvnangen-k0a.no": 1,
  "xn--l-1fa.no": 1,
  "xn--l1acc": 1,
  "xn--laheadju-7ya.no": 1,
  "xn--langevg-jxa.no": 1,
  "xn--lcvr32d.hk": 1,
  "xn--ldingen-q1a.no": 1,
  "xn--leagaviika-52b.no": 1,
  "xn--lesund-hua.no": 1,
  "xn--lgbbat1ad8j": 1,
  "xn--lgrd-poac.no": 1,
  "xn--lhppi-xqa.no": 1,
  "xn--linds-pra.no": 1,
  "xn--lns-qla.museum": 1,
  "xn--loabt-0qa.no": 1,
  "xn--lrdal-sra.no": 1,
  "xn--lrenskog-54a.no": 1,
  "xn--lt-liac.no": 1,
  "xn--lten-gra.no": 1,
  "xn--lury-ira.no": 1,
  "xn--m3ch0j3a.xn--o3cw4h": 1,
  "xn--mely-ira.no": 1,
  "xn--merker-kua.no": 1,
  "xn--mgb2ddes": 1,
  "xn--mgb9awbf": 1,
  "xn--mgba3a3ejt": 1,
  "xn--mgba3a4f16a": 1,
  "xn--mgba3a4f16a.ir": 1,
  "xn--mgba3a4fra": 1,
  "xn--mgba3a4fra.ir": 1,
  "xn--mgba7c0bbn0a": 1,
  "xn--mgbaakc7dvf": 1,
  "xn--mgbaam7a8h": 1,
  "xn--mgbab2bd": 1,
  "xn--mgbah1a3hjkrd": 1,
  "xn--mgbai9a5eva00b": 1,
  "xn--mgbai9azgqp6j": 1,
  "xn--mgbayh7gpa": 1,
  "xn--mgbbh1a": 1,
  "xn--mgbbh1a71e": 1,
  "xn--mgbc0a9azcg": 1,
  "xn--mgbca7dzdo": 1,
  "xn--mgberp4a5d4a87g": 1,
  "xn--mgberp4a5d4ar": 1,
  "xn--mgbgu82a": 1,
  "xn--mgbi4ecexp": 1,
  "xn--mgbpl2fh": 1,
  "xn--mgbqly7c0a67fbc": 1,
  "xn--mgbqly7cvafr": 1,
  "xn--mgbt3dhd": 1,
  "xn--mgbtf8fl": 1,
  "xn--mgbtx2b": 1,
  "xn--mgbx4cd0ab": 1,
  "xn--mix082f": 1,
  "xn--mix891f": 1,
  "xn--mjndalen-64a.no": 1,
  "xn--mk0axi.hk": 1,
  "xn--mk1bu44c": 1,
  "xn--mkru45i.jp": 1,
  "xn--mlatvuopmi-s4a.no": 1,
  "xn--mli-tla.no": 1,
  "xn--mlselv-iua.no": 1,
  "xn--moreke-jua.no": 1,
  "xn--mori-qsa.nz": 1,
  "xn--mosjen-eya.no": 1,
  "xn--mot-tla.no": 1,
  "xn--msy-ula0h.no": 1,
  "xn--mtta-vrjjat-k7af.no": 1,
  "xn--muost-0qa.no": 1,
  "xn--mxtq1m": 1,
  "xn--mxtq1m.hk": 1,
  "xn--mxtq1m.xn--j6w193g": 1,
  "xn--ngbc5azd": 1,
  "xn--ngbe9e0a": 1,
  "xn--ngbrx": 1,
  "xn--nit225k.jp": 1,
  "xn--nmesjevuemie-tcba.no": 1,
  "xn--nnx388a": 1,
  "xn--node": 1,
  "xn--nqv7f": 1,
  "xn--nqv7fs00ema": 1,
  "xn--nry-yla5g.no": 1,
  "xn--ntso0iqx3a.jp": 1,
  "xn--ntsq17g.jp": 1,
  "xn--nttery-byae.no": 1,
  "xn--nvuotna-hwa.no": 1,
  "xn--nyqy26a": 1,
  "xn--o1ac.xn--90a3ac": 1,
  "xn--o1ach.xn--90a3ac": 1,
  "xn--o3cw4h": 1,
  "xn--o3cyx2a.xn--o3cw4h": 1,
  "xn--od0alg.cn": 1,
  "xn--od0alg.hk": 1,
  "xn--od0alg.xn--j6w193g": 1,
  "xn--od0aq3b.hk": 1,
  "xn--ogbpf8fl": 1,
  "xn--oppegrd-ixa.no": 1,
  "xn--ostery-fya.no": 1,
  "xn--osyro-wua.no": 1,
  "xn--otu796d": 1,
  "xn--p1acf": 1,
  "xn--p1ai": 1,
  "xn--pgbs0dh": 1,
  "xn--porsgu-sta26f.no": 1,
  "xn--pssu33l.jp": 1,
  "xn--pssy2u": 1,
  "xn--q9jyb4c": 1,
  "xn--qcka1pmc": 1,
  "xn--qqqt11m.jp": 1,
  "xn--qxa6a": 1,
  "xn--qxam": 1,
  "xn--rady-ira.no": 1,
  "xn--rdal-poa.no": 1,
  "xn--rde-ula.no": 1,
  "xn--rdy-0nab.no": 1,
  "xn--rennesy-v1a.no": 1,
  "xn--rhkkervju-01af.no": 1,
  "xn--rholt-mra.no": 1,
  "xn--rhqv96g": 1,
  "xn--rht27z.jp": 1,
  "xn--rht3d.jp": 1,
  "xn--rht61e.jp": 1,
  "xn--risa-5na.no": 1,
  "xn--risr-ira.no": 1,
  "xn--rland-uua.no": 1,
  "xn--rlingen-mxa.no": 1,
  "xn--rmskog-bya.no": 1,
  "xn--rny31h.jp": 1,
  "xn--rovu88b": 1,
  "xn--rros-gra.no": 1,
  "xn--rskog-uua.no": 1,
  "xn--rst-0na.no": 1,
  "xn--rsta-fra.no": 1,
  "xn--rvc1e0am3e": 1,
  "xn--ryken-vua.no": 1,
  "xn--ryrvik-bya.no": 1,
  "xn--s-1fa.no": 1,
  "xn--s9brj9c": 1,
  "xn--sandnessjen-ogb.no": 1,
  "xn--sandy-yua.no": 1,
  "xn--sdtirol-n2a.it": 1,
  "xn--seral-lra.no": 1,
  "xn--ses554g": 1,
  "xn--sgne-gra.no": 1,
  "xn--skierv-uta.no": 1,
  "xn--skjervy-v1a.no": 1,
  "xn--skjk-soa.no": 1,
  "xn--sknit-yqa.no": 1,
  "xn--sknland-fxa.no": 1,
  "xn--slat-5na.no": 1,
  "xn--slt-elab.no": 1,
  "xn--smla-hra.no": 1,
  "xn--smna-gra.no": 1,
  "xn--snase-nra.no": 1,
  "xn--sndre-land-0cb.no": 1,
  "xn--snes-poa.no": 1,
  "xn--snsa-roa.no": 1,
  "xn--sr-aurdal-l8a.no": 1,
  "xn--sr-fron-q1a.no": 1,
  "xn--sr-odal-q1a.no": 1,
  "xn--sr-varanger-ggb.no": 1,
  "xn--srfold-bya.no": 1,
  "xn--srreisa-q1a.no": 1,
  "xn--srum-gra.no": 1,
  "xn--stjrdal-s1a.no": 1,
  "xn--stjrdalshalsen-sqb.no": 1,
  "xn--stre-toten-zcb.no": 1,
  "xn--t60b56a": 1,
  "xn--tckwe": 1,
  "xn--tiq49xqyj": 1,
  "xn--tjme-hra.no": 1,
  "xn--tn0ag.hk": 1,
  "xn--tnsberg-q1a.no": 1,
  "xn--tor131o.jp": 1,
  "xn--trany-yua.no": 1,
  "xn--trentin-sd-tirol-rzb.it": 1,
  "xn--trentin-sdtirol-7vb.it": 1,
  "xn--trentino-sd-tirol-c3b.it": 1,
  "xn--trentino-sdtirol-szb.it": 1,
  "xn--trentinosd-tirol-rzb.it": 1,
  "xn--trentinosdtirol-7vb.it": 1,
  "xn--trentinsd-tirol-6vb.it": 1,
  "xn--trentinsdtirol-nsb.it": 1,
  "xn--trgstad-r1a.no": 1,
  "xn--trna-woa.no": 1,
  "xn--troms-zua.no": 1,
  "xn--tysvr-vra.no": 1,
  "xn--uc0atv.hk": 1,
  "xn--uc0atv.tw": 1,
  "xn--uc0atv.xn--j6w193g": 1,
  "xn--uc0ay4a.hk": 1,
  "xn--uist22h.jp": 1,
  "xn--uisz3g.jp": 1,
  "xn--unjrga-rta.no": 1,
  "xn--unup4y": 1,
  "xn--uuwu58a.jp": 1,
  "xn--vads-jra.no": 1,
  "xn--valle-aoste-ebb.it": 1,
  "xn--valle-d-aoste-ehb.it": 1,
  "xn--valleaoste-e7a.it": 1,
  "xn--valledaoste-ebb.it": 1,
  "xn--vard-jra.no": 1,
  "xn--vegrshei-c0a.no": 1,
  "xn--vermgensberater-ctb": 1,
  "xn--vermgensberatung-pwb": 1,
  "xn--vestvgy-ixa6o.no": 1,
  "xn--vg-yiab.no": 1,
  "xn--vgan-qoa.no": 1,
  "xn--vgsy-qoa0j.no": 1,
  "xn--vgu402c.jp": 1,
  "xn--vhquv": 1,
  "xn--vler-qoa.hedmark.no": 1,
  "xn--vler-qoa.xn--stfold-9xa.no": 1,
  "xn--vre-eiker-k8a.no": 1,
  "xn--vrggt-xqad.no": 1,
  "xn--vry-yla5g.no": 1,
  "xn--vuq861b": 1,
  "xn--w4r85el8fhu5dnra": 1,
  "xn--w4rs40l": 1,
  "xn--wcvs22d.hk": 1,
  "xn--wcvs22d.xn--j6w193g": 1,
  "xn--wgbh1c": 1,
  "xn--wgbl6a": 1,
  "xn--xhq521b": 1,
  "xn--xkc2al3hye2a": 1,
  "xn--xkc2dl3a5ee0h": 1,
  "xn--y9a3aq": 1,
  "xn--yer-zna.no": 1,
  "xn--yfro4i67o": 1,
  "xn--ygarden-p1a.no": 1,
  "xn--ygbi2ammx": 1,
  "xn--ystre-slidre-ujb.no": 1,
  "xn--zbx025d.jp": 1,
  "xn--zf0ao64a.tw": 1,
  "xn--zf0avx.hk": 1,
  "xn--zfr164b": 1,
  "xnbay.com": 1,
  "xs4all.space": 1,
  "xx.gl": 1,
  "xxx": 1,
  "xy.ax": 1,
  "xyz": 1,
  "xz.cn": 1,
  "y.bg": 1,
  "y.se": 1,
  "yabu.hyogo.jp": 1,
  "yabuki.fukushima.jp": 1,
  "yachimata.chiba.jp": 1,
  "yachiyo.chiba.jp": 1,
  "yachiyo.ibaraki.jp": 1,
  "yachts": 1,
  "yaese.okinawa.jp": 1,
  "yahaba.iwate.jp": 1,
  "yahiko.niigata.jp": 1,
  "yahoo": 1,
  "yaita.tochigi.jp": 1,
  "yaizu.shizuoka.jp": 1,
  "yakage.okayama.jp": 1,
  "yakumo.hokkaido.jp": 1,
  "yakumo.shimane.jp": 1,
  "yali.mythic-beasts.com": 1,
  "yalta.ua": 1,
  "yamada.fukuoka.jp": 1,
  "yamada.iwate.jp": 1,
  "yamada.toyama.jp": 1,
  "yamaga.kumamoto.jp": 1,
  "yamagata.gifu.jp": 1,
  "yamagata.ibaraki.jp": 1,
  "yamagata.jp": 1,
  "yamagata.nagano.jp": 1,
  "yamagata.yamagata.jp": 1,
  "yamaguchi.jp": 1,
  "yamakita.kanagawa.jp": 1,
  "yamamoto.miyagi.jp": 1,
  "yamanakako.yamanashi.jp": 1,
  "yamanashi.jp": 1,
  "yamanashi.yamanashi.jp": 1,
  "yamanobe.yamagata.jp": 1,
  "yamanouchi.nagano.jp": 1,
  "yamashina.kyoto.jp": 1,
  "yamato.fukushima.jp": 1,
  "yamato.kanagawa.jp": 1,
  "yamato.kumamoto.jp": 1,
  "yamatokoriyama.nara.jp": 1,
  "yamatotakada.nara.jp": 1,
  "yamatsuri.fukushima.jp": 1,
  "yamaxun": 1,
  "yamazoe.nara.jp": 1,
  "yame.fukuoka.jp": 1,
  "yanagawa.fukuoka.jp": 1,
  "yanaizu.fukushima.jp": 1,
  "yandex": 1,
  "yandexcloud.net": 1,
  "yao.osaka.jp": 1,
  "yaotsu.gifu.jp": 1,
  "yasaka.nagano.jp": 1,
  "yashio.saitama.jp": 1,
  "yashiro.hyogo.jp": 1,
  "yasu.shiga.jp": 1,
  "yasuda.kochi.jp": 1,
  "yasugi.shimane.jp": 1,
  "yasuoka.nagano.jp": 1,
  "yatomi.aichi.jp": 1,
  "yatsuka.shimane.jp": 1,
  "yatsushiro.kumamoto.jp": 1,
  "yawara.ibaraki.jp": 1,
  "yawata.kyoto.jp": 1,
  "yawatahama.ehime.jp": 1,
  "yazu.tottori.jp": 1,
  "ybo.faith": 1,
  "ybo.party": 1,
  "ybo.review": 1,
  "ybo.science": 1,
  "ybo.trade": 1,
  "yk.ca": 1,
  "yn.cn": 1,
  "yodobashi": 1,
  "yoga": 1,
  "yoichi.hokkaido.jp": 1,
  "yoita.niigata.jp": 1,
  "yoka.hyogo.jp": 1,
  "yokaichiba.chiba.jp": 1,
  "yokawa.hyogo.jp": 1,
  "yokkaichi.mie.jp": 1,
  "yokohama": 1,
  "yokoshibahikari.chiba.jp": 1,
  "yokosuka.kanagawa.jp": 1,
  "yokote.akita.jp": 1,
  "yokoze.saitama.jp": 1,
  "yolasite.com": 1,
  "yombo.me": 1,
  "yomitan.okinawa.jp": 1,
  "yonabaru.okinawa.jp": 1,
  "yonago.tottori.jp": 1,
  "yonaguni.okinawa.jp": 1,
  "yonezawa.yamagata.jp": 1,
  "yono.saitama.jp": 1,
  "yorii.saitama.jp": 1,
  "york.museum": 1,
  "yorkshire.museum": 1,
  "yoro.gifu.jp": 1,
  "yosemite.museum": 1,
  "yoshida.saitama.jp": 1,
  "yoshida.shizuoka.jp": 1,
  "yoshikawa.saitama.jp": 1,
  "yoshimi.saitama.jp": 1,
  "yoshino.nara.jp": 1,
  "yoshinogari.saga.jp": 1,
  "yoshioka.gunma.jp": 1,
  "yotsukaido.chiba.jp": 1,
  "you": 1,
  "youth.museum": 1,
  "youtube": 1,
  "yt": 1,
  "yuasa.wakayama.jp": 1,
  "yufu.oita.jp": 1,
  "yugawa.fukushima.jp": 1,
  "yugawara.kanagawa.jp": 1,
  "yuki.ibaraki.jp": 1,
  "yukuhashi.fukuoka.jp": 1,
  "yun": 1,
  "yura.wakayama.jp": 1,
  "yurihonjo.akita.jp": 1,
  "yusuhara.kochi.jp": 1,
  "yusui.kagoshima.jp": 1,
  "yuu.yamaguchi.jp": 1,
  "yuza.yamagata.jp": 1,
  "yuzawa.niigata.jp": 1,
  "z.bg": 1,
  "z.se": 1,
  "za.bz": 1,
  "za.com": 1,
  "za.net": 1,
  "za.org": 1,
  "zachpomor.pl": 1,
  "zagan.pl": 1,
  "zakopane.pl": 1,
  "zama.kanagawa.jp": 1,
  "zamami.okinawa.jp": 1,
  "zao.miyagi.jp": 1,
  "zaporizhzhe.ua": 1,
  "zaporizhzhia.ua": 1,
  "zappos": 1,
  "zapto.org": 1,
  "zapto.xyz": 1,
  "zara": 1,
  "zarow.pl": 1,
  "zentsuji.kagawa.jp": 1,
  "zero": 1,
  "zgora.pl": 1,
  "zgorzelec.pl": 1,
  "zhitomir.ua": 1,
  "zhytomyr.ua": 1,
  "zip": 1,
  "zj.cn": 1,
  "zlg.br": 1,
  "zm": 1,
  "zone": 1,
  "zoological.museum": 1,
  "zoology.museum": 1,
  "zp.gov.pl": 1,
  "zp.ua": 1,
  "zt.ua": 1,
  "zuerich": 1,
  "zushi.kanagawa.jp": 1,
  "zw": 1
}
  //%END_RESERVED_DOMAINS%
  ;
  api.publicSuffixes = publicSuffixes;
})(adguard.utils);
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (api, global) {
    /**
     * Helper methods to work with URLs
     */
    const UrlUtils = {

        isHttpRequest(url) {
            return url && url.indexOf('http') === 0;
        },

        isHttpOrWsRequest(url) {
            return url && (url.indexOf('http') === 0 || url.indexOf('ws') === 0);
        },

        toPunyCode(domain) {
            if (!domain) {
                return '';
            }
            if (/^[\x00-\x7F]+$/.test(domain)) {
                return domain;
            }
            return global.punycode.toASCII(domain);
        },

        isThirdPartyRequest(requestUrl, referrer) {
            const domainName = this._get2NdLevelDomainName(requestUrl);
            const refDomainName = this._get2NdLevelDomainName(referrer);
            return domainName != refDomainName;
        },

        /**
         * Retrieves hostname from URL
         */
        getHost(url) {
            if (!url) {
                return null;
            }

            let firstIdx = url.indexOf('//');
            if (firstIdx === -1) {
                /**
                 * It's non hierarchical structured URL (e.g. stun: or turn:)
                 * https://tools.ietf.org/html/rfc4395#section-2.2
                 * https://tools.ietf.org/html/draft-nandakumar-rtcweb-stun-uri-08#appendix-B
                 */
                firstIdx = url.indexOf(':');
                if (firstIdx === -1) {
                    return null;
                }
                firstIdx -= 1;
            }

            const nextSlashIdx = url.indexOf('/', firstIdx + 2);
            const startParamsIdx = url.indexOf('?', firstIdx + 2);

            let lastIdx = nextSlashIdx;
            if (startParamsIdx > 0 && (startParamsIdx < nextSlashIdx || nextSlashIdx < 0)) {
                lastIdx = startParamsIdx;
            }

            let host = lastIdx === -1 ? url.substring(firstIdx + 2) : url.substring(firstIdx + 2, lastIdx);

            const portIndex = host.indexOf(':');

            host = portIndex === -1 ? host : host.substring(0, portIndex);

            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1586
            const lastChar = host.charAt(host.length - 1);
            if (lastChar === '.') {
                host = host.slice(0, -1);
            }

            return host;
        },

        getDomainName(url) {
            const host = this.getHost(url);
            return this.getCroppedDomainName(host);
        },

        getCroppedDomainName(host) {
            return api.strings.startWith(host, 'www.') ? host.substring(4) : host;
        },

        isIpv4(address) {
            if (RE_V4.test(address)) {
                return true;
            }
            if (RE_V4_HEX.test(address)) {
                return true;
            }
            if (RE_V4_NUMERIC.test(address)) {
                return true;
            }
            return false;
        },

        isIpv6(address) {
            let a4addon = 0;
            const address4 = address.match(RE_V4inV6);
            if (address4) {
                const temp4 = address4[0].split('.');
                for (let i = 0; i < 4; i++) {
                    if (/^0[0-9]+/.test(temp4[i])) {
                        return false;
                    }
                }
                address = address.replace(RE_V4inV6, '');
                if (/[0-9]$/.test(address)) {
                    return false;
                }

                address += temp4.join(':');
                a4addon = 2;
            }

            if (RE_BAD_CHARACTERS.test(address)) {
                return false;
            }

            if (RE_BAD_ADDRESS.test(address)) {
                return false;
            }

            function count(string, substring) {
                return (string.length - string.replace(new RegExp(substring, 'g'), '').length) / substring.length;
            }

            const halves = count(address, '::');
            if (halves == 1 && count(address, ':') <= 6 + 2 + a4addon) {
                return true;
            }

            if (halves == 0 && count(address, ':') == 7 + a4addon) {
                return true;
            }

            return false;
        },

        urlEquals(u1, u2) {
            if (!u1 || !u2) {
                return false;
            }
            u1 = u1.split(/[#?]/)[0];
            u2 = u2.split(/[#?]/)[0];
            return u1 == u2;
        },

        /**
         * Checks all domains from domainNames with isDomainOrSubDomain
         * @param domainNameToCheck Domain name to check
         * @param domainNames List of domain names
         * @returns boolean true if there is suitable domain in domainNames
         */
        isDomainOrSubDomainOfAny(domainNameToCheck, domainNames) {
            if (!domainNames || domainNames.length === 0) {
                return false;
            }

            for (let i = 0; i < domainNames.length; i += 1) {
                if (this.isDomainOrSubDomain(domainNameToCheck, domainNames[i])) {
                    return true;
                }
            }

            return false;
        },

        /**
         * Checks if the specified domain is a sub-domain of equal to domainName
         *
         * @param domainNameToCheck Domain name to check
         * @param domainName        Domain name
         * @returns boolean true if there is suitable domain in domainNames
         */
        isDomainOrSubDomain: (function () {
            /**
             * Extract from domain name tld if exists
             *
             * @param {string} domainName
             * @returns {string} string is empty if tld doesn't exist
             */
            function extractTld(domainName) {
                let guess = domainName;
                let dotIndex = guess.indexOf('.');
                while (dotIndex >= 0) {
                    if (guess in RESERVED_DOMAINS) {
                        return guess;
                    }
                    guess = guess.slice(dotIndex + 1, guess.length);
                    dotIndex = guess.indexOf('.');
                }
                if (guess in RESERVED_DOMAINS) {
                    return guess;
                }
                return '';
            }

            /**
             * Generates from domain tld wildcard e.g. google.com -> google.* ; youtube.co.uk -> youtube.*
             *
             * @param {string} domainName
             * @returns {string} string is empty if tld for provided domain name doesn't exists
             */
            function genTldWildcard(domainName) {
                const tld = extractTld(domainName);
                if (tld) {
                    return `${domainName.slice(0, domainName.indexOf(`.${tld}`))}.*`;
                }
                return '';
            }

            function matchAsWildcard(wildcard, domainNameToCheck) {
                const wildcardedDomainToCheck = genTldWildcard(domainNameToCheck);
                if (wildcardedDomainToCheck) {
                    return wildcardedDomainToCheck === wildcard
                        || api.strings.endsWith(wildcardedDomainToCheck, wildcard)
                        && api.strings.endsWith(wildcardedDomainToCheck, `.${wildcard}`);
                }
                return false;
            }

            function isWildcardDomain(domainName) {
                return api.strings.endsWith(domainName, '.*');
            }

            return function (domainNameToCheck, domainName) {
                // Checks if domain name from rule is tld wildcard
                // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/571
                if (isWildcardDomain(domainName)) {
                    return matchAsWildcard(domainName, domainNameToCheck);
                }
                // Double endsWith check is memory optimization
                // Works in android, not sure if it makes sense here
                return domainName == domainNameToCheck
                    || api.strings.endsWith(domainNameToCheck, domainName)
                    && api.strings.endsWith(domainNameToCheck, `.${domainName}`);
            };
        })(),

        _get2NdLevelDomainName(url) {
            const host = this.getHost(url);

            if (!host) {
                return null;
            }

            const parts = host.split('.');
            if (parts.length <= 2) {
                return host;
            }

            const twoPartDomain = `${parts[parts.length - 2]}.${parts[parts.length - 1]}`;
            const isContainsTwoLvlPostfix = (twoPartDomain in RESERVED_DOMAINS);

            const threePartDomain = `${parts[parts.length - 3]}.${twoPartDomain}`;
            if (parts.length == 3 && isContainsTwoLvlPostfix) {
                return threePartDomain;
            }
            if (threePartDomain in RESERVED_DOMAINS) {
                if (parts.length == 3) {
                    return threePartDomain;
                }
                return `${parts[parts.length - 4]}.${threePartDomain}`;
            }

            return isContainsTwoLvlPostfix ? threePartDomain : twoPartDomain;
        },
    };

    var RE_V4 = /^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|0x[0-9a-f][0-9a-f]?|0[0-7]{3})\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?|0x[0-9a-f][0-9a-f]?|0[0-7]{3})$/i;
    var RE_V4_HEX = /^0x([0-9a-f]{8})$/i;
    var RE_V4_NUMERIC = /^[0-9]+$/;
    var RE_V4inV6 = /(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$/;

    var RE_BAD_CHARACTERS = /([^0-9a-f:])/i;
    var RE_BAD_ADDRESS = /([0-9a-f]{5,}|:{3,}|[^:]:$|^:[^:]$)/i;

    // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1010
    var RESERVED_DOMAINS = api.publicSuffixes;

    api.url = UrlUtils;
})(adguard.utils, window);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Simple mediator
 */
adguard.listeners = (function () {

    var EventNotifierTypesMap = {
        ADD_RULES: 'event.add.rules',
        REMOVE_RULE: 'event.remove.rule',
        UPDATE_FILTER_RULES: 'event.update.filter.rules',
        FILTER_GROUP_ENABLE_DISABLE: 'filter.group.enable.disable', // enabled or disabled filter group
        FILTER_ENABLE_DISABLE: 'event.filter.enable.disable', // Enabled or disabled
        FILTER_ADD_REMOVE: 'event.filter.add.remove', // Added or removed
        ADS_BLOCKED: 'event.ads.blocked',
        START_DOWNLOAD_FILTER: 'event.start.download.filter',
        SUCCESS_DOWNLOAD_FILTER: 'event.success.download.filter',
        ERROR_DOWNLOAD_FILTER: 'event.error.download.filter',
        ENABLE_FILTER_SHOW_POPUP: 'event.enable.filter.show.popup',
        LOG_EVENT: 'event.log.track',
        UPDATE_TAB_BUTTON_STATE: 'event.update.tab.button.state',
        REQUEST_FILTER_UPDATED: 'event.request.filter.updated',
        APPLICATION_INITIALIZED: 'event.application.initialized',
        APPLICATION_UPDATED: 'event.application.updated',
        CHANGE_PREFS: 'event.change.prefs',
        UPDATE_FILTERS_SHOW_POPUP: 'event.update.filters.show.popup',
        UPDATE_USER_FILTER_RULES: 'event.update.user.filter.rules',
        UPDATE_WHITELIST_FILTER_RULES: 'event.update.whitelist.filter.rules',
        SETTING_UPDATED: 'event.update.setting.value',
        FILTERS_UPDATE_CHECK_READY: 'event.update.filters.check',
        // Log events
        TAB_ADDED: 'log.tab.added',
        TAB_CLOSE: 'log.tab.close',
        TAB_UPDATE: 'log.tab.update',
        TAB_RESET: 'log.tab.reset',
        LOG_EVENT_ADDED: 'log.event.added',
        LOG_EVENT_UPDATED: 'log.event.updated',
        // Sync events
        SETTINGS_UPDATED: 'event.sync.finished',
    };

    var EventNotifierEventsMap = Object.create(null);

    var EventNotifier = {

        listenersMap: Object.create(null),
        listenersEventsMap: Object.create(null),
        listenerId: 0,

        /**
         * Subscribes listener to the specified events
         *
         * @param events    List of event types listener will be notified of
         * @param listener  Listener object
         * @returns Index of the listener
         */
        addSpecifiedListener: function (events, listener) {
            if (typeof listener !== 'function') {
                throw new Error('Illegal listener');
            }
            var listenerId = this.listenerId++;
            this.listenersMap[listenerId] = listener;
            this.listenersEventsMap[listenerId] = events;
            return listenerId;
        },

        /**
         * Subscribe specified listener to all events
         *
         * @param listener Listener
         * @returns Index of the listener
         */
        addListener: function (listener) {
            if (typeof listener !== 'function') {
                throw new Error('Illegal listener');
            }
            var listenerId = this.listenerId++;
            this.listenersMap[listenerId] = listener;
            return listenerId;
        },

        /**
         * Unsubscribe listener
         * @param listenerId Index of listener to unsubscribe
         */
        removeListener: function (listenerId) {
            delete this.listenersMap[listenerId];
            delete this.listenersEventsMap[listenerId];
        },

        /**
         * Notifies listeners about the events passed as arguments of this function.
         */
        notifyListeners: function () {
            var event = arguments[0];
            if (!event || !(event in EventNotifierEventsMap)) {
                throw new Error('Illegal event: ' + event);
            }
            for (var listenerId in this.listenersMap) { // jshint ignore:line
                var events = this.listenersEventsMap[listenerId];
                if (events && events.length > 0 && events.indexOf(event) < 0) {
                    continue;
                }
                try {
                    var listener = this.listenersMap[listenerId];
                    listener.apply(listener, arguments);
                } catch (ex) {
                    adguard.console.error("Error invoking listener for {0} cause: {1}", event, ex);
                }
            }
        },

        /**
         * Asynchronously notifies all listeners about the events passed as arguments of this function.
         * Some events should be dispatched asynchronously, for instance this is very important for Safari:
         * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/251
         */
        notifyListenersAsync: function () {
            var args = arguments;
            setTimeout(function () {
                EventNotifier.notifyListeners.apply(EventNotifier, args);
            }, 500);
        }
    };

    // Make accessible only constants without functions. They will be passed to content-page
    EventNotifier.events = EventNotifierTypesMap;

    // Copy global properties
    for (var key in EventNotifierTypesMap) {
        if (EventNotifierTypesMap.hasOwnProperty(key)) {
            var event = EventNotifierTypesMap[key];
            EventNotifier[key] = event;
            if (event in EventNotifierEventsMap) {
                throw new Error('Duplicate event:  ' + event);
            }
            EventNotifierEventsMap[event] = key;
        }
    }

    return EventNotifier;
})();

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (adguard, api) {
    /**
     * Extension version (x.x.x)
     * @param version
     * @constructor
     */
    const Version = function (version) {
        this.version = Object.create(null);

        const parts = String(version || '').split('.');

        function parseVersionPart(part) {
            if (isNaN(part)) {
                return 0;
            }
            return Math.max(part - 0, 0);
        }

        for (let i = 3; i >= 0; i--) {
            this.version[i] = parseVersionPart(parts[i]);
        }
    };

    /**
     * Compares with other version
     * @param o
     * @returns {number}
     */
    Version.prototype.compare = function (o) {
        for (let i = 0; i < 4; i++) {
            if (this.version[i] > o.version[i]) {
                return 1;
            } if (this.version[i] < o.version[i]) {
                return -1;
            }
        }
        return 0;
    };

    const objectContentTypes = '.jar.swf.';
    const mediaContentTypes = '.mp4.flv.avi.m3u.webm.mpeg.3gp.3gpp.3g2.3gpp2.ogg.mov.qt.';
    const fontContentTypes = '.ttf.otf.woff.woff2.eot.';
    const imageContentTypes = '.ico.png.gif.jpg.jpeg.webp.';

    // noinspection UnnecessaryLocalVariableJS
    const Utils = {

        getClientId() {
            let clientId = adguard.localStorage.getItem('client-id');
            if (!clientId) {
                const result = [];
                const suffix = (Date.now()) % 1e8;
                const symbols = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz01234567890';
                for (let i = 0; i < 8; i++) {
                    const symbol = symbols[Math.floor(Math.random() * symbols.length)];
                    result.push(symbol);
                }
                clientId = result.join('') + suffix;
                adguard.localStorage.setItem('client-id', clientId);
            }

            return clientId;
        },

        /**
         * Checks if left version is greater than the right version
         */
        isGreaterVersion(leftVersion, rightVersion) {
            const left = new Version(leftVersion);
            const right = new Version(rightVersion);
            return left.compare(right) > 0;
        },

        isGreaterOrEqualsVersion(leftVersion, rightVersion) {
            const left = new Version(leftVersion);
            const right = new Version(rightVersion);
            return left.compare(right) >= 0;
        },

        /**
         * Returns major number of version
         *
         * @param version
         */
        getMajorVersionNumber(version) {
            const v = new Version(version);
            return v.version[0];
        },

        /**
         * Returns minor number of version
         *
         * @param version
         */
        getMinorVersionNumber(version) {
            const v = new Version(version);
            return v.version[1];
        },

        /**
         * @returns Extension version
         */
        getAppVersion() {
            return adguard.localStorage.getItem('app-version');
        },

        setAppVersion(version) {
            adguard.localStorage.setItem('app-version', version);
        },

        isYaBrowser() {
            return adguard.prefs.browser === 'YaBrowser';
        },

        isOperaBrowser() {
            return adguard.prefs.browser === 'Opera';
        },

        isEdgeBrowser() {
            return adguard.prefs.browser === 'Edge';
        },

        isEdgeChromiumBrowser() {
            return adguard.prefs.browser === 'EdgeChromium';
        },

        isFirefoxBrowser() {
            return adguard.prefs.browser === 'Firefox';
        },

        isChromeBrowser() {
            return adguard.prefs.browser === 'Chrome';
        },

        isChromium() {
            return adguard.prefs.platform === 'chromium';
        },

        isWindowsOs() {
            return navigator.userAgent.toLowerCase().indexOf('win') >= 0;
        },

        isMacOs() {
            return navigator.platform.toUpperCase().indexOf('MAC') >= 0;
        },

        /**
         * Finds header object by header name (case insensitive)
         * @param headers Headers collection
         * @param headerName Header name
         * @returns {*}
         */
        findHeaderByName(headers, headerName) {
            if (headers) {
                for (let i = 0; i < headers.length; i++) {
                    const header = headers[i];
                    if (header.name.toLowerCase() === headerName.toLowerCase()) {
                        return header;
                    }
                }
            }
            return null;
        },

        /**
         * Finds header value by name (case insensitive)
         * @param headers Headers collection
         * @param headerName Header name
         * @returns {null}
         */
        getHeaderValueByName(headers, headerName) {
            const header = this.findHeaderByName(headers, headerName);
            return header ? header.value : null;
        },

        /**
         * Set header value. Only for Chrome
         * @param headers
         * @param headerName
         * @param headerValue
         */
        setHeaderValue(headers, headerName, headerValue) {
            if (!headers) {
                headers = [];
            }
            const header = this.findHeaderByName(headers, headerName);
            if (header) {
                header.value = headerValue;
            } else {
                headers.push({ name: headerName, value: headerValue });
            }
            return headers;
        },

        /**
         * Removes header from headers by name
         *
         * @param {Array} headers
         * @param {String} headerName
         * @return {boolean} True if header were removed
         */
        removeHeader(headers, headerName) {
            let removed = false;
            if (headers) {
                for (let i = headers.length - 1; i >= 0; i--) {
                    const header = headers[i];
                    if (header.name.toLowerCase() === headerName.toLowerCase()) {
                        headers.splice(i, 1);
                        removed = true;
                    }
                }
            }
            return removed;
        },

        getSafebrowsingBackUrl(tab) {
            // https://code.google.com/p/chromium/issues/detail?id=11854
            const previousUrl = adguard.tabs.getTabMetadata(tab.tabId, 'previousUrl');
            if (previousUrl && previousUrl.indexOf('http') === 0) {
                return previousUrl;
            }
            const referrerUrl = adguard.tabs.getTabMetadata(tab.tabId, 'referrerUrl');
            if (referrerUrl && referrerUrl.indexOf('http') === 0) {
                return referrerUrl;
            }

            return 'about:newtab';
        },

        /**
         * Parse content type from path
         * @param path Path
         * @returns {*} content type (adguard.RequestTypes.*) or null
         */
        parseContentTypeFromUrlPath(path) {
            let ext = path.slice(-6);
            const pos = ext.lastIndexOf('.');

            // Unable to parse extension from url
            if (pos === -1) {
                return null;
            }

            ext = `${ext.slice(pos)}.`;
            if (objectContentTypes.indexOf(ext) !== -1) {
                return adguard.RequestTypes.OBJECT;
            }
            if (mediaContentTypes.indexOf(ext) !== -1) {
                return adguard.RequestTypes.MEDIA;
            }
            if (fontContentTypes.indexOf(ext) !== -1) {
                return adguard.RequestTypes.FONT;
            }
            if (imageContentTypes.indexOf(ext) !== -1) {
                return adguard.RequestTypes.IMAGE;
            }

            return null;
        },

        /**
         * Retrieve languages from navigator
         * @param limit Limit of preferred languages
         * @returns {Array}
         */
        getNavigatorLanguages(limit) {
            let languages = [];
            // https://developer.mozilla.org/ru/docs/Web/API/NavigatorLanguage/languages
            if (adguard.utils.collections.isArray(navigator.languages)) {
                languages = navigator.languages.slice(0, limit);
            } else if (navigator.language) {
                languages.push(navigator.language); // .language is first in .languages
            }
            return languages;
        },

        /**
         * Affected issues:
         * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/602
         * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/566
         * 'Popup' window

         * Creators update is not yet released, so we use Insider build 15063 instead.
         */
        EDGE_CREATORS_UPDATE: 15063,

        isEdgeBeforeCreatorsUpdate() {
            return this.isEdgeBrowser() && adguard.prefs.edgeVersion.build < this.EDGE_CREATORS_UPDATE;
        },

        /**
         * Returns extension params: clientId, version and locale
         */
        getExtensionParams() {
            const clientId = encodeURIComponent(this.getClientId());
            const locale = encodeURIComponent(adguard.app.getLocale());
            const version = encodeURIComponent(adguard.app.getVersion());
            const id = encodeURIComponent(adguard.app.getId());
            const params = [];
            params.push(`v=${version}`);
            params.push(`cid=${clientId}`);
            params.push(`lang=${locale}`);
            params.push(`id=${id}`);
            return params;
        },

        /**
         * Checks if extension has required permissions
         * @param {Array<string>} permissions
         * @param {Array<string>} [origins]
         * @returns {Promise<boolean>}
         */
        containsPermissions: (permissions, origins) => new Promise((resolve) => {
            browser.permissions.contains({
                permissions,
                origins,
            }, resolve);
        }),

        /**
         * Requests required permission
         * @param {Array<string>} permissions
         * @param {Array<string>} [origins]
         * @returns {Promise<any>}
         */
        requestPermissions: (permissions, origins) => new Promise((resolve) => {
            browser.permissions.request({
                permissions,
                origins,
            }, resolve);
        }),

        /**
         * Removes unused permissions
         * @param {Array<string>} permissions
         * @param {Array<string>} [origins]
         * @returns {Promise<any>}
         */
        removePermission: (permissions, origins) => new Promise((resolve) => {
            browser.permissions.remove({
                permissions,
                origins,
            }, resolve);
        }),
    };

    api.browser = Utils;
})(adguard, adguard.utils);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/* global FilterDownloader */
adguard.backend = (function (adguard) {
    'use strict';

    /**
     * Class for working with our backend server.
     * All requests sent by this class are covered in the privacy policy:
     * http://adguard.com/en/privacy.html#browsers
     */

    /**
     * Settings
     */
    const settings = {

        // Base url of our backend server
        get backendUrl() {
            return 'https://chrome.adtidy.org';
        },

        get apiKey() {
            return '4DDBE80A3DA94D819A00523252FB6380';
        },

        // Url for load filters metadata and rules
        get filtersUrl() {
            return adguard.lazyGet(this, 'filtersUrl', () => {
                if (adguard.utils.browser.isFirefoxBrowser()) {
                    return 'https://filters.adtidy.org/extension/firefox';
                } if (adguard.utils.browser.isEdgeBrowser()) {
                    return 'https://filters.adtidy.org/extension/edge';
                } if (adguard.utils.browser.isOperaBrowser()) {
                    return 'https://filters.adtidy.org/extension/opera';
                }
                return 'https://filters.adtidy.org/extension/chromium';
            });
        },

        // URL for downloading AG filters
        get filterRulesUrl() {
            return `${this.filtersUrl}/filters/{filter_id}.txt`;
        },

        // URL for downloading optimized AG filters
        get optimizedFilterRulesUrl() {
            return `${this.filtersUrl}/filters/{filter_id}_optimized.txt`;
        },

        // URL for checking filter updates
        get filtersMetadataUrl() {
            const params = adguard.utils.browser.getExtensionParams();
            return `${this.filtersUrl}/filters.js?${params.join('&')}`;
        },

        // URL for user complaints on missed ads or malware/phishing websites
        get reportUrl() {
            return `${this.backendUrl}/url-report.html`;
        },

        /**
         * URL for collecting filter rules statistics.
         * We do not collect it by default, unless user is willing to help.
         *
         * Filter rules stats are covered in our privacy policy and on also here:
         * http://adguard.com/en/filter-rules-statistics.html
         */
        get ruleStatsUrl() {
            return `${this.backendUrl}/rulestats.html`;
        },

        /**
         * Browsing Security lookups. In case of Firefox lookups are disabled for HTTPS urls.
         */
        get safebrowsingLookupUrl() {
            return 'https://sb.adtidy.org/safebrowsing-lookup-short-hash.html';
        },

        // Folder that contains filters metadata and files with rules. 'filters' by default
        get localFiltersFolder() {
            return 'filters';
        },
        // Path to the redirect sources
        get redirectSourcesFolder() {
            return 'lib/filter/rules/scriptlets';
        },
        // Array of filter identifiers, that have local file with rules. Range from 1 to 14 by default
        get localFilterIds() {
            return [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14];
        },
    };

    /**
     * FilterDownloader constants
     */
    const FilterCompilerConditionsConstants = {
        adguard: true,
        adguard_ext_chromium: adguard.utils.browser.isChromium(),
        adguard_ext_firefox: adguard.utils.browser.isFirefoxBrowser(),
        adguard_ext_edge: adguard.utils.browser.isEdgeBrowser(),
        adguard_ext_safari: false,
        adguard_ext_opera: adguard.utils.browser.isOperaBrowser(),
    };

    /**
     * Loading subscriptions map
     */
    const loadingSubscriptions = Object.create(null);

    /**
     * Executes async request
     * @param url Url
     * @param contentType Content type
     * @param successCallback success callback
     * @param errorCallback error callback
     */
    function executeRequestAsync(url, contentType, successCallback, errorCallback) {
        const request = new XMLHttpRequest();
        try {
            request.open('GET', url);
            request.setRequestHeader('Content-type', contentType);
            request.setRequestHeader('Pragma', 'no-cache');
            request.overrideMimeType(contentType);
            request.mozBackgroundRequest = true;
            if (successCallback) {
                request.onload = function () {
                    successCallback(request);
                };
            }
            if (errorCallback) {
                const errorCallbackWrapper = function () {
                    errorCallback(request);
                };
                request.onerror = errorCallbackWrapper;
                request.onabort = errorCallbackWrapper;
                request.ontimeout = errorCallbackWrapper;
            }
            request.send(null);
        } catch (ex) {
            if (errorCallback) {
                errorCallback(request, ex);
            }
        }
    }

    /**
     * URL for downloading AG filter
     *
     * @param filterId Filter identifier
     * @param useOptimizedFilters
     * @private
     */
    function getUrlForDownloadFilterRules(filterId, useOptimizedFilters) {
        const url = useOptimizedFilters ? settings.optimizedFilterRulesUrl : settings.filterRulesUrl;
        return adguard.utils.strings.replaceAll(url, '{filter_id}', filterId);
    }

    /**
     * Appends request key to url
     */
    function addKeyParameter(url) {
        return `${url}&key=${settings.apiKey}`;
    }

    /**
     * Safe json parsing
     * @param text
     * @private
     */
    function parseJson(text) {
        try {
            return JSON.parse(text);
        } catch (ex) {
            adguard.console.error('Error parse json {0}', ex);
            return null;
        }
    }

    /**
     * Load metadata of the specified filters
     *
     * @param filterIds         Filters identifiers
     * @param successCallback   Called on success
     * @param errorCallback     Called on error
     */
    const loadFiltersMetadata = (filterIds, successCallback, errorCallback) => {
        if (!filterIds || filterIds.length === 0) {
            successCallback([]);
            return;
        }

        const success = (response) => {
            if (response && response.responseText) {
                const metadata = parseJson(response.responseText);
                if (!metadata) {
                    errorCallback(response, 'invalid response');
                    return;
                }
                const filterMetadataList = [];
                for (let i = 0; i < filterIds.length; i += 1) {
                    const filter = adguard.utils.collections.find(metadata.filters, 'filterId', filterIds[i]);
                    if (filter) {
                        filterMetadataList.push(adguard.subscriptions.createSubscriptionFilterFromJSON(filter));
                    }
                }
                successCallback(filterMetadataList);
            } else {
                errorCallback(response, 'empty response');
            }
        };

        executeRequestAsync(settings.filtersMetadataUrl, 'application/json', success, errorCallback);
    };

    /**
     * Downloads filter rules by filter ID
     *
     * @param filterId              Filter identifier
     * @param forceRemote           Force download filter rules from remote server
     * @param useOptimizedFilters   Download optimized filters flag
     * @returns {Promise<string>}   Downloaded rules
     */
    const loadFilterRules = (filterId, forceRemote, useOptimizedFilters) => {
        let url;

        if (forceRemote || settings.localFilterIds.indexOf(filterId) < 0) {
            url = getUrlForDownloadFilterRules(filterId, useOptimizedFilters);
        } else {
            url = adguard.getURL(`${settings.localFiltersFolder}/filter_${filterId}.txt`);
            if (useOptimizedFilters) {
                url = adguard.getURL(`${settings.localFiltersFolder}/filter_mobile_${filterId}.txt`);
            }
        }

        return FilterDownloader.download(url, FilterCompilerConditionsConstants);
    };

    /**
     * Downloads filter rules frm url
     *
     * @param url               Subscription url
     * @param successCallback   Called on success
     * @param errorCallback     Called on error
     */
    const loadFilterRulesBySubscriptionUrl = function (url, successCallback, errorCallback) {
        if (url in loadingSubscriptions) {
            return;
        }

        loadingSubscriptions[url] = true;

        const success = function (lines) {
            delete loadingSubscriptions[url];

            if (lines[0].indexOf('[') === 0) {
                // [Adblock Plus 2.0]
                lines.shift();
            }

            successCallback(lines);
        };

        const error = function (cause) {
            delete loadingSubscriptions[url];
            const message = cause instanceof Error ? cause.message : cause;
            errorCallback(message);
        };

        FilterDownloader.download(url, FilterCompilerConditionsConstants).then(success, error);
    };

    const createError = (message, url, response) => {
        const errorMessage = `
        error:                    ${message}
        requested url:            ${url}
        request status text:      ${response.statusText}`;
        return new Error(errorMessage);
    };

    /**
     * Loads filter groups metadata
     */
    const loadLocalFiltersMetadata = () => new Promise((resolve, reject) => {
        const url = adguard.getURL(`${settings.localFiltersFolder}/filters.json`);
        const success = function (response) {
            if (response && response.responseText) {
                const metadata = parseJson(response.responseText);
                if (!metadata) {
                    reject(createError('invalid response', url, response));
                    return;
                }
                resolve(metadata);
            } else {
                reject(createError('empty response', url, response));
            }
        };

        const error = (request, ex) => {
            const exMessage = (ex && ex.message) || 'couldn\'t load local filters metadata';
            reject(createError(exMessage, url, request));
        };

        executeRequestAsync(url, 'application/json', success, error);
    });

    /**
     * Loads filter groups metadata from local file
     * @returns {Promise}
     */
    const loadLocalFiltersI18Metadata = () => new Promise((resolve, reject) => {
        const url = adguard.getURL(`${settings.localFiltersFolder}/filters_i18n.json`);
        const success = function (response) {
            if (response && response.responseText) {
                const metadata = parseJson(response.responseText);
                if (!metadata) {
                    reject(createError('invalid response', url, response));
                    return;
                }
                resolve(metadata);
            } else {
                reject(createError('empty response', url, response));
            }
        };

        const error = (request, ex) => {
            const exMessage = (ex && ex.message) || 'couldn\'t load local filters i18n metadata';
            reject(createError(exMessage, url, request));
        };

        executeRequestAsync(url, 'application/json', success, error);
    });

    /**
     * Loads script rules from local file
     * @returns {Promise}
     */
    const loadLocalScriptRules = () => new Promise((resolve, reject) => {
        const url = adguard.getURL(`${settings.localFiltersFolder}/local_script_rules.json`);

        const success = (response) => {
            if (response && response.responseText) {
                const metadata = parseJson(response.responseText);
                if (!metadata) {
                    reject(createError('invalid response', url, response));
                    return;
                }
                resolve(metadata);
            } else {
                reject(createError('empty response', url, response));
            }
        };

        const error = (request, ex) => {
            const exMessage = (ex && ex.message) || 'couldn\'t load local script rules';
            reject(createError(exMessage, url, request));
        };

        executeRequestAsync(url, 'application/json', success, error);
    });

    /**
     * Loads redirect sources from local file
     * @returns {Promise}
     */
    const loadRedirectSources = () => new Promise((resolve, reject) => {
        const url = `${adguard.getURL(settings.redirectSourcesFolder)}/redirects.yml`;

        const success = (response) => {
            if (response && response.responseText) {
                resolve(response.responseText);
            } else {
                reject(createError('empty response', url, response));
            }
        };

        const error = (request, ex) => {
            const exMessage = (ex && ex.message) || 'couldn\'t load redirect sources';
            reject(createError(exMessage, url, request));
        };

        executeRequestAsync(url, 'application/x-yaml', success, error);
    });

    /**
     * Checks specified host hashes with our safebrowsing service
     *
     * @param hashes                Host hashes
     * @param successCallback       Called on success
     * @param errorCallback         Called on error
     */
    const lookupSafebrowsing = function (hashes, successCallback, errorCallback) {
        const url = `${settings.safebrowsingLookupUrl}?prefixes=${encodeURIComponent(hashes.join('/'))}`;
        executeRequestAsync(url, 'application/json', successCallback, errorCallback);
    };

    /**
     * Sends feedback from the user to our server
     *
     * @param url           URL
     * @param messageType   Message type
     * @param comment       Message text
     */
    const sendUrlReport = function (url, messageType, comment) {
        let params = `url=${encodeURIComponent(url)}`;
        params += `&messageType=${encodeURIComponent(messageType)}`;
        if (comment) {
            params += `&comment=${encodeURIComponent(comment)}`;
        }
        params = addKeyParameter(params);

        const request = new XMLHttpRequest();
        request.open('POST', settings.reportUrl);
        request.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
        request.send(params);
    };

    /**
     * Sends filter hits stats to backend server.
     * This method is used if user has enabled "Send statistics for ad filters usage".
     * More information about ad filters usage stats:
     * http://adguard.com/en/filter-rules-statistics.html
     *
     * @param stats             Stats
     * @param enabledFilters    List of enabled filters
     */
    const sendHitStats = function (stats, enabledFilters) {
        let params = `stats=${encodeURIComponent(stats)}`;
        params += `&v=${encodeURIComponent(adguard.app.getVersion())}`;
        params += `&b=${encodeURIComponent(adguard.prefs.browser)}`;
        if (enabledFilters) {
            for (let i = 0; i < enabledFilters.length; i++) {
                const filter = enabledFilters[i];
                params += `&f=${encodeURIComponent(`${filter.filterId},${filter.version}`)}`;
            }
        }
        params = addKeyParameter(params);

        const request = new XMLHttpRequest();
        request.open('POST', settings.ruleStatsUrl);
        request.setRequestHeader('Content-type', 'application/x-www-form-urlencoded');
        request.send(params);
    };

    /**
     * Allows to receive response headers from the request to the given URL
     * @param url URL
     * @param callback Callback with headers or null in the case of error
     */
    const getResponseHeaders = function (url, callback) {
        executeRequestAsync(url, 'text/plain', (request) => {
            const arr = request.getAllResponseHeaders().trim().split(/[\r\n]+/);
            const headers = arr.map((line) => {
                const parts = line.split(': ');
                const header = parts.shift();
                const value = parts.join(': ');
                return {
                    name: header,
                    value,
                };
            });
            callback(headers);
        }, (request) => {
            adguard.console.error('Error retrieved response from {0}, cause: {1}', url, request.statusText);
            callback(null);
        });
    };

    /**
     * Configures backend's URLs
     * @param configuration Configuration object:
     * {
     *  filtersMetadataUrl: '...',
     *  filterRulesUrl: '...',
     *  localFiltersFolder: '...',
     *  localFilterIds: []
     * }
     */
    const configure = function (configuration) {
        const { filtersMetadataUrl } = configuration;
        if (filtersMetadataUrl) {
            Object.defineProperty(settings, 'filtersMetadataUrl', {
                get() {
                    return filtersMetadataUrl;
                },
            });
        }
        const { filterRulesUrl } = configuration;
        if (filterRulesUrl) {
            Object.defineProperty(settings, 'filterRulesUrl', {
                get() {
                    return filterRulesUrl;
                },
            });
        }
        const { localFiltersFolder } = configuration;
        if (localFiltersFolder) {
            Object.defineProperty(settings, 'localFiltersFolder', {
                get() {
                    return localFiltersFolder;
                },
            });
        }

        const { redirectSourcesFolder } = configuration;
        if (redirectSourcesFolder) {
            Object.defineProperty(settings, 'redirectSourcesFolder', {
                get() {
                    return redirectSourcesFolder;
                },
            });
        }

        const { localFilterIds } = configuration;
        if (localFilterIds) {
            Object.defineProperty(settings, 'localFilterIds', {
                get() {
                    return localFilterIds;
                },
            });
        }
    };

    return {
        loadFiltersMetadata,
        loadFilterRules,

        loadFilterRulesBySubscriptionUrl,

        loadLocalFiltersMetadata,
        loadLocalFiltersI18Metadata,
        loadLocalScriptRules,
        loadRedirectSources,

        lookupSafebrowsing,

        sendUrlReport,
        sendHitStats,

        getResponseHeaders,

        configure,
    };
})(adguard);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Global stats
 */
adguard.pageStats = (function (adguard) {
    'use strict';

    const MAX_HOURS_HISTORY = 24;
    const MAX_DAYS_HISTORY = 30;
    const MAX_MONTHS_HISTORY = 3;

    const TOTAL_GROUP = {
        groupId: 'total',
        groupName: adguard.i18n ? adguard.i18n.getMessage('popup_statistics_total') : 'Total',
    };

    const pageStatisticProperty = 'page-statistic';

    const pageStatsHolder = {
        /**
         * Getter for total page stats (gets it from local storage)
         *
         * @returns {*}
         * @private
         */
        get stats() {
            return adguard.lazyGet(pageStatsHolder, 'stats', () => {
                let stats;
                try {
                    const json = adguard.localStorage.getItem(pageStatisticProperty);
                    if (json) {
                        stats = JSON.parse(json);
                    }
                } catch (ex) {
                    adguard.console.error('Error retrieve page statistic from storage, cause {0}', ex);
                }
                return stats || Object.create(null);
            });
        },

        save: adguard.utils.concurrent.throttle(function () {
            adguard.localStorage.setItem(pageStatisticProperty, JSON.stringify(this.stats));
        }, adguard.prefs.statsSaveInterval),

        clear: function () {
            adguard.localStorage.removeItem(pageStatisticProperty);
            adguard.lazyGetClear(pageStatsHolder, 'stats');
        },
    };

    /**
     * Total count of blocked requests
     *
     * @returns {Number} Count of blocked requests
     */
    const getTotalBlocked = function () {
        const stats = pageStatsHolder.stats;
        if (!stats) {
            return 0;
        }
        return stats.totalBlocked || 0;
    };

    /**
     * Updates total count of blocked requests
     *
     * @param blocked Count of blocked requests
     */
    const updateTotalBlocked = function (blocked) {
        const stats = pageStatsHolder.stats;
        stats.totalBlocked = (stats.totalBlocked || 0) + blocked;
        pageStatsHolder.save();
    };

    /**
     * Resets tab stats
     */
    const resetStats = function () {
        pageStatsHolder.clear();
    };

    /**
     * Object used to cache bindings between filters and groups
     * @type {{filterId: {groupId: Number, groupName: String, displayNumber: Number}}}
     */
    const blockedGroupsFilters = {};

    // TODO check why not all filter stats appear here, for example cosmetic filters

    /**
     * Returns blocked group by filter id
     *
     * @param {number} filterId
     * @returns
     */
    const getBlockedGroupByFilterId = function (filterId) {
        let blockedGroup = blockedGroupsFilters[filterId];

        if (blockedGroup !== undefined) {
            return blockedGroup;
        }

        const filter = adguard.subscriptions.getFilter(filterId);
        if (!filter) {
            return undefined;
        }

        const group = adguard.subscriptions.getGroup(filter.groupId);
        if (!group) {
            return undefined;
        }

        const { groupId, groupName, displayNumber } = group;
        blockedGroup = { groupId, groupName, displayNumber };
        blockedGroupsFilters[filter.filterId] = blockedGroup;

        return blockedGroup;
    };

    const createStatsDataItem = function (type, blocked) {
        const result = new Object(null);
        if (type) {
            result[type] = blocked;
        }
        result[TOTAL_GROUP.groupId] = blocked;
        return result;
    };

    /**
     * Blocked types to filters relation dictionary
     */
    const createStatsData = function (now, type, blocked) {
        const result = Object.create(null);
        result.hours = [];
        result.days = [];
        result.months = [];

        for (let i = 1; i < MAX_HOURS_HISTORY; i += 1) {
            result.hours.push(createStatsDataItem(null, 0));
        }
        result.hours.push(createStatsDataItem(type, blocked));

        for (let j = 1; j < MAX_DAYS_HISTORY; j += 1) {
            result.days.push(createStatsDataItem(null, 0));
        }
        result.days.push(createStatsDataItem(type, blocked));

        for (let k = 1; k < MAX_MONTHS_HISTORY; k += 1) {
            result.months.push(createStatsDataItem(null, 0));
        }
        result.months.push(createStatsDataItem(type, blocked));

        result.updated = now.getTime();

        return result;
    };

    var updateStatsDataItem = function (type, blocked, current) {
        current[type] = (current[type] || 0) + blocked;
        current[TOTAL_GROUP.groupId] = (current[TOTAL_GROUP.groupId] || 0) + blocked;

        return current;
    };

    var updateStatsData = function (now, type, blocked, current) {
        const currentDate = new Date(current.updated);

        const result = current;

        if (adguard.utils.dates.isSameHour(now, currentDate) && result.hours.length > 0) {
            result.hours[result.hours.length - 1] = updateStatsDataItem(type, blocked, result.hours[result.hours.length - 1]);
        } else {
            let diffHours = adguard.utils.dates.getDifferenceInHours(now, currentDate);

            while (diffHours >= 2) {
                result.hours.push(createStatsDataItem(null, 0));
                diffHours -= 1;
            }

            result.hours.push(createStatsDataItem(type, blocked));
            if (result.hours.length > MAX_HOURS_HISTORY) {
                result.hours = result.hours.slice(-MAX_HOURS_HISTORY);
            }
        }

        if (adguard.utils.dates.isSameDay(now, currentDate) && result.days.length > 0) {
            result.days[result.days.length - 1] = updateStatsDataItem(type, blocked, result.days[result.days.length - 1]);
        } else {
            let diffDays = adguard.utils.dates.getDifferenceInDays(now, currentDate);

            while (diffDays >= 2) {
                result.days.push(createStatsDataItem(null, 0));
                diffDays -= 1;
            }

            result.days.push(createStatsDataItem(type, blocked));
            if (result.days.length > MAX_DAYS_HISTORY) {
                result.days = result.days.slice(-MAX_DAYS_HISTORY);
            }
        }

        if (adguard.utils.dates.isSameMonth(now, currentDate) && result.months.length > 0) {
            result.months[result.months.length - 1] = updateStatsDataItem(type, blocked, result.months[result.months.length - 1]);
        } else {
            let diffMonths = adguard.utils.dates.getDifferenceInMonths(now, currentDate);
            while (diffMonths >= 2) {
                result.months.push(createStatsDataItem(null, 0));
                diffMonths -= 1;
            }

            result.months.push(createStatsDataItem(type, blocked));
        }

        result.updated = now.getTime();
        return result;
    };

    /**
     * Updates stats data
     *
     * For every hour/day/month we have an object:
     * {
     *      blockedType: count,
     *      ..,
     *
     *      total: count
     * }
     *
     * We store last 24 hours, 30 days and all past months stats
     *
     * var data = {
     *              hours: [],
     *              days: [],
     *              months: [],
     *              updated: Date };
     *
     * @param filterId
     * @param blocked count
     * @param now date
     */
    const updateStats = function (filterId, blocked, now) {
        const blockedGroup = getBlockedGroupByFilterId(filterId);

        if (blockedGroup === undefined) {
            return;
        }

        const { groupId } = blockedGroup;
        const stats = pageStatsHolder.stats;

        let updated;

        if (!stats.data) {
            updated = createStatsData(now, groupId, blocked);
        } else {
            updated = updateStatsData(now, groupId, blocked, stats.data);
        }

        pageStatsHolder.stats.data = updated;
        pageStatsHolder.save();
    };

    const getBlockedGroups = () => {
        const groups = adguard.subscriptions.getGroups()
            .map(group => {
                return {
                    groupId: group.groupId,
                    groupName: group.groupName,
                    displayNumber: group.displayNumber,
                };
            });

        return [TOTAL_GROUP, ...groups.sort((prevGroup, nextGroup) => {
            return prevGroup.displayNumber - nextGroup.displayNumber;
        })];
    };

    /**
     * Returns statistics data object
     * @param {Date} [date] - used in the tests to provide time of stats object creation
     */
    const getStatisticsData = (date = new Date()) => {
        let stats = pageStatsHolder.stats;
        if (!stats) {
            stats = {};
        }

        if (!stats.data) {
            stats.data = createStatsData(date, null, 0);
            pageStatsHolder.stats.data = stats.data;
            pageStatsHolder.save();
        }

        return {
            today: stats.data.hours,
            lastWeek: stats.data.days.slice(-7),
            lastMonth: stats.data.days,
            lastYear: stats.data.months.slice(-12),
            overall: stats.data.months,
            blockedGroups: getBlockedGroups(),
        };
    };

    return {
        resetStats: resetStats,
        updateTotalBlocked: updateTotalBlocked,
        updateStats: updateStats,
        getTotalBlocked: getTotalBlocked,
        getStatisticsData: getStatisticsData,
    };
})(adguard);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Object that manages user settings.
 * @constructor
 */
adguard.settings = (function (adguard) {
    'use strict';

    const DEFAULT_FILTERS_UPDATE_PERIOD = -1;
    const DEFAULT_FIRST_PARTY_COOKIES_SELF_DESTRUCT_MIN = 4320;
    const DEFAULT_THIRD_PARTY_COOKIES_SELF_DESTRUCT_MIN = 2880;
    const DEFAULT_TRACKING_PARAMETERS = 'utm_source,utm_medium,utm_term,utm_campaign,utm_content,utm_name,utm_cid,utm_reader,utm_viz_id,utm_pubreferrer,utm_swu,utm_referrer,utm_social,utm_social-type,utm_place,utm_userid,utm_channel,fb_action_ids,fb_action_types,fb_ref,fb_source';

    const settings = {
        DISABLE_DETECT_FILTERS: 'detect-filters-disabled',
        DISABLE_SHOW_PAGE_STATS: 'disable-show-page-statistic',
        DISABLE_SHOW_ADGUARD_PROMO_INFO: 'show-info-about-adguard-disabled',
        DISABLE_SAFEBROWSING: 'safebrowsing-disabled',
        DISABLE_FILTERING: 'adguard-disabled',
        DISABLE_COLLECT_HITS: 'hits-count-disabled',
        DISABLE_SHOW_CONTEXT_MENU: 'context-menu-disabled',
        USE_OPTIMIZED_FILTERS: 'use-optimized-filters',
        DEFAULT_WHITE_LIST_MODE: 'default-whitelist-mode',
        DISABLE_SHOW_APP_UPDATED_NOTIFICATION: 'show-app-updated-disabled',
        FILTERS_UPDATE_PERIOD: 'filters-update-period',
        DISABLE_STEALTH_MODE: 'stealth_disable_stealth_mode',
        HIDE_REFERRER: 'stealth-hide-referrer',
        HIDE_SEARCH_QUERIES: 'stealth-hide-search-queries',
        SEND_DO_NOT_TRACK: 'stealth-send-do-not-track',
        BLOCK_CHROME_CLIENT_DATA: 'stealth-remove-x-client',
        BLOCK_WEBRTC: 'stealth-block-webrtc',
        SELF_DESTRUCT_THIRD_PARTY_COOKIES: 'stealth-block-third-party-cookies',
        SELF_DESTRUCT_THIRD_PARTY_COOKIES_TIME: 'stealth-block-third-party-cookies-time',
        SELF_DESTRUCT_FIRST_PARTY_COOKIES: 'stealth-block-first-party-cookies',
        SELF_DESTRUCT_FIRST_PARTY_COOKIES_TIME: 'stealth-block-first-party-cookies-time',
        STRIP_TRACKING_PARAMETERS: 'strip-tracking-parameters',
        TRACKING_PARAMETERS: 'tracking-parameters',
    };

    const properties = Object.create(null);
    const propertyUpdateChannel = adguard.utils.channels.newChannel();

    /**
     * Lazy default properties
     */
    const defaultProperties = {
        get defaults() {
            return adguard.lazyGet(this, 'defaults', () => {
                // Initialize default properties
                const defaults = Object.create(null);
                for (const name in settings) {
                    if (settings.hasOwnProperty(name)) {
                        defaults[settings[name]] = false;
                    }
                }
                defaults[settings.DISABLE_SHOW_ADGUARD_PROMO_INFO] = (!adguard.utils.browser.isWindowsOs() && !adguard.utils.browser.isMacOs()) || adguard.utils.browser.isEdgeBrowser();
                defaults[settings.DISABLE_SAFEBROWSING] = true;
                defaults[settings.DISABLE_COLLECT_HITS] = true;
                defaults[settings.DEFAULT_WHITE_LIST_MODE] = true;
                defaults[settings.USE_OPTIMIZED_FILTERS] = adguard.prefs.mobile;
                defaults[settings.DISABLE_DETECT_FILTERS] = false;
                defaults[settings.DISABLE_SHOW_APP_UPDATED_NOTIFICATION] = false;
                defaults[settings.FILTERS_UPDATE_PERIOD] = DEFAULT_FILTERS_UPDATE_PERIOD;
                defaults[settings.DISABLE_STEALTH_MODE] = true;
                defaults[settings.HIDE_REFERRER] = true;
                defaults[settings.HIDE_SEARCH_QUERIES] = true;
                defaults[settings.SEND_DO_NOT_TRACK] = true;
                defaults[settings.BLOCK_CHROME_CLIENT_DATA] = !!adguard.utils.browser.isChromeBrowser();
                defaults[settings.BLOCK_WEBRTC] = false;
                defaults[settings.SELF_DESTRUCT_THIRD_PARTY_COOKIES] = true;
                defaults[settings.SELF_DESTRUCT_THIRD_PARTY_COOKIES_TIME] = DEFAULT_THIRD_PARTY_COOKIES_SELF_DESTRUCT_MIN;
                defaults[settings.SELF_DESTRUCT_FIRST_PARTY_COOKIES] = false;
                defaults[settings.SELF_DESTRUCT_FIRST_PARTY_COOKIES_TIME] = DEFAULT_FIRST_PARTY_COOKIES_SELF_DESTRUCT_MIN;
                defaults[settings.STRIP_TRACKING_PARAMETERS] = true;
                defaults[settings.TRACKING_PARAMETERS] = DEFAULT_TRACKING_PARAMETERS;
                return defaults;
            });
        },
    };

    const getProperty = function (propertyName) {
        if (propertyName in properties) {
            return properties[propertyName];
        }

        /**
         * Don't cache values in case of uninitialized storage
         */
        if (!adguard.localStorage.isInitialized()) {
            return defaultProperties.defaults[propertyName];
        }

        let propertyValue = null;

        if (adguard.localStorage.hasItem(propertyName)) {
            try {
                propertyValue = JSON.parse(adguard.localStorage.getItem(propertyName));
            } catch (ex) {
                adguard.console.error('Error get property {0}, cause: {1}', propertyName, ex);
            }
        } else if (propertyName in defaultProperties.defaults) {
            propertyValue = defaultProperties.defaults[propertyName];
        }

        properties[propertyName] = propertyValue;

        return propertyValue;
    };

    const setProperty = (propertyName, propertyValue) => {
        adguard.localStorage.setItem(propertyName, JSON.stringify(propertyValue));
        properties[propertyName] = propertyValue;
        propertyUpdateChannel.notify(propertyName, propertyValue);
        adguard.listeners.notifyListeners(adguard.listeners.SETTING_UPDATED, { propertyName, propertyValue });
    };

    const getAllSettings = function () {
        const result = {
            names: Object.create(null),
            values: Object.create(null),
            defaultValues: Object.create(null),
        };

        for (const key in settings) {
            if (settings.hasOwnProperty(key)) {
                const setting = settings[key];
                result.names[key] = setting;
                result.values[setting] = getProperty(setting);
                result.defaultValues[setting] = defaultProperties.defaults[setting];
            }
        }

        return result;
    };

    /**
     * True if filtering is disabled globally.
     *
     * @returns {boolean} true if disabled
     */
    const isFilteringDisabled = function () {
        return getProperty(settings.DISABLE_FILTERING);
    };

    const changeFilteringDisabled = function (disabled) {
        setProperty(settings.DISABLE_FILTERING, disabled);
    };

    const isAutodetectFilters = function () {
        return !getProperty(settings.DISABLE_DETECT_FILTERS);
    };

    const changeAutodetectFilters = function (enabled, options) {
        setProperty(settings.DISABLE_DETECT_FILTERS, !enabled, options);
    };

    const showPageStatistic = function () {
        return !getProperty(settings.DISABLE_SHOW_PAGE_STATS);
    };

    const changeShowPageStatistic = function (enabled, options) {
        setProperty(settings.DISABLE_SHOW_PAGE_STATS, !enabled, options);
    };

    const isShowInfoAboutAdguardFullVersion = function () {
        return !getProperty(settings.DISABLE_SHOW_ADGUARD_PROMO_INFO);
    };

    const changeShowInfoAboutAdguardFullVersion = function (show, options) {
        setProperty(settings.DISABLE_SHOW_ADGUARD_PROMO_INFO, !show, options);
    };

    const isShowAppUpdatedNotification = function () {
        return !getProperty(settings.DISABLE_SHOW_APP_UPDATED_NOTIFICATION);
    };

    const changeShowAppUpdatedNotification = function (show, options) {
        setProperty(settings.DISABLE_SHOW_APP_UPDATED_NOTIFICATION, !show, options);
    };

    const changeEnableSafebrowsing = function (enabled, options) {
        setProperty(settings.DISABLE_SAFEBROWSING, !enabled, options);
    };

    const safebrowsingInfoEnabled = function () {
        return !getProperty(settings.DISABLE_SAFEBROWSING);
    };

    const collectHitsCount = function () {
        return !getProperty(settings.DISABLE_COLLECT_HITS);
    };

    const changeCollectHitsCount = function (enabled, options) {
        setProperty(settings.DISABLE_COLLECT_HITS, !enabled, options);
    };

    const showContextMenu = function () {
        return !getProperty(settings.DISABLE_SHOW_CONTEXT_MENU);
    };

    const changeShowContextMenu = function (enabled, options) {
        setProperty(settings.DISABLE_SHOW_CONTEXT_MENU, !enabled, options);
    };

    const isDefaultWhiteListMode = function () {
        return getProperty(settings.DEFAULT_WHITE_LIST_MODE);
    };

    const isUseOptimizedFiltersEnabled = function () {
        return getProperty(settings.USE_OPTIMIZED_FILTERS);
    };

    const changeUseOptimizedFiltersEnabled = function (enabled, options) {
        setProperty(settings.USE_OPTIMIZED_FILTERS, !!enabled, options);
    };

    const changeDefaultWhiteListMode = function (enabled) {
        setProperty(settings.DEFAULT_WHITE_LIST_MODE, enabled);
    };

    /**
     * Sets filters update period after conversion in number
     * @param period
     */
    const setFiltersUpdatePeriod = function (period) {
        let parsed = Number.parseInt(period, 10);
        if (Number.isNaN(parsed)) {
            parsed = DEFAULT_FILTERS_UPDATE_PERIOD;
        }
        setProperty(settings.FILTERS_UPDATE_PERIOD, parsed);
    };

    /**
     * Returns filter update period, converted in number
     * @returns {number}
     */
    const getFiltersUpdatePeriod = function () {
        const value = getProperty(settings.FILTERS_UPDATE_PERIOD);
        let parsed = Number.parseInt(value, 10);
        if (Number.isNaN(parsed)) {
            parsed = DEFAULT_FILTERS_UPDATE_PERIOD;
        }
        return parsed;
    };

    const isWebRTCDisabled = function () {
        return getProperty(settings.BLOCK_WEBRTC);
    };

    const disableShowAdguardPromoInfo = function () {
        setProperty(settings.DISABLE_SHOW_ADGUARD_PROMO_INFO, true);
    };

    const isDisableShowAdguardPromoInfo = function () {
        return getProperty(settings.DISABLE_SHOW_ADGUARD_PROMO_INFO);
    };

    const api = {};

    // Expose settings to api
    for (const key in settings) {
        if (settings.hasOwnProperty(key)) {
            api[key] = settings[key];
        }
    }

    api.getProperty = getProperty;
    api.setProperty = setProperty;
    api.getAllSettings = getAllSettings;

    api.onUpdated = propertyUpdateChannel;

    api.isFilteringDisabled = isFilteringDisabled;
    api.changeFilteringDisabled = changeFilteringDisabled;
    api.isAutodetectFilters = isAutodetectFilters;
    api.changeAutodetectFilters = changeAutodetectFilters;
    api.showPageStatistic = showPageStatistic;
    api.changeShowPageStatistic = changeShowPageStatistic;
    api.isShowInfoAboutAdguardFullVersion = isShowInfoAboutAdguardFullVersion;
    api.changeShowInfoAboutAdguardFullVersion = changeShowInfoAboutAdguardFullVersion;
    api.isShowAppUpdatedNotification = isShowAppUpdatedNotification;
    api.changeShowAppUpdatedNotification = changeShowAppUpdatedNotification;
    api.changeEnableSafebrowsing = changeEnableSafebrowsing;
    api.safebrowsingInfoEnabled = safebrowsingInfoEnabled;
    api.collectHitsCount = collectHitsCount;
    api.changeCollectHitsCount = changeCollectHitsCount;
    api.showContextMenu = showContextMenu;
    api.changeShowContextMenu = changeShowContextMenu;
    api.isDefaultWhiteListMode = isDefaultWhiteListMode;
    api.isUseOptimizedFiltersEnabled = isUseOptimizedFiltersEnabled;
    api.changeUseOptimizedFiltersEnabled = changeUseOptimizedFiltersEnabled;
    api.changeDefaultWhiteListMode = changeDefaultWhiteListMode;
    api.getFiltersUpdatePeriod = getFiltersUpdatePeriod;
    api.setFiltersUpdatePeriod = setFiltersUpdatePeriod;
    api.isWebRTCDisabled = isWebRTCDisabled;
    api.disableShowAdguardPromoInfo = disableShowAdguardPromoInfo;
    api.isDisableShowAdguardPromoInfo = isDisableShowAdguardPromoInfo;
    api.DEFAULT_FILTERS_UPDATE_PERIOD = DEFAULT_FILTERS_UPDATE_PERIOD;

    return api;
})(adguard);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Object that contains info about every browser tab.
 */
adguard.frames = (function (adguard) {
    'use strict';

    /**
     * Adds frame to map. This method is called on first document request.
     * If this is a main frame - saves this info in frame data.
     *
     * @param tab       Tab object
     * @param frameId   Frame ID
     * @param url       Page URL
     * @param type      Request content type (UrlFilterRule.contentTypes)
     * @returns Frame data
     */
    const recordFrame = function (tab, frameId, url, type) {
        const frame = adguard.tabs.getTabFrame(tab.tabId, frameId);

        let previousUrl = '';
        if (type === adguard.RequestTypes.DOCUMENT) {
            adguard.tabs.clearTabFrames(tab.tabId);
            adguard.tabs.clearTabMetadata(tab.tabId);
            if (frame) {
                previousUrl = frame.url;
            }
        }

        adguard.tabs.recordTabFrame(tab.tabId, frameId, url, adguard.utils.url.getDomainName(url));

        if (type === adguard.RequestTypes.DOCUMENT) {
            adguard.tabs.updateTabMetadata(tab.tabId, { previousUrl });
            reloadFrameData(tab);
        }
    };

    /**
     * This method reloads frame data and updates previous url if necessary
     * We use it in the webRequest.onCommit event because when website uses service worker
     * main_frame request can not fire in the webRequest events
     * @param tab
     * @param frameId
     * @param url
     * @param type
     */
    const checkAndRecordMainFrame = (tab, frameId, url, type) => {
        if (type !== adguard.RequestTypes.DOCUMENT) {
            return;
        }

        const { tabId } = tab;

        const frame = adguard.tabs.getTabFrame(tabId, frameId);

        // If no main_frame in tab, than we consider this as a new page load
        if (!frame) {
            adguard.tabs.recordTabFrame(tabId, frameId, url, adguard.utils.url.getDomainName(url));
            reloadFrameData(tab);
            return;
        }

        // if frame has different rule, then we consider this as a new page load
        let previousUrl = '';
        if (frame && frame.url !== url) {
            previousUrl = frame.url;
            adguard.tabs.clearTabFrames(tabId);
            adguard.tabs.clearTabMetadata(tabId);
            adguard.tabs.recordTabFrame(tabId, frameId, url, adguard.utils.url.getDomainName(url));
            adguard.tabs.updateTabMetadata(tabId, { previousUrl });
            reloadFrameData(tab);
        }
    };

    /**
     * Gets frame URL
     *
     * @param tab       Tab
     * @param frameId   Frame ID
     * @returns Frame URL
     */
    const getFrameUrl = function (tab, frameId) {
        const frame = adguard.tabs.getTabFrame(tab.tabId, frameId);
        return frame ? frame.url : null;
    };

    /**
     * Gets main frame URL
     *
     * @param tab    Tab
     * @returns Frame URL
     */
    const getMainFrameUrl = function (tab) {
        return getFrameUrl(tab, adguard.MAIN_FRAME_ID);
    };

    /**
     * Gets frame Domain
     *
     * @param tab       Tab
     * @returns Frame Domain
     */
    const getFrameDomain = function (tab) {
        const frame = adguard.tabs.getTabFrame(tab.tabId, 0);
        return frame ? frame.domainName : null;
    };

    /**
     * @param tab Tab
     * @returns true if Tab have white list rule
     */
    const isTabWhiteListed = function (tab) {
        const frameWhiteListRule = adguard.tabs.getTabMetadata(tab.tabId, 'frameWhiteListRule');
        return frameWhiteListRule && frameWhiteListRule.isDocumentWhiteList();
    };

    /**
     * @param tab Tab
     * @returns true if Tab have white list rule and white list isn't invert
     */
    const isTabWhiteListedForSafebrowsing = function (tab) {
        return isTabWhiteListed(tab) && adguard.whitelist.isDefaultMode();
    };

    /**
     * @param tab Tab
     * @returns true if protection is paused
     */
    const isTabProtectionDisabled = function (tab) {
        return adguard.tabs.getTabMetadata(tab.tabId, 'applicationFilteringDisabled');
    };

    /**
     * Returns true if tab is in white list
     *
     * @param tab Tab
     * @returns true if Adguard for Windows/Android/Mac is detected and tab in white list
     */
    const isTabAdguardWhiteListed = function (tab) {
        return adguard.tabs.getTabMetadata(tab.tabId, 'adguardDocumentWhiteListed');
    };

    /**
     * @param tab   Tab
     * @returns Adguard whitelist rule in user filter associated with this tab
     */
    const getTabAdguardUserWhiteListRule = function (tab) {
        const adguardUserWhiteListed = adguard.tabs.getTabMetadata(tab.tabId, 'adguardUserWhiteListed');
        if (adguardUserWhiteListed) {
            return adguard.tabs.getTabMetadata(tab.tabId, 'adguardWhiteListRule');
        }
        return null;
    };

    /**
     * Gets whitelist rule for the specified tab
     * @param tab Tab to check
     * @returns whitelist rule applied to that tab (if any)
     */
    const getFrameWhiteListRule = function (tab) {
        return adguard.tabs.getTabMetadata(tab.tabId, 'frameWhiteListRule');
    };

    /**
     * Reloads tab data (checks whitelist and filtering status)
     *
     * @param tab Tab to reload
     */
    var reloadFrameData = function (tab) {
        const frame = adguard.tabs.getTabFrame(tab.tabId, 0);
        if (frame) {
            const applicationFilteringDisabled = adguard.settings.isFilteringDisabled();
            let frameWhiteListRule = null;
            if (!applicationFilteringDisabled) {
                const { url } = frame;
                frameWhiteListRule = adguard.whitelist.findWhiteListRule(url);
                if (!frameWhiteListRule) {
                    frameWhiteListRule = adguard.requestFilter.findWhiteListRule(url, url, adguard.RequestTypes.DOCUMENT);
                }
            }
            adguard.tabs.updateTabMetadata(tab.tabId, {
                frameWhiteListRule,
                applicationFilteringDisabled,
            });
        }
    };

    /**
     * Attach referrer url to the tab's main frame object.
     * This referrer is then used on safebrowsing "Access Denied" for proper "Go Back" behavior.
     *
     * @param tab Tab
     * @param referrerUrl Referrer to record
     */
    const recordFrameReferrerHeader = function (tab, referrerUrl) {
        adguard.tabs.updateTabMetadata(tab.tabId, { referrerUrl });
    };

    /**
     * Gets main frame data
     *
     * @param tab Tab
     * @returns frame data
     */
    const getFrameInfo = function (tab) {
        const { tabId } = tab;
        const frame = adguard.tabs.getTabFrame(tabId);

        let { url } = tab;
        if (!url && frame) {
            url = frame.url;
        }

        const localStorageInitialized = adguard.localStorage.isInitialized();
        const urlFilteringDisabled = !adguard.utils.url.isHttpRequest(url);

        // application is available for tabs where url is with http schema
        // and when localstorage is initialized
        const applicationAvailable = localStorageInitialized && !urlFilteringDisabled;
        let documentWhiteListed = false;
        let userWhiteListed = false;
        let canAddRemoveRule = false;
        let frameRule;

        const adguardProductName = '';

        const totalBlocked = adguard.pageStats.getTotalBlocked() || 0;
        const totalBlockedTab = adguard.tabs.getTabMetadata(tabId, 'blocked') || 0;
        const applicationFilteringDisabled = adguard.settings.isFilteringDisabled();

        if (applicationAvailable) {
            documentWhiteListed = isTabWhiteListed(tab);
            if (documentWhiteListed) {
                const rule = getFrameWhiteListRule(tab);
                userWhiteListed = adguard.utils.filters.isWhiteListFilterRule(rule)
                        || adguard.utils.filters.isUserFilterRule(rule);
                frameRule = {
                    filterId: rule.filterId,
                    ruleText: rule.ruleText,
                };
            }
            // It means site in exception
            canAddRemoveRule = !(documentWhiteListed && !userWhiteListed);
        }

        const domainName = getFrameDomain(tab);

        return {
            url,
            applicationAvailable,
            domainName,
            applicationFilteringDisabled,
            urlFilteringDisabled,
            documentWhiteListed,
            userWhiteListed,
            canAddRemoveRule,
            frameRule,
            adguardProductName,
            totalBlockedTab,
            totalBlocked,
        };
    };

    /**
     * Update count of blocked requests
     *
     * @param tab - Tab
     * @param blocked - count of blocked requests
     * @returns  updated count of blocked requests
     */
    const updateBlockedAdsCount = function (tab, blocked) {
        adguard.pageStats.updateTotalBlocked(blocked);

        blocked = (adguard.tabs.getTabMetadata(tab.tabId, 'blocked') || 0) + blocked;
        adguard.tabs.updateTabMetadata(tab.tabId, { blocked });

        return blocked;
    };

    /**
     * Reset count of blocked requests for tab or overall stats
     * @param tab - Tab (optional)
     */
    const resetBlockedAdsCount = function (tab) {
        if (tab) {
            adguard.tabs.updateTabMetadata(tab.tabId, { blocked: 0 });
        } else {
            adguard.pageStats.resetStats();
        }
    };

    /**
     * Is tab in incognito mode?
     * @param tab Tab
     */
    const isIncognitoTab = function (tab) {
        return adguard.tabs.isIncognito(tab.tabId);
    };

    /**
     * Checks if we should process request further
     * @param {object} tab
     * @returns {boolean}
     */
    const shouldStopRequestProcess = tab => isTabProtectionDisabled(tab) || isTabWhiteListed(tab);

    // Records frames on application initialization
    adguard.listeners.addListener((event) => {
        if (event === adguard.listeners.APPLICATION_INITIALIZED) {
            adguard.tabs.forEach((tab) => {
                recordFrame(tab, 0, tab.url, adguard.RequestTypes.DOCUMENT);
            });
        }
    });

    return {
        recordFrame,
        getFrameUrl,
        getMainFrameUrl,
        getFrameDomain,
        isTabWhiteListed,
        isTabWhiteListedForSafebrowsing,
        isTabProtectionDisabled,
        isTabAdguardWhiteListed,
        getTabAdguardUserWhiteListRule,
        getFrameWhiteListRule,
        reloadFrameData,
        recordFrameReferrerHeader,
        getFrameInfo,
        updateBlockedAdsCount,
        resetBlockedAdsCount,
        isIncognitoTab,
        shouldStopRequestProcess,
        checkAndRecordMainFrame,
    };
})(adguard);

/* eslint-disable prefer-template */
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Helper methods for parsing and extracting browser cookies from headers (both Set-Cookie and Cookie).
 *
 * This API is exposed via adguard.utils.cookie:
 *
 * - parseCookie    Parses "Cookie" header value and returns all the cookie key-pairs
 * - parseSetCookie Parses "Set-Cookie" header value and returns the key-pairs
 * - serialize      Serializes cookie object into a set-cookie value
 *
 * Heavily inspired by https://github.com/nfriedly/set-cookie-parser and https://github.com/jshttp/cookie
 */
(function (adguard) {
    /**
     * RegExp to match field-content in RFC 7230 sec 3.2
     *
     * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
     * field-vchar   = VCHAR / obs-text
     * obs-text      = %x80-FF
     */
    // eslint-disable-next-line no-control-regex
    const FIELD_CONTENT_REGEX = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

    /**
     * @typedef {object} Cookie
     * @property {string} name Cookie name
     * @property {string} value Cookie value
     * @property {string} path Cookie path (string or undefined)
     * @property {string} domain Domain for the cookie (string or undefined,
     *                           may begin with "." to indicate the named domain or any subdomain of it)
     * @property {Date} expires Absolute expiration date for the cookie (Date object or undefined)
     * @property {number} maxAge relative max age of the cookie in seconds from when the client
     *                           receives it (integer or undefined)
     * @property {boolean} secure indicates that this cookie should only be sent over HTTPs (true or undefined)
     * @property {boolean} httpOnly indicates that this cookie should not be accessible to client-side
     *                              JavaScript (true or undefined)
     * @property {string} sameSite indicates a cookie ought not to be sent along with cross-site requests
     *                             (string or undefined)
     */

    /**
     * Parse an HTTP Cookie header string and return an object with all cookie name-value pairs.
     *
     * @param {string} cookieValue HTTP Cookie value
     * @returns {Array.<{ name: String, value: String }>} Array of cookie name-value pairs
     * @public
     */
    function parseCookie(cookieValue) {
        if (adguard.utils.strings.isEmpty(cookieValue)) {
            return null;
        }

        // Prepare the array to return
        const cookies = [];

        // Split Cookie values
        const pairs = cookieValue.split(/; */);

        for (let i = 0; i < pairs.length; i += 1) {
            const pair = pairs[i];
            const eqIdx = pair.indexOf('=');

            // skip things that don't look like key=value
            if (eqIdx < 0) {
                continue;
            }

            const key = pair.substr(0, eqIdx).trim();
            const value = pair.substr(eqIdx + 1, pair.length).trim();

            cookies.push({
                name: key,
                value,
            });
        }

        return cookies;
    }

    /**
     * Parses "Set-Cookie" header value and returns a cookie object with its properties
     *
     * @param {string} setCookieValue "Set-Cookie" header value to parse
     * @returns {Cookie} cookie object or null if it failed to parse the value
     * @public
     */
    function parseSetCookie(setCookieValue) {
        if (adguard.utils.strings.isEmpty(setCookieValue)) {
            return null;
        }

        const parts = setCookieValue.split(';').filter(s => !adguard.utils.strings.isEmpty(s));
        const nameValuePart = parts.shift();
        const nameValue = nameValuePart.split('=');
        const name = nameValue.shift();
        // everything after the first =, joined by a "=" if there was more than one part
        const value = nameValue.join('=');
        const cookie = {
            name, // grab everything before the first =
            value,
        };

        parts.forEach((part) => {
            const sides = part.split('=');
            const key = sides
                .shift()
                .trimLeft()
                .toLowerCase();
            const optionValue = sides.join('=');
            if (key === 'expires') {
                cookie.expires = new Date(optionValue);
            } else if (key === 'max-age') {
                cookie.maxAge = parseInt(optionValue, 10);
            } else if (key === 'secure') {
                cookie.secure = true;
            } else if (key === 'httponly') {
                cookie.httpOnly = true;
            } else if (key === 'samesite') {
                cookie.sameSite = optionValue;
            } else {
                // other keys
                cookie[key] = optionValue;
            }
        });

        return cookie;
    }

    /**
     * Serializes cookie data into a string suitable for Set-Cookie header.
     *
     * @param {Cookie} cookie A cookie object
     * @return {string} Set-Cookie string or null if it failed to serialize object
     * @throws {TypeError} Thrown in case of invalid input data
     * @public
     */
    function serialize(cookie) {
        if (!cookie) {
            throw new TypeError('empty cookie data');
        }

        // 1. Validate fields
        if (!FIELD_CONTENT_REGEX.test(cookie.name)) {
            throw new TypeError(`Cookie name is invalid: ${cookie.name}`);
        }
        if (cookie.value && !FIELD_CONTENT_REGEX.test(cookie.value)) {
            throw new TypeError(`Cookie value is invalid: ${cookie.value}`);
        }
        if (cookie.domain && !FIELD_CONTENT_REGEX.test(cookie.domain)) {
            throw new TypeError(`Cookie domain is invalid: ${cookie.domain}`);
        }
        if (cookie.path && !FIELD_CONTENT_REGEX.test(cookie.path)) {
            throw new TypeError(`Cookie path is invalid: ${cookie.path}`);
        }
        if (cookie.expires && typeof cookie.expires.toUTCString !== 'function') {
            throw new TypeError(`Cookie expires is invalid: ${cookie.expires}`);
        }

        // 2. Build Set-Cookie header value
        let setCookieValue = cookie.name + '=' + cookie.value;

        if (typeof cookie.maxAge === 'number' && !Number.isNaN(cookie.maxAge)) {
            setCookieValue += '; Max-Age=' + Math.floor(cookie.maxAge);
        }
        if (cookie.domain) {
            setCookieValue += '; Domain=' + cookie.domain;
        }
        if (cookie.path) {
            setCookieValue += '; Path=' + cookie.path;
        }
        if (cookie.expires) {
            setCookieValue += '; Expires=' + cookie.expires.toUTCString();
        }
        if (cookie.httpOnly) {
            setCookieValue += '; HttpOnly';
        }
        if (cookie.secure) {
            setCookieValue += '; Secure';
        }
        if (!adguard.utils.strings.isEmpty(cookie.sameSite)) {
            const sameSite = cookie.sameSite.toLowerCase();

            switch (sameSite) {
                case 'lax':
                    setCookieValue += '; SameSite=Lax';
                    break;
                case 'strict':
                    setCookieValue += '; SameSite=Strict';
                    break;
                case 'none':
                    setCookieValue += '; SameSite=None';
                    break;
                default:
                    throw new TypeError(`Cookie sameSite is invalid: ${cookie.sameSite}`);
            }
        }

        // Don't affected. Let it be here just in case
        // https://bugs.chromium.org/p/chromium/issues/detail?id=232693
        if (cookie.priority) {
            setCookieValue += `; Priority=${cookie.priority}`;
        }

        return setCookieValue;
    }

    // EXPOSE
    adguard.utils.cookie = {
        parseCookie,
        parseSetCookie,
        serialize,
    };
})(adguard);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/* global browser */

/**
 * Local storage implementation for chromium-based browsers
 */
adguard.localStorageImpl = (function () {

    var ADGUARD_SETTINGS_PROP = 'adguard-settings';
    var values = null;

    function checkError(ex) {
        if (ex) {
            adguard.console.error('{0}', ex);
        }
    }

    /**
     * Creates default handler for async operation
     * @param callback Callback, fired with parameters (ex, result)
     */
    function createDefaultAsyncHandler(callback) {

        var dfd = new adguard.utils.Promise();
        dfd.then(
            function (result) {
                callback(null, result);
            }, function (ex) {
                callback(ex);
            });

        return dfd;
    }

    /**
     * Reads data from storage.local
     * @param path Path
     * @param callback Callback
     */
    function read(path, callback) {

        var dfd = createDefaultAsyncHandler(callback);

        try {
            browser.storage.local.get(path, function (results) {
                if (browser.runtime.lastError) {
                    dfd.reject(browser.runtime.lastError);
                } else {
                    dfd.resolve(results ? results[path] : null);
                }
            });
        } catch (ex) {
            dfd.reject(ex);
        }
    }

    /**
     * Writes data to storage.local
     * @param path Path
     * @param data Data to write
     * @param callback Callback
     */
    function write(path, data, callback) {

        var dfd = createDefaultAsyncHandler(callback);

        try {
            var item = {};
            item[path] = data;
            browser.storage.local.set(item, function () {
                if (browser.runtime.lastError) {
                    dfd.reject(browser.runtime.lastError);
                } else {
                    dfd.resolve();
                }
            });
        } catch (ex) {
            dfd.reject(ex);
        }
    }

    /**
     * Migrates key-value pair from local storage to storage.local
     * Part of task https://github.com/AdguardTeam/AdguardBrowserExtension/issues/681
     * @param key Key to migrate
     */
    function migrateKeyValue(key) {
        if (key in localStorage) {
            var value = localStorage.getItem(key);
            localStorage.removeItem(key);
            setItem(key, value);
        }
    }

    /**
     * Retrieves value by key from cached values
     * @param key
     * @returns {*}
     */
    var getItem = function (key) {
        if (!isInitialized()) {
            return null;
        }
        if (!(key in values)) {
            migrateKeyValue(key);
        }
        return values[key];
    };

    var setItem = function (key, value) {
        if (!isInitialized()) {
            return;
        }
        values[key] = value;
        write(ADGUARD_SETTINGS_PROP, values, checkError);
    };

    var removeItem = function (key) {
        if (!isInitialized()) {
            return;
        }
        delete values[key];
        // Remove from localStorage too, as a part of migration process
        localStorage.removeItem(key);
        write(ADGUARD_SETTINGS_PROP, values, checkError);
    };

    var hasItem = function (key) {
        if (!isInitialized()) {
            return false;
        }
        if (key in values) {
            return true;
        }
        migrateKeyValue(key);
        return key in values;
    };

    /**
     * We can't use localStorage object anymore and we've decided to store all data into storage.local
     * localStorage is affected by cleaning tools: https://github.com/AdguardTeam/AdguardBrowserExtension/issues/681
     * storage.local has async nature and we have to preload all key-values pairs into memory on extension startup
     *
     * @param callback
     */
    var init = function (callback) {
        if (isInitialized()) {
            // Already initialized
            callback();
            return;
        }
        read(ADGUARD_SETTINGS_PROP, function (ex, items) {
            if (ex) {
                checkError(ex);
            }
            values = items || Object.create(null);
            callback();
        });
    };

    /**
     * Due to async initialization of storage, we have to check it before accessing values object
     * @returns {boolean}
     */
    var isInitialized = function () {
        return values !== null;
    };

    return {
        getItem: getItem,
        setItem: setItem,
        removeItem: removeItem,
        hasItem: hasItem,
        init: init,
        isInitialized: isInitialized
    };

})();

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Filter rules storage implementation
 */
adguard.rulesStorageImpl = (function () {
    /**
     * Checks runtime.lastError and calls "callback" if so.
     *
     * @returns {boolean} true if operation caused error
     */
    const checkLastError = function (callback) {
        if (browser.runtime.lastError) {
            callback(browser.runtime.lastError);
            return true;
        }

        return false;
    };

    const read = function (path, callback) {
        try {
            browser.storage.local.get(path, (results) => {
                if (!checkLastError(callback)) {
                    let lines = [];

                    if (results && results[path] instanceof Array) {
                        lines = results[path];
                    }

                    callback(null, lines);
                }
            });
        } catch (ex) {
            callback(ex);
        }
    };

    const write = function (path, data, callback) {
        const item = {};
        item[path] = data;
        try {
            browser.storage.local.set(item, () => {
                if (!checkLastError(callback)) {
                    callback();
                }
            });
        } catch (ex) {
            callback(ex);
        }
    };

    const remove = function (path, successCallback) {
        browser.storage.local.remove(path, successCallback);
    };

    return {
        read,
        write,
        remove,
    };
})();

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * localStorage interface. Implementation depends on browser
 */
adguard.localStorageImpl = adguard.localStorageImpl || (function () {
    function notImplemented() {
        throw new Error('Not implemented');
    }

    return {
        getItem: notImplemented,
        setItem: notImplemented,
        removeItem: notImplemented,
        hasItem: notImplemented,
    };
})();

/**
 * This class manages local storage
 */
adguard.localStorage = (function (adguard, impl) {
    const getItem = function (key) {
        return impl.getItem(key);
    };

    const setItem = function (key, value) {
        try {
            impl.setItem(key, value);
        } catch (ex) {
            adguard.console.error(`Error while saving item ${key} to the localStorage: ${ex}`);
        }
    };

    const removeItem = function (key) {
        impl.removeItem(key);
    };

    const hasItem = function (key) {
        return impl.hasItem(key);
    };

    const init = function (callback) {
        if (typeof impl.init === 'function') {
            impl.init(callback);
        } else {
            callback();
        }
    };

    const isInitialized = function () {
        // WebExtension storage has async initialization
        if (typeof impl.isInitialized === 'function') {
            return impl.isInitialized();
        }
        return true;
    };

    return {
        getItem,
        setItem,
        removeItem,
        hasItem,
        init,
        isInitialized,
    };
})(adguard, adguard.localStorageImpl);

/**
 * Rules storage interface. Implementation depends on browser
 */
adguard.rulesStorageImpl = adguard.rulesStorageImpl || (function () {
    function notImplemented() {
        throw new Error('Not implemented');
    }

    return {
        read: notImplemented,
        write: notImplemented,
    };
})();

/**
 * This class manages storage for filters.
 */
adguard.rulesStorage = (function (adguard, impl) {
    function getFilePath(filterId) {
        return `filterrules_${filterId}.txt`;
    }

    /**
     * Loads filter from the storage
     *
     * @param filterId  Filter identifier
     * @param callback  Called when file content has been loaded
     */
    const read = function (filterId, callback) {
        const filePath = getFilePath(filterId);
        impl.read(filePath, (e, rules) => {
            if (e) {
                adguard.console.error(`Error while reading rules from file ${filePath} cause: ${e}`);
            }
            callback(rules);
        });
    };

    /**
     * Saves filter rules to storage
     *
     * @param filterId      Filter identifier
     * @param filterRules   Filter rules
     * @param callback      Called when save operation is finished
     */
    const write = function (filterId, filterRules, callback) {
        const filePath = getFilePath(filterId);
        impl.write(filePath, filterRules, (e) => {
            if (e) {
                adguard.console.error(`Error writing filters to file ${filePath}. Cause: ${e}`);
            }
            callback();
        });
    };

    /**
     * Removes filter from storage
     * @param filterId
     * @param callback
     */
    const remove = (filterId, callback) => {
        const filePath = getFilePath(filterId);
        impl.remove(filePath, (e) => {
            if (e) {
                adguard.console.error(`Error removing filter ${filePath}. Cause: ${e}`);
            }
            callback();
        });
    };

    /**
     * IndexedDB implementation of the rules storage requires async initialization.
     * Also in some cases IndexedDB isn't supported, so we have to replace implementation
     * with the browser.storage
     *
     * @param callback
     */
    const init = function (callback) {
        if (typeof impl.init === 'function') {
            impl.init((api) => {
                impl = api;
                callback();
            });
        } else {
            callback();
        }
    };

    return {
        read,
        write,
        remove,
        init,
    };
})(adguard, adguard.rulesStorageImpl);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/* global adguardContent */

(function (adguard, self) {
    'use strict';

    /**
     * https://bugs.chromium.org/p/project-zero/issues/detail?id=1225&desc=6
     * Page script can inject global variables into the DOM,
     * so content script isolation doesn't work as expected
     * So we have to make additional check before accessing a global variable.
     */
    function isDefined(property) {
        return Object.prototype.hasOwnProperty.call(self, property);
    }

    const browserApi = isDefined('browser') && self.browser !== undefined ? self.browser : self.chrome;

    adguard.i18n = browserApi.i18n;

    adguard.runtimeImpl = (function () {
        const onMessage = (function () {
            if (browserApi.runtime && browserApi.runtime.onMessage) {
                // Chromium, Edge, Firefox WebExtensions
                return browserApi.runtime.onMessage;
            }
            // Old Chromium
            return browserApi.extension.onMessage || browserApi.extension.onRequest;
        })();

        const sendMessage = (function () {
            if (browserApi.runtime && browserApi.runtime.sendMessage) {
                // Chromium, Edge, Firefox WebExtensions
                return browserApi.runtime.sendMessage;
            }
            // Old Chromium
            return browserApi.extension.sendMessage || browserApi.extension.sendRequest;
        })();

        return {
            onMessage,
            sendMessage,
        };
    })();
})(typeof adguardContent !== 'undefined' ? adguardContent : adguard, this); // jshint ignore:line

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

const browser = window.browser || chrome;

(function (adguard, browser) {
    'use strict';

    adguard.runtime = (function () {
        const onMessage = {
            addListener(callback) {
                // https://developer.chrome.com/extensions/runtime#event-onMessage
                adguard.runtimeImpl.onMessage.addListener((message, sender, sendResponse) => {
                    const senderOverride = Object.create(null);
                    if (sender.tab) {
                        senderOverride.tab = adguard.tabsImpl.fromChromeTab(sender.tab);
                    }
                    if (typeof sender.frameId !== 'undefined') {
                        senderOverride.frameId = sender.frameId;
                    }
                    const response = callback(message, senderOverride, sendResponse);
                    const async = response === true;
                    // If async sendResponse will be invoked later
                    if (!async) {
                        sendResponse(response);
                    }
                    // Don't forget return callback result for asynchronous message passing
                    return async;
                });
            },
        };

        return {
            setUninstallURL: browser.runtime.setUninstallURL,
            onMessage,
            get lastError() {
                return browser.runtime.lastError;
            },
        };
    })();

    // Calculates scheme of this extension (e.g.: chrome-extension:// or moz-extension://)
    const extensionScheme = (function () {
        const url = browser.extension.getURL('');
        const index = url.indexOf('://');
        if (index > 0) {
            return url.substring(0, index);
        }
        return url;
    })();

    /**
     * We are skipping requests to internal resources of extensions
     * (e.g. chrome-extension:// or moz-extension://... etc.)
     * @param details Request details
     * @returns {boolean}
     */
    function shouldSkipRequest(details) {
        return details.tabId === adguard.BACKGROUND_TAB_ID
            && details.url.indexOf(extensionScheme) === 0;
    }

    const linkHelper = document.createElement('a');

    /**
     * Fixing request type:
     * https://code.google.com/p/chromium/issues/detail?id=410382
     *
     * @param url Request url
     * @returns String Fixed object type
     */
    function parseRequestTypeFromUrl(url) {
        linkHelper.href = url;
        const path = linkHelper.pathname;
        let requestType = adguard.utils.browser.parseContentTypeFromUrlPath(path);
        if (requestType === null) {
            // https://code.google.com/p/chromium/issues/detail?id=410382
            requestType = adguard.RequestTypes.OBJECT;
        }
        return requestType;
    }

    /**
     * An array of HTTP headers.
     * Each header is represented as a dictionary containing the keys name
     * and either value or binaryValue.
     * https://developer.chrome.com/extensions/webRequest#type-HttpHeaders
     * @typedef HttpHeaders
     * @type {Array.<{ name: String, value: String, binaryValue }>}
     */

    /**
     * @typedef RequestDetails
     * @type {Object}
     * @property {String} requestUrl - request url
     * @property {String} referrerUrl - the origin where the request was initiated
     * @property {{tabId: Number}} tab - request tab with tabId in property
     * @property {Number} requestId - the ID of the request
     * @property {Number} statusCode - standard HTTP status code
     * @property {String} method - standard HTTP method
     * @property {Number} frameId - ID of current frame. Frame IDs are unique within a tab.
     * @property {Number} requestFrameId - ID of frame where request is executed
     * @property {Number} requestType - request type {@link adguard.RequestTypes}
     * @property {HttpHeaders} [requestHeaders] - the HTTP request headers
     * @property {HttpHeaders} [responseHeaders] - the HTTP response headers
     * @property {String} redirectUrl - new URL in onBeforeRedirect event
     */

    /**
     * Argument passed to the webRequest event listener.
     * Every webRequest event listener has its own object with request details.
     * To learn more see https://developer.chrome.com/extensions/webRequest or
     * https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/webRequest
     * @typedef {Object} WebRequestDetails
     */

    /**
     * Transforms raw request details from different browsers into unified format
     * @param {WebRequestDetails} details raw webRequest details
     * @returns {RequestDetails} prepared request details
     */
    function getRequestDetails(details) {
        const tab = { tabId: details.tabId };

        /**
         * FF sends http instead of ws protocol at the http-listeners layer
         * Although this is expected, as the Upgrade request is indeed an HTTP request,
         * we use a chromium based approach in this case.
         */
        if (details.type === 'websocket' && details.url.indexOf('http') === 0) {
            details.url = details.url.replace(/^http(s)?:/, 'ws$1:');
        }

        // https://developer.chrome.com/extensions/webRequest#event-onBeforeRequest
        const requestDetails = {
            requestUrl: details.url,    // request url
            tab,                        // request tab,
            requestId: details.requestId,
            statusCode: details.statusCode,
            method: details.method,
        };

        let frameId = 0;        // id of this frame (only for main_frame and sub_frame types)
        let requestFrameId = 0; // id of frame where request is executed
        let requestType;        // request type

        switch (details.type) {
            case 'main_frame':
                frameId = 0;
                requestType = adguard.RequestTypes.DOCUMENT;
                break;
            case 'sub_frame':
                frameId = details.frameId;
                // for sub_frame use parentFrameId as id of frame that wraps this frame
                requestFrameId = details.parentFrameId;
                requestType = adguard.RequestTypes.SUBDOCUMENT;
                break;
            default:
                requestFrameId = details.frameId;
                requestType = details.type.toUpperCase();
                break;
        }

        // Relate request to main_frame
        if (requestFrameId === -1) {
            requestFrameId = 0;
        }

        if (requestType === 'IMAGESET') {
            requestType = adguard.RequestTypes.IMAGE;
        }

        if (requestType === adguard.RequestTypes.OTHER) {
            requestType = parseRequestTypeFromUrl(details.url);
        }

        /**
         * Use `OTHER` type as a fallback
         * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/777
         */
        if (!(requestType in adguard.RequestTypes)) {
            requestType = adguard.RequestTypes.OTHER;
        }

        requestDetails.frameId = frameId;
        requestDetails.requestFrameId = requestFrameId;
        requestDetails.requestType = requestType;

        if (details.requestHeaders) {
            requestDetails.requestHeaders = details.requestHeaders;
        }

        if (details.responseHeaders) {
            requestDetails.responseHeaders = details.responseHeaders;
        }

        if (details.tabId === adguard.BACKGROUND_TAB_ID) {
            // In case of background request, its details contains referrer url
            // Chrome uses `initiator`: https://developer.chrome.com/extensions/webRequest#event-onBeforeRequest
            // FF uses `originUrl`: https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/webRequest/onBeforeRequest#Additional_objects
            requestDetails.referrerUrl = details.originUrl || details.initiator;
        }
        requestDetails.originUrl = details.originUrl || details.initiator;

        return requestDetails;
    }

    const onBeforeRequest = {
        /**
         * Wrapper for webRequest.onBeforeRequest event
         * It prepares requestDetails and passes them to the callback
         * @param callback callback function receives {RequestDetails} and handles event
         * @param {String} urls url match pattern https://developer.chrome.com/extensions/match_patterns
         */
        addListener(callback, urls) {
            // https://developer.chrome.com/extensions/webRequest#event-onBeforeRequest
            browser.webRequest.onBeforeRequest.addListener((details) => {
                if (shouldSkipRequest(details)) {
                    return;
                }

                const requestDetails = getRequestDetails(details);
                return callback(requestDetails);
            }, urls ? { urls } : {}, ['blocking']);
        },
    };

    /**
     * Apply 'extraHeaders' option for request/response headers access/change. See:
     * https://groups.google.com/a/chromium.org/forum/#!topic/chromium-extensions/vYIaeezZwfQ
     * https://chromium-review.googlesource.com/c/chromium/src/+/1338165
     */

    const onBeforeSendHeadersExtraInfoSpec = ['requestHeaders', 'blocking'];
    const onHeadersReceivedExtraInfoSpec = ['responseHeaders', 'blocking'];

    if (typeof browser.webRequest.OnBeforeSendHeadersOptions !== 'undefined'
        && browser.webRequest.OnBeforeSendHeadersOptions.hasOwnProperty('EXTRA_HEADERS')) {
        onBeforeSendHeadersExtraInfoSpec.push('extraHeaders');
    }

    if (typeof browser.webRequest.OnHeadersReceivedOptions !== 'undefined'
        && browser.webRequest.OnHeadersReceivedOptions.hasOwnProperty('EXTRA_HEADERS')) {
        onHeadersReceivedExtraInfoSpec.push('extraHeaders');
    }

    const onHeadersReceived = {
        /**
         * Wrapper for webRequest.onHeadersReceived event
         * It prepares requestDetails and passes them to the callback
         * @param callback callback function receives {RequestDetails} and handles event
         * @param {Array.<String>} urls url match pattern https://developer.chrome.com/extensions/match_patterns
         */
        addListener(callback, urls) {
            browser.webRequest.onHeadersReceived.addListener((details) => {
                if (shouldSkipRequest(details)) {
                    return;
                }

                const requestDetails = getRequestDetails(details);
                const result = callback(requestDetails);
                if (result) {
                    return 'responseHeaders' in result ? { responseHeaders: result.responseHeaders } : {};
                }
            }, urls ? { urls } : {}, onHeadersReceivedExtraInfoSpec);
        },
    };

    const onBeforeSendHeaders = {
        /**
         * Wrapper for webRequest.onBeforeSendHeaders event
         * It prepares requestDetails and passes them to the callback
         * @param callback callback function receives {RequestDetails} and handles event
         * @param {Array.<String>} urls url match pattern https://developer.chrome.com/extensions/match_patterns
         */
        addListener(callback, urls) {
            let requestFilter = {};
            /**
             * Sometimes extraHeaders option of onBeforeSendHeaders handler is blocking network
             * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1634
             * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1644
             * https://bugs.chromium.org/p/chromium/issues/detail?id=938560
             * https://bugs.chromium.org/p/chromium/issues/detail?id=1075905
             * This issue was fixed in the Canary v85.0.4178.0 and would be fixed
             * in the Chrome with the same version
             * Until v85 we have decided to filter requests with types:
             * 'stylesheet', 'script', 'media'
             */
            if (adguard.prefs.browser === 'Chrome' && adguard.prefs.chromeVersion < 85) {
                const allTypes = [
                    'main_frame',
                    'sub_frame',
                    'stylesheet',
                    'script',
                    'image',
                    'font',
                    'object',
                    'xmlhttprequest',
                    'ping',
                    'csp_report',
                    'media',
                    'websocket',
                    'other',
                ];
                // this request types block requests, if use them with extraHeaders and blocking options
                const nonExtraHeadersTypes = ['stylesheet', 'script', 'media'];
                const extraHeadersTypes = allTypes.filter(type => !nonExtraHeadersTypes.includes(type));
                // Assign instead of spread used because FF begin to support them from v55
                // https://caniuse.com/#feat=mdn-javascript_operators_spread_spread_in_object_literals
                requestFilter = Object.assign(requestFilter, { types: extraHeadersTypes });
            }

            if (urls) {
                // Assign instead of spread used because FF begin to support them from v55
                // https://caniuse.com/#feat=mdn-javascript_operators_spread_spread_in_object_literals
                requestFilter = Object.assign(requestFilter, { urls });
            }

            browser.webRequest.onBeforeSendHeaders.addListener((details) => {
                if (shouldSkipRequest(details)) {
                    return;
                }

                const requestDetails = getRequestDetails(details);
                const result = callback(requestDetails);
                if (result) {
                    return 'requestHeaders' in result ? { requestHeaders: result.requestHeaders } : {};
                }
            }, requestFilter, onBeforeSendHeadersExtraInfoSpec);
        },
    };

    const onResponseStarted = {
        /**
         * Wrapper for webRequest.onResponseStarted event
         * It prepares requestDetails and passes them to the callback
         * @param callback callback function receives {RequestDetails} and handles event
         * @param {String} urls url match pattern https://developer.chrome.com/extensions/match_patterns
         */
        addListener(callback, urls) {
            browser.webRequest.onResponseStarted.addListener((details) => {
                if (shouldSkipRequest(details)) {
                    return;
                }
                const requestDetails = getRequestDetails(details);
                return callback(requestDetails);
            }, urls ? { urls } : {}, ['responseHeaders']);
        },
    };

    const onErrorOccurred = {
        /**
         * Wrapper for webRequest.onErrorOccurred event
         * It prepares requestDetails and passes them to the callback
         * @param callback callback function receives {RequestDetails} and handles event
         * @param {String} urls url match pattern https://developer.chrome.com/extensions/match_patterns
         */
        addListener(callback, urls) {
            browser.webRequest.onErrorOccurred.addListener((details) => {
                if (shouldSkipRequest(details)) {
                    return;
                }
                const requestDetails = getRequestDetails(details);
                return callback(requestDetails);
            }, urls ? { urls } : {});
        },
    };

    const onCompleted = {
        /**
         * Wrapper for webRequest.onCompleted event
         * It prepares requestDetails and passes them to the callback
         * @param callback callback function receives {RequestDetails} and handles event
         * @param {String} urls url match pattern https://developer.chrome.com/extensions/match_patterns
         */
        addListener(callback, urls) {
            browser.webRequest.onCompleted.addListener((details) => {
                if (shouldSkipRequest(details)) {
                    return;
                }
                const requestDetails = getRequestDetails(details);
                return callback(requestDetails);
            }, urls ? { urls } : {}, ['responseHeaders']);
        },
    };

    const onBeforeRedirect = {
        /**
         * Wrapper for webRequest.onBeforeRedirect event
         * It prepares requestDetails and passes them to the callback
         * @param callback callback function receives {RequestDetails} and handles event
         * @param {Array.<String>} urls url match pattern https://developer.chrome.com/extensions/match_patterns
         */
        addListener(callback, urls) {
            browser.webRequest.onBeforeRedirect.addListener((details) => {
                if (shouldSkipRequest(details)) {
                    return;
                }
                const requestDetails = getRequestDetails(details);
                requestDetails.redirectUrl = details.redirectUrl;
                return callback(requestDetails);
            }, urls ? { urls } : {});
        },
    };

    /**
     * Gets URL of a file that belongs to our extension
     * https://developer.chrome.com/apps/runtime#method-getURL
     */
    adguard.getURL = browser.runtime.getURL;

    adguard.backgroundPage = {};
    adguard.backgroundPage.getWindow = function () {
        return browser.extension.getBackgroundPage();
    };

    adguard.app = {

        /**
         * Extension ID
         */
        getId() {
            return browser.runtime.id;
        },

        /**
         * Gets extension scheme
         * @returns "chrome-extension" for Chrome," ms-browser-extension" for Edge
         */
        getUrlScheme() {
            const url = adguard.getURL('test.html');
            const index = url.indexOf('://');
            return url.substring(0, index);
        },

        /**
         * Extension version
         */
        getVersion() {
            return browser.runtime.getManifest().version;
        },

        /**
         * Extension UI locale
         */
        getLocale() {
            return browser.i18n.getUILanguage();
        },

        /**
         * Returns extension's full url
         */
        getExtensionUrl() {
            const url = adguard.getURL('');
            return url.substring(0, url.length - 1);
        },

        /**
         * If referrer of request contains full url of extension,
         * then this request is considered as extension's own request
         * (e.g. request for filter downloading)
         * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1437
         * @param referrerUrl
         * @returns {boolean}
         */
        isOwnRequest(referrerUrl) {
            return referrerUrl && referrerUrl.indexOf(this.getExtensionUrl()) === 0;
        },
    };

    adguard.webRequest = {
        onBeforeRequest,
        handlerBehaviorChanged: browser.webRequest.handlerBehaviorChanged,
        onCompleted,
        onErrorOccurred,
        onHeadersReceived,
        onBeforeSendHeaders,
        onResponseStarted,
        onBeforeRedirect,
        webSocketSupported: typeof browser.webRequest.ResourceType !== 'undefined'
            && browser.webRequest.ResourceType.WEBSOCKET === 'websocket',
        filterResponseData: browser.webRequest.filterResponseData,
    };

    const onCreatedNavigationTarget = {

        addListener(callback) {
            // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/webNavigation/onCreatedNavigationTarget#Browser_compatibility
            if (typeof browser.webNavigation.onCreatedNavigationTarget === 'undefined') {
                return;
            }

            browser.webNavigation.onCreatedNavigationTarget.addListener((details) => {
                if (details.tabId === adguard.BACKGROUND_TAB_ID) {
                    return;
                }

                callback({
                    tabId: details.tabId,
                    sourceTabId: details.sourceTabId,
                    url: details.url,
                });
            });
        },
    };

    const onCommitted = {
        /**
         * Wrapper for webNavigation.onCommitted event
         * It prepares webNavigation details and passes them to the callback
         * @param callback callback function receives object similar to {RequestDetails}
         * and handles event
         */
        addListener(callback) {
            // https://developer.chrome.com/extensions/webNavigation#event-onCommitted
            browser.webNavigation.onCommitted.addListener((details) => {
                // makes webNavigation.onCommitted details similar to webRequestDetails
                details.requestType = details.frameId === 0
                    ? adguard.RequestTypes.DOCUMENT
                    : adguard.RequestTypes.SUBDOCUMENT;
                details.tab = { tabId: details.tabId };
                details.requestUrl = details.url;
                callback(details);
            }, {
                url: [{
                    urlPrefix: 'http',
                }, {
                    urlPrefix: 'https',
                }],
            });
        },
    };

    // https://developer.chrome.com/extensions/webNavigation
    adguard.webNavigation = {
        onCreatedNavigationTarget,
        onCommitted,
        onDOMContentLoaded: browser.webNavigation.onDOMContentLoaded,
    };

    const browserActionSupported = typeof browser.browserAction.setIcon !== 'undefined';
    if (!browserActionSupported && browser.browserAction.onClicked) {
        // Open settings menu
        browser.browserAction.onClicked.addListener(() => {
            adguard.ui.openSettingsTab();
        });
    }

    adguard.browserAction = {
        /* eslint-disable-next-line no-unused-vars */
        setBrowserAction(tab, icon, badge, badgeColor, title) {
            if (!browserActionSupported) {
                return;
            }

            const { tabId } = tab;

            const onIconReady = function () {
                if (browser.runtime.lastError) {
                    return;
                }
                browser.browserAction.setBadgeText({ tabId, text: badge });

                if (browser.runtime.lastError) {
                    return;
                }
                if (badge) {
                    browser.browserAction.setBadgeBackgroundColor({ tabId, color: badgeColor });
                }

                // title setup via manifest.json file
                // chrome.browserAction.setTitle({tabId: tabId, title: title});
            };

            /**
             * Workaround for MS Edge.
             * For some reason Edge changes the inner state of the "icon"
             * object and adds a tabId property inside.
             */
            delete icon.tabId;

            if (browser.runtime.lastError) {
                return;
            }

            browser.browserAction.setIcon({ tabId, path: icon }, onIconReady);
        },
        setPopup() {
            // Do nothing. Popup is already installed in manifest file
        },
        resize() {
            // Do nothing
        },
        close() {
            // Do nothing
        },
    };

    adguard.contextMenus = browser.contextMenus;
})(adguard, browser);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/* global browser */

/**
 * Chromium windows implementation
 * @type {{onCreated, onRemoved, onUpdated, create, getLastFocused, forEachNative}}
 */
adguard.windowsImpl = (function (adguard) {

    'use strict';

    function toWindowFromChromeWindow(chromeWin) {
        return {
            windowId: chromeWin.id,
            type: chromeWin.type === 'normal' || chromeWin.type === 'popup' ? chromeWin.type : 'other'
        };
    }

    // Make compatible with Android WebExt
    if (typeof browser.windows === 'undefined') {

        browser.windows = (function () {

            var defaultWindow = {
                id: 1,
                type: 'normal'
            };

            var emptyListener = {
                addListener: function () {
                    // Doing nothing
                }
            };

            var create = function (createData, callback) {
                callback(defaultWindow);
            };

            var update = function (windowId, data, callback) {
                callback();
            };

            var getAll = function (query, callback) {
                callback(defaultWindow);
            };

            var getLastFocused = function (callback) {
                callback(defaultWindow);
            };

            return {
                onCreated: emptyListener,
                onRemoved: emptyListener,
                onFocusChanged: emptyListener,
                create: create,
                update: update,
                getAll: getAll,
                getLastFocused: getLastFocused
            };

        })();
    }

    var onCreatedChannel = adguard.utils.channels.newChannel();
    var onRemovedChannel = adguard.utils.channels.newChannel();
    var onUpdatedChannel = adguard.utils.channels.newChannel();

    // https://developer.chrome.com/extensions/windows#event-onCreated
    // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/windows/onCreated
    browser.windows.onCreated.addListener(function (chromeWin) {
        onCreatedChannel.notify(toWindowFromChromeWindow(chromeWin), chromeWin);
    });

    // https://developer.chrome.com/extensions/windows#event-onRemoved
    // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/windows/onRemoved
    browser.windows.onRemoved.addListener(function (windowId) {
        onRemovedChannel.notify(windowId);
    });

    var create = function (createData, callback) {
        // https://developer.chrome.com/extensions/windows#method-create
        // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/windows/create
        browser.windows.create(createData, function (chromeWin) {
            callback(toWindowFromChromeWindow(chromeWin), chromeWin);
        });
    };

    var forEachNative = function (callback) {
        // https://developer.chrome.com/extensions/windows#method-getAll
        // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/windows/getAll
        // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/569
        browser.windows.getAll({}, function (chromeWins) {
            for (var i = 0; i < chromeWins.length; i++) {
                var chromeWin = chromeWins[i];
                callback(chromeWin, toWindowFromChromeWindow(chromeWin));
            }
        });
    };

    var getLastFocused = function (callback) {
        // https://developer.chrome.com/extensions/windows#method-getLastFocused
        browser.windows.getLastFocused(function (chromeWin) {
            callback(chromeWin.id);
        });
    };

    return {

        onCreated: onCreatedChannel, // callback (adguardWin, nativeWin)
        onRemoved: onRemovedChannel, // callback (windowId)
        onUpdated: onUpdatedChannel, // empty

        create: create,
        getLastFocused: getLastFocused,

        forEachNative: forEachNative
    };

})(adguard);

/**
 * Chromium tabs implementation
 * @type {{onCreated, onRemoved, onUpdated, onActivated, create, remove, activate, reload, sendMessage, getAll, getActive, fromChromeTab}}
 */
adguard.tabsImpl = (function (adguard) {

    'use strict';

    /**
     * tabId parameter must be integer
     * @param tabId
     */
    function tabIdToInt(tabId) {
        return parseInt(tabId);
    }

    function checkLastError(operation) {
        var ex = browser.runtime.lastError;
        if (ex) {
            adguard.console.error("Error while executing operation{1}: {0}", ex, operation ? " '" + operation + "'" : '');
        }
        return ex;
    }

    // https://developer.chrome.com/extensions/tabs#type-Tab
    function toTabFromChromeTab(chromeTab) {
        return {
            tabId: chromeTab.id,
            url: chromeTab.url,
            title: chromeTab.title,
            incognito: chromeTab.incognito,
            status: chromeTab.status
        };
    }

    // https://developer.chrome.com/extensions/tabs#event-onCreated
    var onCreatedChannel = adguard.utils.channels.newChannel();
    browser.tabs.onCreated.addListener(function (chromeTab) {
        onCreatedChannel.notify(toTabFromChromeTab(chromeTab));
    });

    // https://developer.chrome.com/extensions/tabs#event-onCreated
    var onRemovedChannel = adguard.utils.channels.newChannel();
    browser.tabs.onRemoved.addListener(function (tabId) {
        onRemovedChannel.notify(tabId);
    });

    var onUpdatedChannel = adguard.utils.channels.newChannel();
    // https://developer.chrome.com/extensions/tabs#event-onUpdated
    browser.tabs.onUpdated.addListener(function (tabId, changeInfo, tab) {
        onUpdatedChannel.notify(toTabFromChromeTab(tab));
    });

    // https://developer.chrome.com/extensions/tabs#event-onActivated
    var onActivatedChannel = adguard.utils.channels.newChannel();
    browser.tabs.onActivated.addListener(function (activeInfo) {
        onActivatedChannel.notify(activeInfo.tabId);
    });

    // https://developer.chrome.com/extensions/windows#event-onFocusChanged
    browser.windows.onFocusChanged.addListener(function (windowId) {
        if (windowId === browser.windows.WINDOW_ID_NONE) {
            return;
        }
        getActive(onActivatedChannel.notify);
    });

    /**
     * Give focus to a window
     * @param tabId Tab identifier
     * @param windowId Window identifier
     * @param callback Callback
     */
    function focusWindow(tabId, windowId, callback) {
        /**
         * Updating already focused window produces bug in Edge browser
         * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/675
         */
        getActive(function (activeTabId) {
            if (tabId !== activeTabId) {
                // Focus window
                browser.windows.update(windowId, { focused: true }, function () {
                    if (checkLastError("Update window " + windowId)) {
                        return;
                    }
                    callback();
                });
            }
            callback();
        });
    }

    var create = function (createData, callback) {

        var url = createData.url;
        var active = createData.active === true;

        if (createData.type === 'popup' &&
            // Does not work properly in Anniversary builds
            !adguard.utils.browser.isEdgeBeforeCreatorsUpdate() &&
            // Isn't supported by Android WebExt
            !adguard.prefs.mobile) {
            // https://developer.chrome.com/extensions/windows#method-create
            // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/windows/create
            browser.windows.create({
                url: url,
                type: 'popup',
                width: 1230,
                height: 630
            }, callback);
            return;
        }

        var isHttp = url.indexOf('http') === 0;

        function onWindowFound(win) {
            // https://developer.chrome.com/extensions/tabs#method-create
            browser.tabs.create({
                /**
                 * In the Firefox browser for Android there is not concept of windows
                 * There is only one window whole time
                 * Thats why if we try to provide windowId, method fails with error.
                 */
                windowId: !adguard.prefs.mobile ? win.id : undefined,
                url: url,
                active: active,
            }, function (chromeTab) {
                if (active) {
                    focusWindow(chromeTab.id, chromeTab.windowId, function () {
                    });
                }
                callback(toTabFromChromeTab(chromeTab));
            });
        }

        function isAppropriateWindow(win) {
            // We can't open not-http (e.g. 'chrome-extension://') urls in incognito mode
            return win.type === 'normal' && (isHttp || !win.incognito);
        }

        // https://developer.chrome.com/extensions/windows#method-create
        // https://developer.chrome.com/extensions/windows#method-getLastFocused
        // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/windows/create
        // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/windows/getLastFocused

        browser.windows.getLastFocused(function (win) {
            if (isAppropriateWindow(win)) {
                onWindowFound(win);
                return;
            }

            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/569
            browser.windows.getAll({}, function (wins) {
                if (wins) {
                    for (var i = 0; i < wins.length; i++) {
                        var win = wins[i];
                        if (isAppropriateWindow(win)) {
                            onWindowFound(win);
                            return;
                        }
                    }
                }

                // Create new window
                browser.windows.create({}, onWindowFound);
            });
        });
    };

    var remove = function (tabId, callback) {
        // https://developer.chrome.com/extensions/tabs#method-remove
        // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/tabs/remove
        browser.tabs.remove(tabIdToInt(tabId), function () {
            if (checkLastError()) {
                return;
            }
            callback(tabId);
        });
    };

    var activate = function (tabId, callback) {
        // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/tabs/update
        browser.tabs.update(tabIdToInt(tabId), { active: true }, function (chromeTab) {
            if (checkLastError("Before tab update")) {
                return;
            }
            focusWindow(tabId, chromeTab.windowId, function () {
                callback(tabId);
            });
        });
    };

    var reload = function (tabId, url) {
        if (url) {
            if (adguard.utils.browser.isEdgeBrowser()) {
                /**
                 * For security reasons, in Firefox and Edge, this may not be a privileged URL.
                 * So passing any of the following URLs will fail, with runtime.lastError being set to an error message:
                 * chrome: URLs
                 * javascript: URLs
                 * data: URLs
                 * privileged about: URLs (for example, about:config, about:addons, about:debugging).
                 *
                 * Non-privileged URLs (about:home, about:newtab, about:blank) are allowed.
                 *
                 * So we use a content script instead.
                 */
                /**
                 * Content script may not have been loaded at this point yet.
                 * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/580
                 */
                setTimeout(function () {
                    sendMessage(tabId, { type: 'update-tab-url', url: url });
                }, 100);
            } else {
                browser.tabs.update(tabIdToInt(tabId), { url: url }, checkLastError);
            }
        } else {
            // https://developer.chrome.com/extensions/tabs#method-reload
            // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/tabs/reload#Browser_compatibility
            if (browser.tabs.reload) {
                browser.tabs.reload(tabIdToInt(tabId), { bypassCache: true }, checkLastError);
            } else {
                // Reload page without cache via content script
                sendMessage(tabId, { type: 'no-cache-reload' });
            }
        }
    };

    var sendMessage = function (tabId, message, responseCallback, options) {
        // https://developer.chrome.com/extensions/tabs#method-sendMessage
        // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/tabs/sendMessage
        if (typeof options === 'object' && browser.tabs.sendMessage) {
            browser.tabs.sendMessage(tabIdToInt(tabId), message, options, responseCallback);
            return;
        }
        (browser.tabs.sendMessage || browser.tabs.sendRequest)(tabIdToInt(tabId), message, responseCallback);
    };

    var getAll = function (callback) {
        // https://developer.chrome.com/extensions/tabs#method-query
        // https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/tabs/query
        browser.tabs.query({}, function (chromeTabs) {
            var result = [];
            for (var i = 0; i < chromeTabs.length; i++) {
                var chromeTab = chromeTabs[i];
                result.push(toTabFromChromeTab(chromeTab));
            }
            callback(result);
        });
    };

    var getActive = function (callback) {
        /**
         * lastFocusedWindow parameter isn't supported by Opera
         * But seems currentWindow has the same effect in our case.
         * See for details:
         * https://developer.chrome.com/extensions/windows#current-window
         * https://dev.opera.com/extensions/tab-window/#accessing-the-current-tab
         * https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/tabs/query
         */
        browser.tabs.query({ currentWindow: true, active: true }, function (tabs) {
            if (tabs && tabs.length > 0) {
                callback(tabs[0].id);
            }
        });
    };

    /**
     * Gets tab by id
     * @param tabId Tab identifier
     * @param callback
     */
    var get = function (tabId, callback) {
        browser.tabs.get(tabIdToInt(tabId), function (chromeTab) {
            if (browser.runtime.lastError) {
                return;
            }
            callback(toTabFromChromeTab(chromeTab));
        });
    };

    /**
     * The only purpose of this callback is to read `lastError` and prevent
     * unnecessary console warnings (can happen with Chrome preloaded tabs).
     * See https://stackoverflow.com/questions/43665470/cannot-call-chrome-tabs-executescript-into-preloaded-tab-is-this-a-bug-in-chr
     */
    const noopCallback = function () {
        adguard.runtime.lastError;
    };

    /**
     * Updates tab url
     * @param {number} tabId
     * @param {string} url
     */
    const updateUrl = (tabId, url) => {
        if (tabId === 0) {
            return;
        }
        browser.tabs.update(tabId, { url }, noopCallback);
    };

    /**
     * True if `browser.tabs.insertCSS` supports `cssOrigin: "user"`.
     */
    let userCSSSupport = true;

    /**
     * Inserts CSS using the `browser.tabs.insertCSS` under the hood.
     * This method always injects CSS using `runAt: document_start`/
     *
     * @param {number} tabId Tab id or null if you want to inject into the active tab
     * @param {number} requestFrameId Target frame id (CSS will be inserted into that frame)
     * @param {number} code CSS code to insert
     */
    const insertCssCode = !browser.tabs.insertCSS ? undefined : function (tabId, requestFrameId, code) {
        const injectDetails = {
            code,
            runAt: 'document_start',
            frameId: requestFrameId,
            matchAboutBlank: true,
        };

        if (userCSSSupport) {
            // If this is set for not supporting browser, it will throw an error.
            injectDetails.cssOrigin = 'user';
        }

        try {
            browser.tabs.insertCSS(tabId, injectDetails, noopCallback);
        } catch (e) {
            // e.message in edge is undefined
            const errorMessage = e.message || e;
            // Some browsers do not support user css origin
            if (/\bcssOrigin\b/.test(errorMessage)) {
                userCSSSupport = false;
            }
        }
    };

    /**
     * Executes the specified JS code using `browser.tabs.executeScript` under the hood.
     * This method forces `runAt: document_start`.
     *
     * @param {number} tabId Tab id or null if you want to inject into the active tab
     * @param {requestFrameId} requestFrameId Target frame id (script will be injected into that frame)
     * @param {requestFrameId} code Javascript code to execute
     */
    const executeScriptCode = !browser.tabs.executeScript ? undefined : function (tabId, requestFrameId, code) {
        browser.tabs.executeScript(tabId, {
            code: code,
            frameId: requestFrameId,
            runAt: 'document_start',
            matchAboutBlank: true,
        }, noopCallback);
    };

    /**
     * Executes the specified javascript file in the top frame of the specified tab.
     * This method forces `runAt: document_start`.
     *
     * @param {number} tabId Tab id or null if you want to inject into the active tab
     * @param {Object} options
     * @param {string} options.file - Path to the javascript file
     * @param {number} [options.frameId=0] - id of the frame, default to the 0;
     * @param {function} callback Called when the script injection is complete
     */
    const executeScriptFile = !browser.tabs.executeScript
        ? undefined
        : (tabId, options, callback) => {
            const { file, frameId = 0 } = options;
            const executeScriptOptions = {
                file,
                runAt: 'document_start',
            };

            // Chrome 49 throws an exception if browser.tabs.executeScript is called
            // with a frameId equal to 0
            if (frameId !== 0) {
                executeScriptOptions.frameId = frameId;
            }

            browser.tabs.executeScript(tabId, executeScriptOptions, () => {
                noopCallback();
                if (callback) {
                    callback();
                }
            });
        };

    return {

        onCreated: onCreatedChannel,
        onRemoved: onRemovedChannel,
        onUpdated: onUpdatedChannel,
        onActivated: onActivatedChannel,

        create: create,
        remove: remove,
        activate: activate,
        reload: reload,
        sendMessage: sendMessage,
        getAll: getAll,
        getActive: getActive,
        get: get,
        updateUrl: updateUrl,

        insertCssCode: insertCssCode,
        executeScriptCode: executeScriptCode,
        executeScriptFile: executeScriptFile,

        fromChromeTab: toTabFromChromeTab
    };

})(adguard);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (adguard) {
    'use strict';

    adguard.windowsImpl = adguard.windowsImpl || (function () {
        function noOpFunc() {
            throw new Error('Not implemented');
        }

        const emptyListener = {
            addListener: noOpFunc,
            removeListener: noOpFunc,
        };

        return {

            onCreated: emptyListener, // callback (adguardWin, nativeWin)
            onRemoved: emptyListener, // callback (windowId, nativeWin)
            onUpdated: emptyListener, // callback (adguardWin, nativeWin, type) (Defined only for Firefox)

            create: noOpFunc,
            getLastFocused: noOpFunc, // callback (windowId, nativeWin)
            forEachNative: noOpFunc, // callback (nativeWin, adguardWin)
        };
    });

    adguard.windows = (function (windowsImpl) {
        // eslint-disable-next-line no-unused-vars
        const AdguardWin = {
            windowId: 1,
            type: 'normal', // 'popup'
        };

        function noOpFunc() {
        }

        const adguardWindows = Object.create(null); // windowId => AdguardWin

        windowsImpl.forEachNative((nativeWin, adguardWin) => {
            adguardWindows[adguardWin.windowId] = adguardWin;
        });

        const onCreatedChannel = adguard.utils.channels.newChannel();
        const onRemovedChannel = adguard.utils.channels.newChannel();

        windowsImpl.onCreated.addListener((adguardWin) => {
            adguardWindows[adguardWin.windowId] = adguardWin;
            onCreatedChannel.notify(adguardWin);
        });

        windowsImpl.onRemoved.addListener((windowId) => {
            const adguardWin = adguardWindows[windowId];
            if (adguardWin) {
                onRemovedChannel.notify(adguardWin);
                delete adguardWindows[windowId];
            }
        });

        const create = function (createData, callback) {
            windowsImpl.create(createData, callback || noOpFunc);
        };

        const getLastFocused = function (callback) {
            windowsImpl.getLastFocused((windowId) => {
                const metadata = adguardWindows[windowId];
                if (metadata) {
                    callback(metadata[0]);
                }
            });
        };

        return {

            onCreated: onCreatedChannel,    // callback(adguardWin)
            onRemoved: onRemovedChannel,    // callback(adguardWin)

            create,
            getLastFocused, // callback (adguardWin)
        };
    })(adguard.windowsImpl);

    adguard.tabsImpl = adguard.tabsImpl || (function () {
        function noOpFunc() {
            throw new Error('Not implemented');
        }

        const emptyListener = {
            addListener: noOpFunc,
            removeListener: noOpFunc,
        };

        return {

            onCreated: emptyListener, // callback(tab)
            onRemoved: emptyListener, // callback(tabId)
            onUpdated: emptyListener, // callback(tab)
            onActivated: emptyListener, // callback(tabId)

            create: noOpFunc, // callback(tab)
            remove: noOpFunc, // callback(tabId)
            activate: noOpFunc, // callback(tabId)
            reload: noOpFunc,
            sendMessage: noOpFunc,
            getAll: noOpFunc, // callback(tabs)
            getActive: noOpFunc, // callback(tabId),
            get: noOpFunc, // callback(tab)
        };
    })();

    adguard.tabs = (function (tabsImpl) {
        // eslint-disable-next-line no-unused-vars
        const AdguardTab = {
            tabId: 1,
            url: 'url',
            title: 'Title',
            incognito: false,
            status: null,   // 'loading' or 'complete'
            frames: null,   // Collection of frames inside tab
            metadata: null,  // Contains info about white list rule is applied to tab.
        };

        // eslint-disable-next-line no-unused-vars
        const AdguardTabFrame = {
            frameId: 1,
            url: 'url',
            domainName: 'domainName',
        };

        function noOpFunc() {
        }

        const tabs = Object.create(null);

        // Fired when a tab is created. Note that the tab's URL may not be set at the time
        // this event fired, but you can listen to onUpdated events to be notified when a URL is set.
        const onCreatedChannel = adguard.utils.channels.newChannel();

        // Fired when a tab is closed.
        const onRemovedChannel = adguard.utils.channels.newChannel();

        // Fired when a tab is updated.
        const onUpdatedChannel = adguard.utils.channels.newChannel();

        // Fires when the active tab in a window changes.
        const onActivatedChannel = adguard.utils.channels.newChannel();

        /**
         * Saves tab to collection and notify listeners
         * @param aTab
         */
        function onTabCreated(aTab) {
            const tab = tabs[aTab.tabId];
            if (tab) {
                // Tab has been already synchronized
                return;
            }
            tabs[aTab.tabId] = aTab;
            onCreatedChannel.notify(aTab);
        }

        // Synchronize opened tabs
        tabsImpl.getAll((aTabs) => {
            for (let i = 0; i < aTabs.length; i++) {
                const aTab = aTabs[i];
                tabs[aTab.tabId] = aTab;
            }
        });

        tabsImpl.onCreated.addListener(onTabCreated);

        tabsImpl.onRemoved.addListener((tabId) => {
            const tab = tabs[tabId];
            if (tab) {
                onRemovedChannel.notify(tab);
                delete tabs[tabId];
            }
        });

        tabsImpl.onUpdated.addListener((aTab) => {
            const tab = tabs[aTab.tabId];
            if (tab) {
                tab.url = aTab.url;
                tab.title = aTab.title;
                tab.status = aTab.status;
                // If the tab was updated it means that it wasn't used to send requests in the background
                tab.synthetic = false;
                onUpdatedChannel.notify(tab);
            }
        });

        tabsImpl.onActivated.addListener((tabId) => {
            const tab = tabs[tabId];
            if (tab) {
                onActivatedChannel.notify(tab);
            }
        });

        // --------- Actions ---------

        // Creates a new tab.
        const create = function (details, callback) {
            tabsImpl.create(details, callback || noOpFunc);
        };

        // Closes tab.
        const remove = function (tabId, callback) {
            tabsImpl.remove(tabId, callback || noOpFunc);
        };

        // Activates tab (Also makes tab's window in focus).
        const activate = function (tabId, callback) {
            tabsImpl.activate(tabId, callback || noOpFunc);
        };

        // Reloads tab.
        const reload = function (tabId, url) {
            tabsImpl.reload(tabId, url);
        };

        // Updates tab url
        const updateUrl = (tabId, url) => {
            tabsImpl.updateUrl(tabId, url);
        };

        // Sends message to tab
        const sendMessage = function (tabId, message, responseCallback, options) {
            tabsImpl.sendMessage(tabId, message, responseCallback, options);
        };

        // Gets all opened tabs
        const getAll = function (callback) {
            tabsImpl.getAll((aTabs) => {
                const result = [];
                for (let i = 0; i < aTabs.length; i++) {
                    const aTab = aTabs[i];
                    let tab = tabs[aTab.tabId];
                    if (!tab) {
                        // Synchronize state
                        tabs[aTab.tabId] = tab = aTab;
                    }
                    result.push(tab);
                }
                callback(result);
            });
        };

        const forEach = function (callback) {
            tabsImpl.getAll((aTabs) => {
                for (let i = 0; i < aTabs.length; i++) {
                    const aTab = aTabs[i];
                    let tab = tabs[aTab.tabId];
                    if (!tab) {
                        // Synchronize state
                        tabs[aTab.tabId] = tab = aTab;
                    }
                    callback(tab);
                }
            });
        };

        // Gets active tab
        const getActive = function (callback) {
            tabsImpl.getActive((tabId) => {
                const tab = tabs[tabId];
                if (tab) {
                    callback(tab);
                } else {
                    // Tab not found in the local state, but we are sure that this tab exists. Sync...
                    // TODO[Edge]: Relates to Edge Bug https://github.com/AdguardTeam/AdguardBrowserExtension/issues/481
                    tabsImpl.get(tabId, (tab) => {
                        onTabCreated(tab);
                        callback(tab);
                    });
                }
            });
        };

        const isIncognito = function (tabId) {
            const tab = tabs[tabId];
            return tab && tab.incognito === true;
        };

        // Records tab's frame
        const recordTabFrame = function (tabId, frameId, url, domainName) {
            let tab = tabs[tabId];
            if (!tab && frameId === 0) {
                // Sync tab for that 'onCreated' event was missed.
                // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/481
                tab = {
                    tabId,
                    url,
                    status: 'loading',
                    // We mark this tabs as synthetic because actually they may not exists
                    synthetic: true,
                };
                onTabCreated(tab);
            }
            if (tab) {
                if (!tab.frames) {
                    tab.frames = Object.create(null);
                }
                tab.frames[frameId] = {
                    url,
                    domainName,
                };
            }
        };

        const clearTabFrames = function (tabId) {
            const tab = tabs[tabId];
            if (tab) {
                tab.frames = null;
            }
        };

        // Gets tab's frame by id
        const getTabFrame = function (tabId, frameId) {
            const tab = tabs[tabId];
            if (tab && tab.frames) {
                return tab.frames[frameId || 0];
            }
            return null;
        };

        /**
         * Checks if the tab is new tab for popup or not
         * May be false positive for FF at least because new tab url in FF is "about:blank" too
         * @param tabId
         * @returns {boolean}
         */
        const isNewPopupTab = (tabId) => {
            const tab = tabs[tabId];
            if (!tab) {
                return false;
            }
            return !!(tab.url === '' || tab.url === 'about:blank');
        };

        // Update tab metadata
        const updateTabMetadata = function (tabId, values) {
            const tab = tabs[tabId];
            if (tab) {
                if (!tab.metadata) {
                    tab.metadata = Object.create(null);
                }
                for (const key in values) {
                    if (values.hasOwnProperty && values.hasOwnProperty(key)) {
                        tab.metadata[key] = values[key];
                    }
                }
            }
        };

        // Gets tab metadata
        const getTabMetadata = function (tabId, key) {
            const tab = tabs[tabId];
            if (tab && tab.metadata) {
                return tab.metadata[key];
            }
            return null;
        };

        const clearTabMetadata = function (tabId) {
            const tab = tabs[tabId];
            if (tab) {
                tab.metadata = null;
            }
        };

        // Injecting resources to tabs
        const { insertCssCode } = tabsImpl;
        const { executeScriptCode } = tabsImpl;
        const { executeScriptFile } = tabsImpl;

        return {
            // Events
            onCreated: onCreatedChannel,
            onRemoved: onRemovedChannel,
            onUpdated: onUpdatedChannel,
            onActivated: onActivatedChannel,

            // Actions
            create,
            remove,
            activate,
            reload,
            sendMessage,
            getAll,
            forEach,
            getActive,
            isIncognito,
            updateUrl,

            // Frames
            recordTabFrame,
            clearTabFrames,
            getTabFrame,
            isNewPopupTab,

            // Other
            updateTabMetadata,
            getTabMetadata,
            clearTabMetadata,

            insertCssCode,
            executeScriptCode,
            executeScriptFile,
        };
    })(adguard.tabsImpl);
})(adguard);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Namespace for adguard rules classes and utils
 */
adguard.rules = (function () {
    'use strict';

    return {};
})();

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (adguard, api) {

    'use strict';

    // Constants
    const SHORTCUT_LENGTH = 5;

    /**
     * Gets a list of shortcuts that can be used for the lookup table
     * 
     * @param {UrlFilterRule} rule basic rule
     * @returns {Array<string>} a list of applicable shortcuts or null if no shortcuts found
     */
    function getRuleShortcuts(rule) {
        if (!rule.shortcut || rule.shortcut.length < SHORTCUT_LENGTH) {
            return null;
        }
        let shortcuts = [];
        for (let i = 0; i <= rule.shortcut.length - SHORTCUT_LENGTH; i++) {
            let shortcut = rule.shortcut.substring(i, i + SHORTCUT_LENGTH);
            shortcuts.push(shortcut);
        }
        return shortcuts;
    }

    /**
     * Avoid adding rules that match too many URLs.
     * We'd better use DomainsLookupTable for them.
     * 
     * @param {UrlFilterRule} rule rule to check
     */
    function isAnyUrlShortcut(rule) {
        if (!rule.shortcut || rule.shortcut.length < SHORTCUT_LENGTH) {
            return true;
        }

        // Sorry for magic numbers
        // The numbers are basically ("PROTO://".length + 1)

        if (rule.shortcut.length < 6 && rule.shortcut.indexOf('ws:') === 0) {
            return true;
        }

        if (rule.shortcut.length < 7 && rule.shortcut.indexOf('|ws:') === 0) {
            return true;
        }

        if (rule.shortcut.length < 9 && rule.shortcut.indexOf('http') === 0) {
            return true;
        }

        if (rule.shortcut.length < 10 && rule.shortcut.indexOf('|http') === 0) {
            return true;
        }

        return false;
    }

    /**
     * djb2 hash algorithm
     * 
     * @param {String} str string
     * @param {Number} begin start index
     * @param {Number} end end index
     * @param {Number} hash value
     */
    function djb2HashBetween(str, begin, end) {
        let hash = 5381;
        for (let i = begin; i < end; i += 1) {
            hash = (hash * 33) ^ str.charCodeAt(i);
        }
        return hash >>> 0;
    }

    /**
     * djb2 hash algorithm
     * 
     * @param {String} str string
     * @returns {Number} hash value
     */
    function djb2Hash(str) {
        if (!str) {
            return 0;
        }
        return djb2HashBetween(str, 0, str.length);
    }

    /**
     * Special hash table that greatly increases speed of searching url filter rule by its shortcut
     */
    const ShortcutsLookupTable = function (rules) {

        this.lookupTable = new Map();
        this.histogram = new Map();

        if (rules) {
            for (let i = 0; i < rules.length; i++) {
                this.addRule(rules[i]);
            }
        }
    };

    ShortcutsLookupTable.prototype = {

        /**
         * Adds rule to the shortcuts lookup table
         *
         * @param {UrlFilterRule} rule Rule to add to the table
         * @return {Boolean} true if the rule shortcut is applicable and the rule was added
         */
        addRule: function (rule) {
            if (isAnyUrlShortcut(rule)) {
                return false;
            }

            let shortcuts = getRuleShortcuts(rule);
            if (!shortcuts) {
                return false;
            }

            // Find the applicable shortcut (the least used)
            let shortcutHash;
            let minCount = Number.MAX_SAFE_INTEGER;
            for (let shortcutToCheck of shortcuts) {
                let hash = djb2Hash(shortcutToCheck);
                let count = this.histogram.get(hash) || 0;
                if (count < minCount) {
                    minCount = count;
                    shortcutHash = hash;
                }
            }

            // Increment the histogram
            const count = this.histogram.get(shortcutHash) || 0;
            this.histogram.set(shortcutHash, count + 1);

            if (!this.lookupTable.has(shortcutHash)) {
                // Array is too "memory-hungry" so we try to store one rule instead
                this.lookupTable.set(shortcutHash, rule);
            } else {
                const obj = this.lookupTable.get(shortcutHash);
                if (adguard.utils.collections.isArray(obj)) {
                    // That is popular shortcut, more than one rule
                    obj.push(rule);
                } else {
                    this.lookupTable.set(shortcutHash, [obj, rule]);
                }
            }

            return true;
        },

        /**
         * Removes specified rule from the lookup table
         *
         * @param rule Rule to remove
         */
        removeRule: function (rule) {
            let shortcuts = getRuleShortcuts(rule);
            if (!shortcuts) {
                return false;
            }

            for (let shortcut of shortcuts) {
                const shortcutHash = djb2Hash(shortcut);

                if (this.lookupTable.has(shortcutHash)) {
                    const obj = this.lookupTable.get(shortcutHash);
                    if (adguard.utils.collections.isArray(obj)) {
                        adguard.utils.collections.removeRule(obj, rule);
                        if (obj.length === 0) {
                            this.lookupTable.delete(shortcutHash);
                        }
                    } else if (obj.ruleText === rule.ruleText) {
                        this.lookupTable.delete(shortcutHash);
                    }
                }
            }
        },

        /**
         * Clears lookup table
         */
        clearRules: function () {
            this.lookupTable.clear();
            this.histogram.clear();
        },

        /**
         * Searches for filter rules restricted to the specified url
         *
         * @param url url
         * @return List of filter rules or null if nothing found
         */
        lookupRules: function (url) {
            let result = null;

            for (let i = 0; i <= url.length - SHORTCUT_LENGTH; i++) {
                const hash = djb2HashBetween(url, i, i + SHORTCUT_LENGTH);
                const value = this.lookupTable.get(hash);

                if (value) {
                    if (adguard.utils.collections.isArray(value)) {
                        if (result === null) {
                            result = [];
                        }
                        for (let rule of value) {
                            if (url.indexOf(rule.shortcut) !== -1) {
                                result.push(rule);
                            }
                        }
                    } else {
                        if (result === null) {
                            result = [];
                        }
                        if (url.indexOf(value.shortcut) !== -1) {
                            result.push(value);
                        }
                    }
                }
            }

            return result;
        },

        /**
         * @returns {Array} rules in lookup table
         */
        getRules: function () {
            const result = [];
            this.lookupTable.forEach((value) => {
                if (value) {
                    if (adguard.utils.collections.isArray(value)) {
                        result = result.concat(value);
                    } else {
                        result.push(value);
                    }
                }
            });
            return result;
        }
    };

    api.ShortcutsLookupTable = ShortcutsLookupTable;

})(adguard, adguard.rules);
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (adguard, api) {

    'use strict';

    /**
     * Special lookup table, which improves basic rules search speed by domain.
     */
    var DomainsLookupTable = function (rules) {

        this.lookupTable = Object.create(null);

        if (rules) {
            for (var i = 0; i < rules.length; i++) {
                this.addRule(rules[i]);
            }
        }
    };

    DomainsLookupTable.prototype = {

        /**
         * Adds specified rule to the lookup table (if it is possible).
         * If rule has no domain restriction, this method returns false.
         *
         * @param rule Url filter rule
         * @return boolean true if rule was added. Otherwise - false.
         */
        addRule: function (rule) {
            if (!rule.hasPermittedDomains()) {
                // No permitted domains, we can't do anything
                return false;
            }

            var permittedDomains = rule.getPermittedDomains();
            for (var i = 0; i < permittedDomains.length; i++) {
                var domainName = permittedDomains[i];
                var rules = this.lookupTable[domainName];
                if (!rules) {
                    rules = [];
                    this.lookupTable[domainName] = rules;
                }

                rules.push(rule);
            }

            return true;
        },

        /**
         * Removes specified rule from the lookup table
         *
         * @param rule Rule to remove
         */
        removeRule: function (rule) {

            if (!rule.hasPermittedDomains()) {
                // No permitted domains, we can't do anything
                return;
            }

            var permittedDomains = rule.getPermittedDomains();
            for (var i = 0; i < permittedDomains.length; i++) {
                var domainName = permittedDomains[i];
                var rules = this.lookupTable[domainName];
                if (rules) {
                    adguard.utils.collections.removeRule(rules, rule);
                    if (rules.length === 0) {
                        delete this.lookupTable[domainName];
                    }
                }
            }
        },

        /**
         * Clears lookup table
         */
        clearRules: function () {
            this.lookupTable = Object.create(null);
        },

        /**
         * Searches for filter rules restricted to the specified domain
         *
         * @param domainName Domain name
         * @return List of filter rules or null if nothing found
         */
        lookupRules: function (domainName) {
            if (!domainName) {
                return null;
            }

            let parts = domainName.split('.');
            if (parts.length === 0) {
                return null;
            }

            // Resulting list of rules
            let result = null;

            // Iterate over all sub-domains
            let host = parts[parts.length - 1];
            for (let i = parts.length - 2; i >= 0; i--) {
                host = parts[i] + "." + host;
                let rules = this.lookupTable[host];
                if (rules && rules.length > 0) {
                    if (result === null) {
                        // Lazy initialization of the resulting list
                        result = [];
                    }
                    result = result.concat(rules);
                }
            }

            return result;
        },

        /**
         * @returns {Array} rules in lookup table
         */
        getRules: function () {
            var result = [];
            for (var r in this.lookupTable) { // jshint ignore:line
                var value = this.lookupTable[r];
                if (value) {
                    if (adguard.utils.collections.isArray(value)) {
                        result = result.concat(value);
                    } else {
                        result.push(value);
                    }
                }
            }

            return adguard.utils.collections.removeDuplicates(result);
        }
    };

    api.DomainsLookupTable = DomainsLookupTable;

})(adguard, adguard.rules);


/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (adguard, api) {
    'use strict';

    /**
     * Checks if rule filters request
     *
     * @param rule                Rule
     * @param url                 Request url
     * @param referrerHost        Referrer host
     * @param thirdParty          Is request third-party or not
     * @param requestType         Request type
     * @param genericRulesAllowed If true - generic rules are allowed
     * @param badFilterRules      Link to the badFilterRules
     * @return {Boolean}          If rule should filter this request
     */
    function isFiltered(rule, url, referrerHost, thirdParty, requestType, genericRulesAllowed, badFilterRules) {
        if (badFilterRules) {
            // if rule was converted we should lookup for converted rule text in the badFilterRules table
            if (rule.convertedRuleText && badFilterRules[rule.convertedRuleText]) {
                return false;
            }
            if (badFilterRules[rule.ruleText]) {
                return false;
            }
        }

        if (!genericRulesAllowed && rule.isGeneric()) {
            return false;
        }

        if (!rule.hasPermittedDomains()) {
            return rule.isFiltered(url, thirdParty, requestType)
                && rule.isPermitted(referrerHost);
        }

        if (requestType !== adguard.RequestTypes.DOCUMENT
            && requestType !== adguard.RequestTypes.SUBDOCUMENT) {
            return rule.isFiltered(url, thirdParty, requestType)
                && rule.isPermitted(referrerHost);
        }

        let isPermitted = rule.isPermitted(referrerHost);
        if (rule.isAnyUrl()) {
            // if rules dont have domain patterns and have $domain modifier
            // we should check rules with request urls hosts
            isPermitted = rule.isPermitted(adguard.utils.url.getHost(url));
            thirdParty = false;
        } else {
            // for DOCUMENT and SUBDOCUMENT requests
            // rules with request urls hosts are permitted as well
            isPermitted = isPermitted || rule.isPermitted(adguard.utils.url.getHost(url));
        }

        return rule.isFiltered(url, thirdParty, requestType) && isPermitted;
    }

    /**
     * Returns rules priority considering the following chain
     * (whitelist + $important) > $important > whitelist > $redirect > basic rules
     * @param rule
     * @returns {number}
     */
    const getPriority = (rule) => {
        if (rule.isImportant && rule.whiteListRule) {
            return 4;
        }
        if (rule.isImportant) {
            return 3;
        }
        if (rule.whiteListRule) {
            return 2;
        }
        if (rule.isRedirectRule()) {
            return 1;
        }
        return 0;
    };

    /**
     * Compare rules by priorities
     * if ruleA has higher or equal priority returns ruleA else returns ruleB
     * view getPriority function
     * @param ruleA
     * @param ruleB
     * @returns {object} rule with higher priority
     */
    function isHigherPriority(ruleA, ruleB) {
        const priorityA = getPriority(ruleA);
        const priorityB = getPriority(ruleB);
        return priorityA >= priorityB ? ruleA : ruleB;
    }

    /**
     * Checks url against collection of rules
     *
     * @param rules               Rules to check
     * @param url                 Request url
     * @param referrerHost        Request referrer host
     * @param thirdParty          Is request third-party or not
     * @param requestType         Request type
     * @param genericRulesAllowed If true - generic rules are allowed
     * @param badFilterRules      Link to the bad rules
     * @return Collection of matching rules
     */
    function filterRules(rules, url, referrerHost, thirdParty, requestType, genericRulesAllowed, badFilterRules) {
        let result = null;

        if (requestType === adguard.RequestTypes.DOCUMENT) {
            // Looking for document level rules
            for (let i = 0; i < rules.length; i += 1) {
                const rule = rules[i];
                if (rule.isDocumentLevel()
                    && isFiltered(
                        rule,
                        url,
                        referrerHost,
                        thirdParty,
                        requestType,
                        genericRulesAllowed,
                        badFilterRules
                    )) {
                    if (!result) {
                        result = [];
                    }
                    result.push(rule);
                }
            }
        }

        for (let i = 0; i < rules.length; i += 1) {
            const rule = rules[i];
            if (isFiltered(
                rule,
                url,
                referrerHost,
                thirdParty,
                requestType,
                genericRulesAllowed,
                badFilterRules
            )) {
                if (!result) {
                    result = [];
                }
                result.push(rule);
            }
        }

        return result;
    }

    /**
     * Iterates through matching rules and returns the first one with higher priority
     * @param rules Rules to check
     * @param url URL
     * @param referrerHost Referrer Host
     * @param thirdParty Is third-party request?
     * @param requestType Request type
     * @param genericRulesAllowed If true - generic rules are allowed
     * @param badFilterRules Link to the badFilterRules
     */
    function findFirstRule(rules, url, referrerHost, thirdParty, requestType, genericRulesAllowed, badFilterRules) {
        const matchingRules = filterRules(
            rules,
            url,
            referrerHost,
            thirdParty,
            requestType,
            genericRulesAllowed,
            badFilterRules
        );

        if (!matchingRules) {
            return null;
        }

        return matchingRules.reduce(isHigherPriority);
    }

    /**
     * Find all matching rules
     * @param rules Rules to check
     * @param url URL
     * @param referrerHost Referrer Host
     * @param thirdParty Is third-party request?
     * @param requestType Request type
     * @param genericRulesAllowed If true - generic rules are allowed
     * @param badFilterRules Link to the badFilterRules
     */
    function findAllRules(rules, url, referrerHost, thirdParty, requestType, genericRulesAllowed, badFilterRules) {
        return filterRules(rules, url, referrerHost, thirdParty, requestType, genericRulesAllowed, badFilterRules);
    }

    /**
     * Special lookup table
     */
    const UrlFilterRuleLookupTable = function () {
        this.shortcutsLookupTable = new api.ShortcutsLookupTable();
        this.domainsLookupTable = new api.DomainsLookupTable();
        this.rulesWithoutShortcuts = [];
    };

    UrlFilterRuleLookupTable.prototype = {
        /**
         * Adds rule to the table
         *
         * @param rule Rule to add
         */
        addRule(rule) {
            if (!this.shortcutsLookupTable.addRule(rule)) {
                if (!this.domainsLookupTable.addRule(rule)) {
                    this.rulesWithoutShortcuts.push(rule);
                }
            }
        },

        /**
         * Removes rule from the table
         *
         * @param rule Rule to remove
         */
        removeRule(rule) {
            this.shortcutsLookupTable.removeRule(rule);
            this.domainsLookupTable.removeRule(rule);
            adguard.utils.collections.removeRule(this.rulesWithoutShortcuts, rule);
        },

        /**
         * Clears rules
         */
        clearRules() {
            this.shortcutsLookupTable.clearRules();
            this.domainsLookupTable.clearRules();
            this.rulesWithoutShortcuts = [];
        },

        getRules() {
            let rules = [];

            rules = rules.concat(this.rulesWithoutShortcuts);
            rules = rules.concat(this.shortcutsLookupTable.getRules());
            rules = rules.concat(this.domainsLookupTable.getRules());

            return rules;
        },

        /**
         * Concat arrays with necessary checks
         *
         * @param rules
         * @param toAdd
         * @return {*|WordArray|Array|Buffer|any[]|string}
         */
        concatRules(rules, toAdd) {
            if (toAdd && toAdd.length > 0) {
                return rules.concat(toAdd);
            }

            return rules;
        },

        /**
         * Returns filtering rule if request is filtered or NULL if nothing found
         *
         * @param url                 Url to check
         * @param documentHost        Request document host
         * @param thirdParty          Is request third-party or not
         * @param requestType         Request type
         * @param genericRulesAllowed If true - generic rules are allowed
         * @param badFilterRules      Link to the bad filters
         * @return {object} First matching rule or null if no match found
         */
        findRule(url, documentHost, thirdParty, requestType, genericRulesAllowed, badFilterRules) {
            if (!url) {
                return null;
            }

            const urlLowerCase = url.toLowerCase();
            let matchedRules = [];

            // Check against rules with shortcuts
            let rules = this.shortcutsLookupTable.lookupRules(urlLowerCase);
            matchedRules = this.concatRules(matchedRules, rules);

            let hostToCheck = documentHost;
            // if document host is null, get host from url
            // thus we can find rules and check them using domain restriction later
            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1474
            if (hostToCheck === null) {
                hostToCheck = adguard.utils.url.getHost(url);
            } else if (requestType === adguard.RequestTypes.DOCUMENT) {
                // In case DOCUMENT request type look up rules for request url host
                // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1534
                rules = this.domainsLookupTable.lookupRules(adguard.utils.url.getHost(url));
                matchedRules = this.concatRules(matchedRules, rules);
            }

            // Check against rules with domains
            rules = this.domainsLookupTable.lookupRules(hostToCheck);
            matchedRules = this.concatRules(matchedRules, rules);

            // Check against rules without shortcuts
            matchedRules = this.concatRules(matchedRules, this.rulesWithoutShortcuts);

            if (matchedRules.length > 0) {
                const rule = findFirstRule(
                    matchedRules,
                    url,
                    documentHost,
                    thirdParty,
                    requestType,
                    genericRulesAllowed,
                    badFilterRules
                );
                if (rule) {
                    return rule;
                }
            }

            return null;
        },

        /**
         * Returns filtering rules that match the passed parameters
         *
         * @param url                 Url to check
         * @param documentHost        Request document host
         * @param thirdParty          Is request third-party or not
         * @param requestType         Request type
         * @param badFilterRules      object with collection of bad filters
         * @return All matching rules or null if no match found
         */
        findRules(url, documentHost, thirdParty, requestType, badFilterRules) {
            if (!url) {
                return null;
            }

            let allRules = [];

            const urlLowerCase = url.toLowerCase();
            let rules = this.shortcutsLookupTable.lookupRules(urlLowerCase);
            if (rules) {
                allRules = allRules.concat(rules);
            }

            // if document host is null, get host from url
            // thus we can find rules and check this rules using domain restriction later
            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1474
            if (documentHost === null) {
                const urlHost = adguard.utils.url.getHost(url);
                rules = this.domainsLookupTable.lookupRules(urlHost);
                if (rules && rules.length > 0) {
                    allRules = allRules.concat(rules);
                }
            }

            rules = this.domainsLookupTable.lookupRules(documentHost);
            if (rules) {
                allRules = allRules.concat(rules);
            }

            allRules = allRules.concat(this.rulesWithoutShortcuts);

            if (allRules && allRules.length > 0) {
                return findAllRules(allRules, url, documentHost, thirdParty, requestType, true, badFilterRules);
            }

            return null;
        },
    };

    api.UrlFilterRuleLookupTable = UrlFilterRuleLookupTable;
})(adguard, adguard.rules);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */
(function (api) {

    'use strict';

    /**
     * Helper class for creating regular expression from a simple wildcard-syntax used in basic filters
     */
    var SimpleRegex = (function () {

        // Constants
        var regexConfiguration = {
            maskStartUrl: "||",
            maskPipe: "|",
            maskSeparator: "^",
            maskAnySymbol: "*",

            regexAnySymbol: ".*",
            regexSeparator: "([^ a-zA-Z0-9.%_-]|$)",
            regexStartUrl: "^(http|https|ws|wss)://([a-z0-9-_.]+\\.)?",
            regexStartString: "^",
            regexEndString: "$"
        };

        // https://developer.mozilla.org/en/JavaScript/Reference/Global_Objects/regexp
        // should be escaped . * + ? ^ $ { } ( ) | [ ] / \
        // except of * | ^
        var specials = [
            '.', '+', '?', '$', '{', '}', '(', ')', '[', ']', '\\', '/'
        ];
        var specialsRegex = new RegExp('[' + specials.join('\\') + ']', 'g');

        /**
         * Escapes regular expression string
         */
        var escapeRegExp = function (str) {
            return str.replace(specialsRegex, "\\$&");
        };

        /**
         * Checks if string "str" starts with the specified "prefix"
         */
        var startsWith = function (str, prefix) {
            return str && str.indexOf(prefix) === 0;
        };

        /**
         * Checks if string "str" ends with the specified "postfix"
         */
        var endsWith = function (str, postfix) {
            if (!str || !postfix) {
                return false;
            }

            if (str.endsWith) {
                return str.endsWith(postfix);
            }
            var t = String(postfix);
            var index = str.lastIndexOf(t);
            return index >= 0 && index === str.length - t.length;
        };

        /**
         * Replaces all occurencies of a string "find" with "replace" str;
         */
        var replaceAll = function (str, find, replace) {
            if (!str) {
                return str;
            }
            return str.split(find).join(replace);
        };


        /**
         * Creates regex
         */
        var createRegexText = function (str) {
            if (str === regexConfiguration.maskStartUrl ||
                str === regexConfiguration.maskPipe ||
                str === regexConfiguration.maskAnySymbol) {
                return regexConfiguration.regexAnySymbol;
            }

            var regex = escapeRegExp(str);

            if (startsWith(regex, regexConfiguration.maskStartUrl)) {
                regex = regex.substring(0, regexConfiguration.maskStartUrl.length) +
                    replaceAll(regex.substring(regexConfiguration.maskStartUrl.length, regex.length - 1), "\|", "\\|") +
                    regex.substring(regex.length - 1);
            } else if (startsWith(regex, regexConfiguration.maskPipe)) {
                regex = regex.substring(0, regexConfiguration.maskPipe.length) +
                    replaceAll(regex.substring(regexConfiguration.maskPipe.length, regex.length - 1), "\|", "\\|") +
                    regex.substring(regex.length - 1);
            } else {
                regex = replaceAll(regex.substring(0, regex.length - 1), "\|", "\\|") +
                    regex.substring(regex.length - 1);
            }

            // Replacing special url masks
            regex = replaceAll(regex, regexConfiguration.maskAnySymbol, regexConfiguration.regexAnySymbol);
            regex = replaceAll(regex, regexConfiguration.maskSeparator, regexConfiguration.regexSeparator);

            if (startsWith(regex, regexConfiguration.maskStartUrl)) {
                regex = regexConfiguration.regexStartUrl + regex.substring(regexConfiguration.maskStartUrl.length);
            } else if (startsWith(regex, regexConfiguration.maskPipe)) {
                regex = regexConfiguration.regexStartString + regex.substring(regexConfiguration.maskPipe.length);
            }
            if (endsWith(regex, regexConfiguration.maskPipe)) {
                regex = regex.substring(0, regex.length - 1) + regexConfiguration.regexEndString;
            }

            return regex;
        };

        // EXPOSE
        return {
            // Function for creating regex
            createRegexText: createRegexText,

            // Configuration used for the transformation
            regexConfiguration: regexConfiguration,
            escapeRegExp: escapeRegExp,
        };
    })();

    api.SimpleRegex = SimpleRegex;

})(adguard.rules);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (adguard, api) {
    'use strict';

    /**
     * Base class for all filter rules
     */
    const FilterRule = function (text, filterId) {
        this.ruleText = text;
        this.filterId = filterId;
    };

    FilterRule.prototype = {

        /**
         * Loads $domain option.
         * http://adguard.com/en/filterrules.html#hideRulesDomainRestrictions
         * http://adguard.com/en/filterrules.html#advanced
         *
         * @param domains List of domains. Examples: "example.com|test.com" or "example.com,test.com"
         */
        loadDomains(domains) {
            if (adguard.utils.strings.isEmpty(domains)) {
                return;
            }

            let permittedDomains = null;
            let restrictedDomains = null;

            const parts = domains.split(/[,|]/);

            for (let i = 0; i < parts.length; i += 1) {
                const domain = parts[i];
                let domainName;
                if (domain.trim().length === 0) {
                    // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1242
                    throw `Error load $domain options from "${domains}", because after split one of them is empty`;
                }
                if (adguard.utils.strings.startWith(domain, '~')) {
                    domainName = adguard.utils.url.toPunyCode(domain.substring(1).trim());
                    if (!adguard.utils.strings.isEmpty(domainName)) {
                        if (restrictedDomains === null) {
                            restrictedDomains = [];
                        }
                        restrictedDomains.push(domainName);
                    }
                } else {
                    domainName = adguard.utils.url.toPunyCode(domain.trim());
                    if (!adguard.utils.strings.isEmpty(domainName)) {
                        if (permittedDomains === null) {
                            permittedDomains = [];
                        }
                        permittedDomains.push(domainName);
                    }
                }
            }

            this.setPermittedDomains(permittedDomains);
            this.setRestrictedDomains(restrictedDomains);
        },

        getPermittedDomains() {
            if (this.permittedDomain) {
                return [this.permittedDomain];
            }
            return this.permittedDomains;
        },

        getRestrictedDomains() {
            if (this.restrictedDomain) {
                return [this.restrictedDomain];
            }
            return this.restrictedDomains;
        },

        setPermittedDomains(permittedDomains) {
            if (!permittedDomains || permittedDomains.length === 0) {
                delete this.permittedDomain;
                delete this.permittedDomains;
                return;
            }
            if (permittedDomains.length > 1) {
                this.permittedDomains = permittedDomains;
                delete this.permittedDomain;
            } else {
                this.permittedDomain = permittedDomains[0];
                delete this.permittedDomains;
            }
        },

        setRestrictedDomains(restrictedDomains) {
            if (!restrictedDomains || restrictedDomains.length === 0) {
                delete this.restrictedDomain;
                delete this.restrictedDomains;
                return;
            }
            if (restrictedDomains.length > 1) {
                this.restrictedDomains = restrictedDomains;
                delete this.restrictedDomain;
            } else {
                this.restrictedDomain = restrictedDomains[0];
                delete this.restrictedDomains;
            }
        },

        /**
         * Checks if rule is domain-sensitive
         * @returns boolean true if $domain option is present. Otherwise false.
         */
        isDomainSensitive() {
            return this.hasRestrictedDomains() || this.hasPermittedDomains();
        },

        /**
         * Checks whether this rule is generic or domain specific
         * @returns boolean true if rule is generic, otherwise false
         */
        isGeneric() {
            return (!this.hasPermittedDomains());
        },

        /**
         * @returns boolean true if rule has permitted domains
         */
        hasPermittedDomains() {
            return (this.permittedDomain || (this.permittedDomains && this.permittedDomains.length > 0));
        },

        /**
         * @returns boolean true if rule has restricted domains
         */
        hasRestrictedDomains() {
            return (this.restrictedDomain
                || (this.restrictedDomains && this.restrictedDomains.length > 0));
        },

        isRestricted(domainName) {
            if (!domainName) { return false; }
            const restrictedDomains = this.getRestrictedDomains();
            if (restrictedDomains) {
                return adguard.utils.url.isDomainOrSubDomainOfAny(
                    domainName,
                    restrictedDomains
                );
            }
            return false;
        },

        /**
         * Checks if rule could be applied to the specified domain name
         *
         * @param domainName Domain name
         * @returns boolean true if rule is permitted
         */
        isPermitted(domainName) {
            if (!domainName) { return false; }

            if (this.isRestricted(domainName)) {
                return false;
            }

            const permittedDomains = this.getPermittedDomains();
            if (permittedDomains) {
                return adguard.utils.url.isDomainOrSubDomainOfAny(
                    domainName,
                    permittedDomains
                );
            }

            return true;
        },

        /**
         * Checks if rule is domain specific for provided domain
         * @param {string} domainName
         * @return {boolean}
         */
        isDomainSpecific(domainName) {
            if (!domainName) {
                return false;
            }
            const permitted = this.getPermittedDomains() || [];
            const restricted = this.getRestrictedDomains() || [];

            return adguard.utils.url.isDomainOrSubDomainOfAny(
                domainName,
                [...permitted, ...restricted]
            );
        },

        /**
         * Adds restricted domains
         *
         * @param domains List of domains
         */
        addRestrictedDomains(domains) {
            if (!domains || !domains.length) {
                return;
            }
            let restrictedDomains = this.getRestrictedDomains();
            restrictedDomains = adguard.utils.collections.removeDuplicates((restrictedDomains || []).concat(domains));
            this.setRestrictedDomains(restrictedDomains);
        },

        /**
         * Removes restricted domains
         *
         * @param domains List of domains
         */
        removeRestrictedDomains(domains) {
            if (domains) {
                const restrictedDomains = this.getRestrictedDomains();
                for (let i = 0; i < domains.length; i++) {
                    adguard.utils.collections.remove(restrictedDomains, domains[i]);
                }
                this.setRestrictedDomains(restrictedDomains);
            }
        },
    };

    var stringUtils = adguard.utils.strings;

    /**
     * Finds CSS rule marker in the rule text
     *
     * @param ruleText        rule text to check
     * @param markers         a list of markers to check (IMPORTANT: sorted by length desc)
     * @param firstMarkerChar first character of the marker we're looking for
     * @return rule marker found
     */
    FilterRule.findRuleMarker = function (ruleText, markers, firstMarkerChar) {
        const startIndex = ruleText.indexOf(firstMarkerChar);
        if (startIndex === -1) {
            return null;
        }

        for (let i = 0; i < markers.length; i += 1) {
            const marker = markers[i];
            if (stringUtils.startsAtIndexWith(ruleText, startIndex, marker)) {
                return marker;
            }
        }

        return null;
    };

    /**
     * urlencodes rule text.
     * We need this function because of this issue:
     * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/34
     * and
     * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1079
     */
    FilterRule.escapeRule = function (ruleText) {
        return encodeURIComponent(ruleText)
            .replace(/['()]/g, match => ({ "'": '%27', '(': '%28', ')': '%29' }[match]));
    };

    FilterRule.PARAMETER_START = '[';
    FilterRule.PARAMETER_END = ']';
    FilterRule.MASK_WHITE_LIST = '@@';
    FilterRule.MASK_CSS_RULE = '##';
    FilterRule.MASK_CSS_EXCEPTION_RULE = '#@#';
    FilterRule.MASK_CSS_INJECT_RULE = '#$#';
    FilterRule.MASK_CSS_EXCEPTION_INJECT_RULE = '#@$#';
    FilterRule.MASK_CSS_EXTENDED_CSS_RULE = '#?#';
    FilterRule.MASK_CSS_EXCEPTION_EXTENDED_CSS_RULE = '#@?#';
    FilterRule.MASK_CSS_INJECT_EXTENDED_CSS_RULE = '#$?#';
    FilterRule.MASK_CSS_EXCEPTION_INJECT_EXTENDED_CSS_RULE = '#@$?#';
    FilterRule.MASK_SCRIPT_RULE = '#%#';
    FilterRule.MASK_SCRIPT_EXCEPTION_RULE = '#@%#';
    FilterRule.MASK_CONTENT_RULE = '$$';
    FilterRule.MASK_CONTENT_EXCEPTION_RULE = '$@$';
    FilterRule.MASK_BANNER_RULE = '++';
    FilterRule.MASK_CONFIGURATION_RULE = '~~';
    FilterRule.COMMENT = '!';
    FilterRule.EQUAL = '=';
    FilterRule.COMA_DELIMITER = ',';
    FilterRule.LINE_DELIMITER = '|';
    FilterRule.NOT_MARK = '~';

    api.FilterRule = FilterRule;
})(adguard, adguard.rules);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (adguard, api) {

    'use strict';

    /**
     * CSS rule.
     *
     * Read here for details:
     * http://adguard.com/en/filterrules.html#hideRules
     * http://adguard.com/en/filterrules.html#cssInjection
     */
    var CssFilterRule = (function () {
        /**
         * Parses first pseudo class from the specified CSS selector
         *
         * @param selector
         * @returns {*} first PseudoClass found or null
         */
        var parsePseudoClass = function (selector) {
            var beginIndex = 0;
            var nameStartIndex = -1;
            var squareBracketIndex = 0;

            while (squareBracketIndex >= 0) {
                nameStartIndex = selector.indexOf(':', beginIndex);
                if (nameStartIndex < 0) {
                    return null;
                }

                if (nameStartIndex > 0 && selector.charAt(nameStartIndex - 1) === '\\') {
                    // Escaped colon character
                    return null;
                }

                squareBracketIndex = selector.indexOf("[", beginIndex);
                while (squareBracketIndex >= 0) {
                    if (nameStartIndex > squareBracketIndex) {
                        var squareEndBracketIndex = selector.indexOf("]", squareBracketIndex + 1);
                        beginIndex = squareEndBracketIndex + 1;
                        if (nameStartIndex < squareEndBracketIndex) {
                            // Means that colon character is somewhere inside attribute selector
                            // Something like a[src^="http://domain.com"]
                            break;
                        }

                        if (squareEndBracketIndex > 0) {
                            squareBracketIndex = selector.indexOf("[", beginIndex);
                        } else {
                            // bad rule, example: a[src="http:
                            return null;
                        }
                    } else {
                        squareBracketIndex = -1;
                        break;
                    }
                }
            }

            var nameEndIndex = adguard.utils.strings.indexOfAny(selector, [' ', '\t', '>', '(', '[', '.', '#', ':', '+', '~', '"', "'"], nameStartIndex + 1);
            if (nameEndIndex < 0) {
                nameEndIndex = selector.length;
            }

            var name = selector.substring(nameStartIndex, nameEndIndex);
            if (name.length <= 1) {
                // Either empty name or a pseudo element (like ::content)
                return null;
            }

            return {
                name: name,
                nameStartIndex: nameStartIndex,
                nameEndIndex: nameEndIndex
            };
        };

        /**
         * CssFilterRule constructor
         */
        var constructor = function (rule, filterId) {

            api.FilterRule.call(this, rule, filterId);

            var mask = api.FilterRule.findRuleMarker(rule, CssFilterRule.RULE_MARKERS, CssFilterRule.RULE_MARKER_FIRST_CHAR);
            if (!mask) {
                throw new Error("ruleText does not contain a CSS rule marker: " + rule);
            }

            var isElemhideRule = CssFilterRule.ELEMHIDE_MARKERS.indexOf(mask) !== -1;
            var isInjectRule = CssFilterRule.INJECT_MARKERS.indexOf(mask) !== -1;
            this.whiteListRule = CssFilterRule.WHITELIST_MARKERS.indexOf(mask) !== -1;
            var isExtendedCss = CssFilterRule.EXTCSS_MARKERS.indexOf(mask) !== -1;

            var indexOfMask = rule.indexOf(mask);
            if (indexOfMask > 0) {
                // domains are specified, parsing
                var domains = rule.substring(0, indexOfMask);
                this.loadDomains(domains);
            }

            var stringUtils = adguard.utils.strings;
            var cssContent = rule.substring(indexOfMask + mask.length);

            if (isElemhideRule) {
                // prevent using elemhide rules (##) as css (#$#)
                // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1624
                if (/{.+}/.test(cssContent)
                    || stringUtils.hasUnquotedSubstring(cssContent, '{')
                    || stringUtils.hasUnquotedSubstring(cssContent, '/*')
                    || stringUtils.hasUnquotedSubstring(cssContent, ' //')) {
                    throw new SyntaxError(`Invalid elemhide rule: ${this.ruleText}`);
                }
            }

            if (!isInjectRule) {
                // We need to validate pseudo-classes
                // https://github.com/AdguardTeam/AdguardForAndroid/issues/701
                const pseudoClass = parsePseudoClass(cssContent);
                if (pseudoClass !== null) {
                    if (CssFilterRule.SUPPORTED_PSEUDO_CLASSES.indexOf(pseudoClass.name) < 0) {
                        throw new Error(`Unknown pseudo class: ${cssContent}`);
                    }
                }
            }

            if (isInjectRule) {
                // Simple validation for css injection rules
                if (!/{.+}/.test(cssContent)) {
                    throw new Error(`Invalid css injection rule, no style presented: ${rule}`);
                }
                // discard css inject rules containing "url"
                // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1196
                if (/url\(.*\)/gi.test(cssContent)) {
                    throw new Error(`Css injection rule with 'url' was omitted: ${rule}`);
                }

                // Prohibit "\" character in CSS injection rules
                // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1444
                if ((cssContent.indexOf('\\') > -1) && !isExtendedCss) {
                    throw new Error(`Css injection rule with '\\' was omitted: ${rule}`);
                }
            }

            // Extended CSS selectors support
            // https://github.com/AdguardTeam/ExtendedCss
            for (var i = 0; i < CssFilterRule.EXTENDED_CSS_MARKERS.length; i++) {
                if (cssContent.indexOf(CssFilterRule.EXTENDED_CSS_MARKERS[i]) >= 0) {
                    isExtendedCss = true;
                }
            }

            this.isElemhideRule = isElemhideRule;
            this.isInjectRule = isInjectRule;
            this.extendedCss = isExtendedCss;
            this.cssSelector = cssContent;
        };

        return constructor;
    })();

    CssFilterRule.prototype = Object.create(api.FilterRule.prototype);

    /**
     * The problem with pseudo-classes is that any unknown pseudo-class makes browser ignore the whole CSS rule,
     * which contains a lot more selectors. So, if CSS selector contains a pseudo-class, we should try to validate it.
     * <p>
     * One more problem with pseudo-classes is that they are actively used in uBlock, hence it may mess AG styles.
     */
    CssFilterRule.SUPPORTED_PSEUDO_CLASSES = [":active",
        ":checked", ":contains", ":disabled", ":empty", ":enabled", ":first-child", ":first-of-type",
        ":focus", ":has", ":has-text", ":hover", ":if", ":if-not", ":in-range", ":invalid", ":lang",
        ":last-child", ":last-of-type", ":link", ":matches-css", ":matches-css-before", ":matches-css-after",
        ":not", ":nth-child", ":nth-last-child", ":nth-last-of-type", ":nth-of-type",
        ":only-child", ":only-of-type", ":optional", ":out-of-range", ":properties", ":read-only",
        ":read-write", ":required", ":root", ":target", ":valid", ":visited",
        ":-abp-has", ":-abp-contains", ":-abp-properties", ":xpath", ":nth-ancestor", ":upward", ":remove"];

    /**
     * The problem with it is that ":has" and ":contains" pseudo classes are not a valid pseudo classes,
     * hence using it may break old versions of AG.
     */
    CssFilterRule.EXTENDED_CSS_MARKERS = ["[-ext-has=", "[-ext-contains=", "[-ext-has-text=", "[-ext-matches-css=",
        "[-ext-matches-css-before=", "[-ext-matches-css-after=", ":has(", ":has-text(", ":contains(",
        ":matches-css(", ":matches-css-before(", ":matches-css-after(", ":-abp-has(", ":-abp-contains(",
        ":if(", ":if-not(", ":properties(", ":-abp-properties(", ":xpath(", ":nth-ancestor(", ":upward(", ":remove("];

    /**
     * All CSS rules markers start with this character
     */
    CssFilterRule.RULE_MARKER_FIRST_CHAR = '#';

    /**
     * CSS rule markers
     */
    CssFilterRule.RULE_MARKERS = [
        api.FilterRule.MASK_CSS_EXCEPTION_INJECT_EXTENDED_CSS_RULE,
        api.FilterRule.MASK_CSS_INJECT_EXTENDED_CSS_RULE,
        api.FilterRule.MASK_CSS_EXCEPTION_INJECT_RULE,
        api.FilterRule.MASK_CSS_INJECT_RULE,
        api.FilterRule.MASK_CSS_EXCEPTION_EXTENDED_CSS_RULE,
        api.FilterRule.MASK_CSS_EXTENDED_CSS_RULE,
        api.FilterRule.MASK_CSS_EXCEPTION_RULE,
        api.FilterRule.MASK_CSS_RULE,
    ];

    /**
     * Masks indicating whitelist exception rules
     */
    CssFilterRule.WHITELIST_MARKERS = [
        api.FilterRule.MASK_CSS_EXCEPTION_RULE, api.FilterRule.MASK_CSS_EXCEPTION_INJECT_RULE,
        api.FilterRule.MASK_CSS_EXCEPTION_EXTENDED_CSS_RULE, api.FilterRule.MASK_CSS_EXCEPTION_INJECT_EXTENDED_CSS_RULE];

    /**
     * Masks indicating extended css rules
     */
    CssFilterRule.EXTCSS_MARKERS = [
        api.FilterRule.MASK_CSS_EXCEPTION_INJECT_EXTENDED_CSS_RULE, api.FilterRule.MASK_CSS_INJECT_EXTENDED_CSS_RULE,
        api.FilterRule.MASK_CSS_EXCEPTION_EXTENDED_CSS_RULE, api.FilterRule.MASK_CSS_EXTENDED_CSS_RULE];

    /**
     * Masks indicating inject css rules
     */
    CssFilterRule.INJECT_MARKERS = [
        api.FilterRule.MASK_CSS_EXCEPTION_INJECT_EXTENDED_CSS_RULE, api.FilterRule.MASK_CSS_INJECT_EXTENDED_CSS_RULE,
        api.FilterRule.MASK_CSS_EXCEPTION_INJECT_RULE, api.FilterRule.MASK_CSS_INJECT_RULE];

    /**
     * Masks indicating elemhide rules
     */
    CssFilterRule.ELEMHIDE_MARKERS = [
        api.FilterRule.MASK_CSS_RULE, api.FilterRule.MASK_CSS_EXCEPTION_RULE];
        
    api.CssFilterRule = CssFilterRule;

})(adguard, adguard.rules);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (adguard, api) {

    'use strict';

    /**
     * This class manages CSS rules and builds styles to inject to pages.
     * ABP element hiding rules: http://adguard.com/en/filterrules.html#hideRules
     * CSS injection rules: http://adguard.com/en/filterrules.html#cssInjection
     */
    var CssFilter = function (rules) {

        this.commonCss = null;
        this.commonCssHits = null;
        this.commonRules = [];
        this.domainSensitiveRules = [];
        this.extendedCssRules = [];
        this.exceptionRules = [];
        this.dirty = false;

        if (rules) {
            for (var i = 0; i < rules.length; i++) {
                this.addRule(rules[i]);
            }
        }
    };

    // Bitmask to be used in CssFilter#_filterRules and Cssfilter#buildCss calls.
    var RETRIEVE_TRADITIONAL_CSS = CssFilter.RETRIEVE_TRADITIONAL_CSS = 1 << 0;
    var RETRIEVE_EXTCSS = CssFilter.RETRIEVE_EXTCSS = 1 << 1;
    var GENERIC_HIDE_APPLIED = CssFilter.GENERIC_HIDE_APPLIED = 1 << 2;
    var CSS_INJECTION_ONLY = CssFilter.CSS_INJECTION_ONLY = 1 << 3;

    CssFilter.prototype = {

        /**
         * Adds rule to CssFilter
         *
         * @param rule Rule to add
         */
        addRule: function (rule) {
            // TODO: Check that extended css rules can be also whitelist (#@#)

            if (rule.whiteListRule) {
                this.exceptionRules.push(rule);
            } else if (rule.extendedCss) {
                this.extendedCssRules.push(rule);
            } else if (rule.isDomainSensitive()) {
                this.domainSensitiveRules.push(rule);
            } else {
                this.commonRules.push(rule);
            }

            this.dirty = true;
        },

        /**
         * Removes rule from the CssFilter
         *
         * @param rule Rule to remove
         */
        removeRule: function (rule) {

            var ruleText = rule.ruleText;

            this.exceptionRules = this.exceptionRules.filter(function (r) {
                return r.ruleText != ruleText;
            });
            this.extendedCssRules = this.extendedCssRules.filter(function (r) {
                return r.ruleText != ruleText;
            });
            this.domainSensitiveRules = this.domainSensitiveRules.filter(function (r) {
                return r.ruleText != ruleText;
            });
            this.commonRules = this.commonRules.filter(function (r) {
                return r.ruleText != ruleText;
            });

            this._rollbackExceptionRule(rule);

            this.dirty = true;
        },

        /**
         * Returns the array of loaded rules
         */
        getRules: function () {
            var result = [];
            return result.concat(this.commonRules).concat(this.domainSensitiveRules).concat(this.exceptionRules).concat(this.extendedCssRules);
        },

        /**
         * An object with the information on the CSS and ExtendedCss stylesheets which
         * need to be injected into a web page.
         *
         * @typedef {Object} CssFilterBuildResult
         * @property {Array.<string>} css Regular CSS stylesheets
         * @property {Array.<string>} extendedCss ExtendedCSS stylesheets
         */

        /**
         * Builds CSS to be injected to the page.
         * This method builds CSS for element hiding rules only:
         * http://adguard.com/en/filterrules.html#hideRules
         *
         * @param domainName    Domain name
         * @param options       CssFilter Bitmask
         * @returns {CssFilterBuildResult} CSS and ExtCss stylesheets
         */
        buildCss: function (domainName, options) {
            if (typeof options === 'undefined') {
                options = RETRIEVE_TRADITIONAL_CSS + RETRIEVE_EXTCSS;
            }

            var cssInjectionOnly = (options & CSS_INJECTION_ONLY) === CSS_INJECTION_ONLY;
            var genericHide = (options & GENERIC_HIDE_APPLIED) === GENERIC_HIDE_APPLIED;
            var retrieveTraditionalCss = (options & RETRIEVE_TRADITIONAL_CSS) === RETRIEVE_TRADITIONAL_CSS;

            if (cssInjectionOnly) {
                this._rebuildBinding();
            } else {
                this._rebuild();
            }

            var rules = this._filterRules(domainName, options);

            var stylesheets = this._createCssStylesheets(rules);
            if (!genericHide && retrieveTraditionalCss) { // ExtCss rules are not contained in commonRules
                var commonCss = this._getCommonCss();
                if (cssInjectionOnly) {
                    commonCss = this._buildCssByRules(this.commonRules.filter(function (rule) {
                        return rule.isInjectRule;
                    }));
                }
                Array.prototype.unshift.apply(stylesheets.css, commonCss);
            }

            return stylesheets;
        },

        /**
         * Builds CSS to be injected to the page.
         * If user has enabled "Send statistics for ad filters usage" option we build CSS with enabled hits stats.
         * In this case style contains "content" attribute with filter identifier and rule text.
         * Parsing this attributes shows us which rule has been used.
         *
         * @param domainName    Domain name
         * @param options CssFilter bitmask
         * @returns {CssFilterBuildResult} CSS and ExtCss stylesheets
         */
        buildCssHits: function (domainName, options) {
            this._rebuildHits();

            if (typeof options === 'undefined') {
                options = RETRIEVE_TRADITIONAL_CSS + RETRIEVE_EXTCSS;
            }

            var rules = this._filterRules(domainName, options);

            var genericHide = (options & GENERIC_HIDE_APPLIED) === GENERIC_HIDE_APPLIED;
            var retrieveTraditionalCss = (options & RETRIEVE_TRADITIONAL_CSS) === RETRIEVE_TRADITIONAL_CSS;

            var stylesheets = this._createCssStylesheetsHits(rules);
            if (!genericHide && retrieveTraditionalCss) {
                stylesheets.css = this._getCommonCssHits().concat(stylesheets.css);
            }

            return stylesheets;
        },

        /**
         * Filters rules with specified parameters
         *
         * @param domainName
         * @param options CssFilter bitmask
         * @returns {*}
         * @private
         */
        _filterRules: function (domainName, options) {
            var rules = [];
            var rule;

            var retrieveTraditionalCss = (options & RETRIEVE_TRADITIONAL_CSS) === RETRIEVE_TRADITIONAL_CSS;
            var retrieveExtCss = (options & RETRIEVE_EXTCSS) === RETRIEVE_EXTCSS;
            var genericHide = (options & GENERIC_HIDE_APPLIED) === GENERIC_HIDE_APPLIED;
            var cssInjectionOnly = (options & CSS_INJECTION_ONLY) === CSS_INJECTION_ONLY;

            if (!domainName) { return rules; }

            if (retrieveTraditionalCss && this.domainSensitiveRules !== null) {
                var iDomainSensitive = this.domainSensitiveRules.length;
                while (iDomainSensitive--) {
                    rule = this.domainSensitiveRules[iDomainSensitive];
                    if (rule.isPermitted(domainName)) {
                        if (genericHide && rule.isGeneric()) { continue; }
                        if (cssInjectionOnly && !rule.isInjectRule) { continue; }
                        rules.push(rule);
                    }
                }
            }

            if (retrieveExtCss && this.extendedCssRules !== null) {
                var iExtendedCss = this.extendedCssRules.length;
                while (iExtendedCss--) {
                    rule = this.extendedCssRules[iExtendedCss];
                    if (rule.isPermitted(domainName)) {
                        if (genericHide && rule.isGeneric()) {
                            continue;
                        }
                        rules.push(rule);
                    }
                }
            }

            return rules;
        },

        /**
         * Creates separated stylesheet for css and extended css rules.
         *
         * @param rules
         * @returns {{css: (*|*[]), extendedCss: (*|*[])}}
         * @private
         */
        _createCssStylesheets: function (rules) {
            var extendedCssRules = rules.filter(function (rule) {
                return rule.extendedCss;
            });

            var cssRules = rules.filter(function (rule) {
                return !rule.extendedCss;
            });

            return {
                css: this._buildCssByRules(cssRules),
                extendedCss: this._buildCssByRules(extendedCssRules)
            };
        },

        /**
         * Creates separated stylesheet for css and extended css rules.
         *
         * @param rules
         * @returns {{css: (*|List), extendedCss: (*|List)}}
         * @private
         */
        _createCssStylesheetsHits: function (rules) {
            var extendedCssRules = rules.filter(function (rule) {
                return rule.extendedCss;
            });

            var cssRules = rules.filter(function (rule) {
                return !rule.extendedCss;
            });

            return {
                css: this._buildCssByRulesHits(cssRules),
                extendedCss: this._buildCssByRulesHits(extendedCssRules)
            };
        },

        /**
         * Rebuilds CSS stylesheets if CssFilter is "dirty" (has some changes which are not applied yet).
         *
         * @private
         */
        _rebuild: function () {
            if (!this.dirty) {
                return;
            }
            this._applyExceptionRules();
            this.commonCss = this._buildCssByRules(this.commonRules);
            this.commonCssHits = null;
            this.dirty = false;
        },

        /**
         * Rebuilds CSS with hits stylesheet if CssFilter is "dirty" (has some changes which are not applied yet).
         *
         * If user has enabled "Send statistics for ad filters usage" option we build CSS with enabled hits stats.
         *
         * @private
         */
        _rebuildHits: function () {
            if (!this.dirty) {
                return;
            }
            this._applyExceptionRules();
            this.commonCssHits = this._buildCssByRulesHits(this.commonRules);
            this.commonCss = null;
            this.dirty = false;
        },

        /**
         * Rebuilds CSS filter.
         *
         * This method is used in Firefox if user has enabled "Send statistics for ad filters usage" option.
         * In this case we don't need commonCss and commonCssHits strings.
         * We just register browser-wide stylesheet which is stored in file.
         *
         * @private
         */
        _rebuildBinding: function () {
            if (!this.dirty) {
                return;
            }
            this._applyExceptionRules();
            this.commonCss = null;
            this.commonCssHits = null;
            this.dirty = false;
        },
        /**
         * Applies exception rules
         *
         * Read here for details:
         * http://adguard.com/en/filterrules.html#hideRulesExceptions
         * http://adguard.com/en/filterrules.html#cssInjectionExceptions
         * @private
         */
        _applyExceptionRules: function () {

            var i, j, rule, exceptionRules;

            var exceptionRulesMap = this._arrayToMap(this.exceptionRules, 'cssSelector');

            for (i = 0; i < this.domainSensitiveRules.length; i++) {
                rule = this.domainSensitiveRules[i];
                exceptionRules = exceptionRulesMap[rule.cssSelector];
                if (exceptionRules) {
                    for (j = 0; j < exceptionRules.length; j++) {

                        this._applyExceptionRule(rule, exceptionRules[j]);
                    }
                }
            }

            for (i = 0; i < this.extendedCssRules.length; i++) {
                rule = this.extendedCssRules[i];
                exceptionRules = exceptionRulesMap[rule.cssSelector];
                if (exceptionRules) {
                    for (j = 0; j < exceptionRules.length; j++) {
                        this._applyExceptionRule(rule, exceptionRules[j]);
                    }
                }
            }

            var newDomainSensitiveRules = [];

            for (i = 0; i < this.commonRules.length; i++) {
                rule = this.commonRules[i];
                exceptionRules = exceptionRulesMap[rule.cssSelector];
                if (exceptionRules) {
                    for (j = 0; j < exceptionRules.length; j++) {
                        this._applyExceptionRule(rule, exceptionRules[j]);
                    }
                    if (rule.isDomainSensitive()) {
                        // Rule has become domain sensitive.
                        // We should remove it from common rules and add to domain sensitive.
                        newDomainSensitiveRules.push(rule);
                    }
                }
            }

            var newDomainSensitiveRulesMap = this._arrayToMap(newDomainSensitiveRules, 'ruleText');

            this.domainSensitiveRules = this.domainSensitiveRules.concat(newDomainSensitiveRules);
            // Remove new domain sensitive rules from common rules
            this.commonRules = this.commonRules.filter(function (el) {
                return !(el.ruleText in newDomainSensitiveRulesMap);
            });
        },

        /**
         * Applies exception rule to the specified common rule.
         * Common means that this rule does not have $domain option.
         *
         * @param commonRule        Rule object
         * @param exceptionRule     Exception rule object
         * @private
         */
        _applyExceptionRule: function (commonRule, exceptionRule) {

            if (commonRule.cssSelector !== exceptionRule.cssSelector) {
                return;
            }

            commonRule.addRestrictedDomains(exceptionRule.getPermittedDomains());
        },

        /**
         * Getter for commonCss field.
         * Lazy-initializes commonCss field if needed.
         *
         * @returns Common CSS stylesheet content
         * @private
         */
        _getCommonCss: function () {
            if (this.commonCss === null || this.commonCss.length === 0) {
                this.commonCss = this._buildCssByRules(this.commonRules);
            }
            return this.commonCss;
        },

        /**
         * Getter for commonCssHits field.
         * Lazy-initializes commonCssHits field if needed.
         *
         * @private
         */
        _getCommonCssHits: function () {
            if (this.commonCssHits === null || this.commonCssHits.length === 0) {
                this.commonCssHits = this._buildCssByRulesHits(this.commonRules);
            }
            return this.commonCssHits;
        },

        /**
         * Rolls back exception rule (used if this exception rule is removed from the user filter)
         *
         * @param exceptionRule Exception rule to roll back
         * @private
         */
        _rollbackExceptionRule: function (exceptionRule) {

            if (!exceptionRule.whiteListRule) {
                return;
            }

            var newCommonRules = [];
            var i, rule;

            for (i = 0; i < this.domainSensitiveRules.length; i++) {
                rule = this.domainSensitiveRules[i];
                if (rule.cssSelector == exceptionRule.cssSelector) {
                    rule.removeRestrictedDomains(exceptionRule.getPermittedDomains());
                    if (!rule.isDomainSensitive()) {
                        // Rule has become common.
                        // We should remove it from domain sensitive rules and add to common.
                        newCommonRules.push(rule);
                    }
                }
            }

            for (i = 0; i < this.extendedCssRules.length; i++) {
                rule = this.extendedCssRules[i];
                if (rule.cssSelector == exceptionRule.cssSelector) {
                    rule.removeRestrictedDomains(exceptionRule.getPermittedDomains());
                }
            }

            this.commonRules = this.commonRules.concat(newCommonRules);

            // Remove new common rules from  domain sensitive rules
            var newCommonRulesMap = this._arrayToMap(newCommonRules, 'ruleText');
            this.domainSensitiveRules = this.domainSensitiveRules.filter(function (el) {
                return !(el.ruleText in newCommonRulesMap);
            });
        },

        /**
         * Builds CSS to be injected
         *
         * @param rules     List of rules
         * @returns {Array<string>} of CSS stylesheets
         * @private
         */
        _buildCssByRules: function (rules) {

            var CSS_SELECTORS_PER_LINE = 50;
            var ELEMHIDE_CSS_STYLE = " { display: none!important; }\r\n";

            var elemHideSb = [];
            var selectorsCount = 0;
            var cssSb = [];

            for (var i = 0; i < rules.length; i++) {
                var rule = rules[i];

                if (rule.isInjectRule) {
                    cssSb.push(this._getRuleCssSelector(rule));
                } else {
                    elemHideSb.push(this._getRuleCssSelector(rule));
                    ++selectorsCount;
                    if (selectorsCount % CSS_SELECTORS_PER_LINE === 0 || rule.extendedCss) {
                        elemHideSb.push(ELEMHIDE_CSS_STYLE);
                    } else {
                        elemHideSb.push(", ");
                    }
                }
            }

            if (elemHideSb.length > 0) {
                // Last element should always be a style (it will replace either a comma or the same style)
                elemHideSb[elemHideSb.length - 1] = ELEMHIDE_CSS_STYLE;
            }

            var styles = [];
            var elemHideStyle = elemHideSb.join("");
            var cssStyle = cssSb.join("\r\n");

            if (elemHideStyle) {
                styles.push(elemHideStyle);
            }

            if (cssStyle) {
                styles.push(cssStyle);
            }

            return styles;
        },

        /**
         * Patch rule selector adding adguard mark and rule info in the content attribute
         * Example:
         * .selector { color: red } -> .selector { color: red, content: 'adguard{filterId};{ruleText} !important;}
         * @param rule
         * @returns {String}
         */
        _addMarkerToInjectRule: function (rule) {
            var INJECT_HIT_START = " content: 'adguard";
            var HIT_SEP = encodeURIComponent(';');
            var HIT_END = "' !important;}\r\n";

            var result = [];
            var ruleText = this._getRuleCssSelector(rule);
            // if rule text has content attribute we don't add rule marker
            var contentAttributeRegex = /[{;"(]\s*content\s*:/gi;
            if (contentAttributeRegex.test(ruleText)) {
                return ruleText;
            }
            // remove closing brace
            var ruleTextWithoutCloseBrace = ruleText.slice(0, -1).trim();
            // check semicolon
            var ruleTextWithSemicolon = adguard.utils.strings.endsWith(ruleTextWithoutCloseBrace, ';') ?
                ruleTextWithoutCloseBrace :
                ruleTextWithoutCloseBrace + ';';
            result.push(ruleTextWithSemicolon);
            result.push(INJECT_HIT_START);
            result.push(rule.filterId);
            result.push(HIT_SEP);
            result.push(api.FilterRule.escapeRule(rule.ruleText));
            result.push(HIT_END);
            return result.join('');
        },

        /**
         * Patch rule selector adding adguard mark rule info in the content attribute
         * Example:
         * .selector -> .selector { content: 'adguard{filterId};{ruleText} !important;}
         * @param rule
         * @returns {String}
         */
        _addMarkerToElemhideRule: function (rule) {
            var ELEMHIDE_HIT_START = " { display: none!important; content: 'adguard";
            var HIT_SEP = encodeURIComponent(';');
            var HIT_END = "' !important;}\r\n";

            var result = [];
            result.push(this._getRuleCssSelector(rule));
            result.push(ELEMHIDE_HIT_START);
            result.push(rule.filterId);
            result.push(HIT_SEP);
            result.push(api.FilterRule.escapeRule(rule.ruleText));
            result.push(HIT_END);
            return result.join('');
        },

        /**
         * Builds CSS with content style to be injected.
         * This method is used if user has enabled "Send statistics for ad filters usage" option and/or
         * if filtering log window is open
         * Parsing css 'content' attribute allows us to track rule hits.
         *
         * @param rules List of rules
         * @returns List of CSS stylesheets
         * @private
         */
        _buildCssByRulesHits: function (rules) {
            var styles = [];
            for (var i = 0; i < rules.length; i += 1) {
                var rule = rules[i];
                if (rule.isInjectRule) {
                    styles.push(this._addMarkerToInjectRule(rule));
                } else {
                    styles.push(this._addMarkerToElemhideRule(rule));
                }
            }
            return styles;
        },

        _getRuleCssSelector: function (rule) {
            return rule.cssSelector;
        },

        _arrayToMap: function (array, prop) {
            var map = Object.create(null);
            for (var i = 0; i < array.length; i++) {
                var el = array[i];
                var property = el[prop];
                if (!(property in map)) {
                    map[property] = [];
                }
                map[property].push(el);
            }
            return map;
        }
    };

    api.CssFilter = CssFilter;

})(adguard, adguard.rules);


/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (adguard, api) {
    'use strict';

    /**
     * By the rules of AMO and addons.opera.com we cannot use remote scripts
     * (and our JS injection rules could be considered as remote scripts).
     *
     * So, what we do:
     * 1. Pre-compile all current JS rules to the add-on and mark them as 'local'.
     * Other JS rules (new not pre-compiled) are marked as 'remote'.
     * 2. Also we mark as 'local' rules from the "User Filter" (local filter which user can edit)
     * 3. In case of Firefox and Opera we apply only 'local'
     * JS rules and ignore all marked as 'remote'
     * Note: LocalScriptRulesService may be undefined, in this case, we mark all rules as remote.
     */
    function getScriptSource(filterId, ruleText) {
        return filterId === adguard.utils.filters.USER_FILTER_ID
        || (api.LocalScriptRulesService && api.LocalScriptRulesService.isLocal(ruleText))
            ? 'local'
            : 'remote';
    }

    /**
     * JS injection rule:
     * http://adguard.com/en/filterrules.html#javascriptInjection
     */
    const ScriptFilterRule = function (rule, filterId) {
        api.FilterRule.call(this, rule, filterId);

        this.script = null;
        this.whiteListRule = adguard.utils.strings.contains(
            rule,
            api.FilterRule.MASK_SCRIPT_EXCEPTION_RULE
        );
        const mask = this.whiteListRule
            ? api.FilterRule.MASK_SCRIPT_EXCEPTION_RULE
            : api.FilterRule.MASK_SCRIPT_RULE;

        const indexOfMask = rule.indexOf(mask);
        if (indexOfMask > 0) {
            // domains are specified, parsing
            const domains = rule.substring(0, indexOfMask);
            this.loadDomains(domains);
        }

        this.script = rule.substring(indexOfMask + mask.length);

        this.scriptSource = getScriptSource(filterId, rule);
    };

    function getScript() {
        return this.script;
    }

    /**
     * returns rule content after mask
     * e.g. example.org#%#window.AG_onLoad = function(func) {} ->
     * -> #%#window.AG_onLoad = function(func) {}
     * @return {string}
     */
    function getRuleContent() {
        return this.script;
    }

    ScriptFilterRule.prototype = Object.create(api.FilterRule.prototype);

    ScriptFilterRule.prototype.getScript = getScript;

    ScriptFilterRule.prototype.getRuleContent = getRuleContent;

    /**
     * All content rules markers start with this character
     */
    ScriptFilterRule.RULE_MARKER_FIRST_CHAR = '#';

    /**
     * Content rule markers
     */
    ScriptFilterRule.RULE_MARKERS = [
        api.FilterRule.MASK_SCRIPT_EXCEPTION_RULE,
        api.FilterRule.MASK_SCRIPT_RULE,
    ];

    api.ScriptFilterRule = ScriptFilterRule;
})(adguard, adguard.rules);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (adguard, api) {
    'use strict';

    /**
     * Filter that manages JS injection rules.
     * Read here for details: http://adguard.com/en/filterrules.html#javascriptInjection
     */
    const ScriptFilter = function (rules) {
        this.scriptRules = [];
        this.exceptionsRules = [];

        if (rules) {
            for (let i = 0; i < rules.length; i++) {
                this.addRule(rules[i]);
            }
        }
    };

    ScriptFilter.prototype = {

        /**
         * Adds JS injection rule
         *
         * @param rule Rule object
         */
        addRule(rule) {
            if (rule.whiteListRule) {
                this.exceptionsRules.push(rule);
                this._applyExceptionRuleToFilter(rule);
                return;
            }

            this._applyExceptionRulesToRule(rule);
            this.scriptRules.push(rule);
        },

        /**
         * Removes JS injection rule
         *
         * @param rule Rule object
         */
        removeRule(rule) {
            adguard.utils.collections.removeRule(this.scriptRules, rule);
            adguard.utils.collections.removeRule(this.exceptionsRules, rule);
            this._rollbackExceptionRule(rule);
        },

        /**
         * Removes all rules from this filter
         */
        clearRules() {
            this.scriptRules = [];
            this.exceptionsRules = [];
        },

        /**
         * Returns the array of loaded rules
         */
        getRules() {
            return this.scriptRules.concat(this.exceptionsRules);
        },

        /**
         * Builds script for the specified domain to be injected
         *
         * @param domainName Domain name
         * @param {Object} debugConfig
         * @returns {{scriptSource: string, rule: string}[]} List of scripts to be applied
         * and scriptSource
         */
        buildScript(domainName, debugConfig) {
            const scripts = [];
            for (let i = 0; i < this.scriptRules.length; i += 1) {
                const rule = this.scriptRules[i];
                if (rule.isPermitted(domainName)) {
                    const script = rule.getScript(debugConfig);
                    if (script) {
                        scripts.push({
                            scriptSource: rule.scriptSource,
                            script,
                            rule,
                        });
                    }
                }
            }
            return scripts;
        },

        /**
         * Rolls back exception rule:
         * http://adguard.com/en/filterrules.html#javascriptInjectionExceptions
         *
         * @param exceptionRule Exception rule
         * @private
         */
        _rollbackExceptionRule(exceptionRule) {
            if (!exceptionRule.whiteListRule) {
                return;
            }

            for (let i = 0; i < this.scriptRules.length; i++) {
                const scriptRule = this.scriptRules[i];
                if (scriptRule.getRuleContent() === exceptionRule.getRuleContent()) {
                    scriptRule.removeRestrictedDomains(exceptionRule.getPermittedDomains());
                }
            }
        },

        /**
         * Applies exception rule:
         * http://adguard.com/en/filterrules.html#javascriptInjectionExceptions
         *
         * @param exceptionRule Exception rule
         * @private
         */
        _applyExceptionRuleToFilter(exceptionRule) {
            for (let i = 0; i < this.scriptRules.length; i++) {
                this._removeExceptionDomains(this.scriptRules[i], exceptionRule);
            }
        },

        /**
         * Applies exception rules:
         * http://adguard.com/en/filterrules.html#javascriptInjectionExceptions
         *
         * @param scriptRule JS injection rule
         * @private
         */
        _applyExceptionRulesToRule(scriptRule) {
            for (let i = 0; i < this.exceptionsRules.length; i++) {
                this._removeExceptionDomains(scriptRule, this.exceptionsRules[i]);
            }
        },

        _removeExceptionDomains(scriptRule, exceptionRule) {
            if (scriptRule.getRuleContent() !== exceptionRule.getRuleContent()) {
                return;
            }

            scriptRule.addRestrictedDomains(exceptionRule.getPermittedDomains());
        },
    };

    api.ScriptFilter = ScriptFilter;
})(adguard, adguard.rules);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (adguard, api) {
    'use strict';

    const ESCAPE_CHARACTER = '\\';

    /**
     * Searches for domain name in rule text and transforms it to punycode if needed.
     *
     * @param ruleText Rule text
     * @returns Transformed rule text
     */
    function getAsciiDomainRule(ruleText) {
        try {
            if (/^[\x00-\x7F]+$/.test(ruleText)) {
                return ruleText;
            }

            const domain = parseRuleDomain(ruleText, true);
            if (!domain) {
                return '';
            }

            // In case of one domain
            return adguard.utils.strings.replaceAll(ruleText, domain, adguard.utils.url.toPunyCode(domain));
        } catch (ex) {
            adguard.console.error('Error getAsciiDomainRule from {0}, cause {1}', ruleText, ex);
            return '';
        }
    }

    /**
     * Searches for domain name in rule text.
     *
     * @param ruleText Rule text
     * @param parseOptions Flag to parse rule options
     * @returns string domain name
     */
    function parseRuleDomain(ruleText, parseOptions) {
        try {
            let i;
            const startsWith = ['http://www.', 'https://www.', 'http://', 'https://', '||', '//'];
            const contains = ['/', '^'];
            let startIndex = parseOptions ? -1 : 0;

            for (i = 0; i < startsWith.length; i++) {
                const start = startsWith[i];
                if (adguard.utils.strings.startWith(ruleText, start)) {
                    startIndex = start.length;
                    break;
                }
            }

            if (parseOptions) {
                // exclusive for domain
                const exceptRule = 'domain=';
                const domainIndex = ruleText.indexOf(exceptRule);
                if (domainIndex > -1 && ruleText.indexOf('$') > -1) {
                    startIndex = domainIndex + exceptRule.length;
                }

                if (startIndex === -1) {
                    // Domain is not found in rule options, so we continue a normal way
                    startIndex = 0;
                }
            }

            let symbolIndex = -1;
            for (i = 0; i < contains.length; i++) {
                const contain = contains[i];
                const index = ruleText.indexOf(contain, startIndex);
                if (index >= 0) {
                    symbolIndex = index;
                    break;
                }
            }

            return symbolIndex === -1 ? ruleText.substring(startIndex) : ruleText.substring(startIndex, symbolIndex);
        } catch (ex) {
            adguard.console.error('Error parsing domain from {0}, cause {1}', ruleText, ex);
            return null;
        }
    }

    /**
     * Searches for the shortcut of this url mask.
     * Shortcut is the longest part of the mask without special characters:
     * *,^,|. If not found anything with the length greater or equal to 8 characters -
     * shortcut is not used.
     *
     * @param urlmask
     * @returns {string}
     */
    function findShortcut(urlmask) {
        let longest = '';
        const parts = urlmask.split(/[*^|]/);
        for (let i = 0; i < parts.length; i++) {
            const part = parts[i];
            if (part.length > longest.length) {
                longest = part;
            }
        }

        return longest ? longest.toLowerCase() : null;
    }

    /**
     * Extracts a shortcut from a regexp rule.
     *
     * @param {string} ruleText rule text
     * @returns {string} shortcut or null if it's not possible to extract it
     */
    function extractRegexpShortcut(ruleText) {
        // Get the regexp text
        const match = ruleText.match(/\/(.*)\/(\$.*)?/);
        if (!match || match.length < 2) {
            return null;
        }

        let reText = match[1];

        const specialCharacter = '...';

        if (reText.indexOf('?') !== -1) {
            // Do not mess with complex expressions which use lookahead
            // And with those using ? special character: https://github.com/AdguardTeam/AdguardBrowserExtension/issues/978
            return null;
        }

        // (Dirty) prepend specialCharacter for the following replace calls to work properly
        reText = specialCharacter + reText;

        // Strip all types of brackets
        reText = reText.replace(/[^\\]\(.*[^\\]\)/, specialCharacter);
        reText = reText.replace(/[^\\]\[.*[^\\]\]/, specialCharacter);
        reText = reText.replace(/[^\\]\{.*[^\\]\}/, specialCharacter);

        // Strip some special characters
        reText = reText.replace(/[^\\]\\[a-zA-Z]/, specialCharacter);

        // Split by special characters
        const parts = reText.split(/[\\^$*+?.()|[\]{}]/);
        let token = '';
        let iParts = parts.length;
        while (iParts--) {
            const part = parts[iParts];
            if (part.length > token.length) {
                token = part;
            }
        }

        return token ? token.toLowerCase() : null;
    }

    /**
     * Parse rule text
     * @param ruleText
     * @returns {{urlRuleText: *, options: *, whiteListRule: *}}
     * @private
     */
    function parseRuleText(ruleText) {
        let urlRuleText = ruleText;
        let whiteListRule = null;
        let options = null;

        let startIndex = 0;

        if (adguard.utils.strings.startWith(urlRuleText, api.FilterRule.MASK_WHITE_LIST)) {
            startIndex = api.FilterRule.MASK_WHITE_LIST.length;
            urlRuleText = urlRuleText.substring(startIndex);
            whiteListRule = true;
        }

        let parseOptions = true;
        /**
         * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/517
         * regexp rule may contain dollar sign which also is options delimiter
         */
        // Added check for replacement rule, because maybe problem with rules for example /.*/$replace=/hello/bug/

        if (adguard.utils.strings.startWith(urlRuleText, api.UrlFilterRule.MASK_REGEX_RULE)
            && adguard.utils.strings.endsWith(urlRuleText, api.UrlFilterRule.MASK_REGEX_RULE)
            && !adguard.utils.strings.contains(urlRuleText, `${api.UrlFilterRule.REPLACE_OPTION}=`)) {
            parseOptions = false;
        }

        if (parseOptions) {
            let foundEscaped = false;
            // Start looking from the prev to the last symbol
            // If dollar sign is the last symbol - we simply ignore it.
            for (let i = (ruleText.length - 2); i >= startIndex; i--) {
                const c = ruleText.charAt(i);
                if (c === UrlFilterRule.OPTIONS_DELIMITER) {
                    if (i > 0 && ruleText.charAt(i - 1) === ESCAPE_CHARACTER) {
                        foundEscaped = true;
                    } else {
                        urlRuleText = ruleText.substring(startIndex, i);
                        options = ruleText.substring(i + 1);

                        if (foundEscaped) {
                            // Find and replace escaped options delimiter
                            const search = api.SimpleRegex.escapeRegExp(ESCAPE_CHARACTER + UrlFilterRule.OPTIONS_DELIMITER);
                            const regexp = new RegExp(search, 'g');
                            options = options.replace(regexp, UrlFilterRule.OPTIONS_DELIMITER);
                        }

                        // Options delimiter was found, doing nothing
                        break;
                    }
                }
            }
        }

        // Transform to punycode
        urlRuleText = getAsciiDomainRule(urlRuleText);

        return {
            urlRuleText,
            options,
            whiteListRule,
        };
    }

    /**
     * Validates CSP rule
     * @param rule Rule with $CSP modifier
     */
    function validateCspRule(rule) {
        /**
         * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/685
         * CSP directive may be empty in case of whitelist rule, it means to disable all $csp rules matching the whitelist rule
         */
        if (!rule.whiteListRule && !rule.cspDirective) {
            throw new Error('Invalid $CSP rule: CSP directive must not be empty');
        }

        if (rule.cspDirective) {
            /**
             * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/685#issue-228287090
             * Forbids report-to and report-uri directives
             */
            const cspDirective = rule.cspDirective.toLowerCase();
            if (cspDirective.indexOf('report-') >= 0) {
                throw new Error(`Forbidden CSP directive: ${cspDirective}`);
            }
        }
    }

    /**
     * Represents a $replace modifier value.
     * <p/>
     * Learn more about this modifier syntax here:
     * https://github.com/AdguardTeam/AdguardForWindows/issues/591
     */
    function ReplaceOption(option) {
        if (!option) {
            return {
                optionText: '',
            };
        }

        const parts = adguard.utils.strings.splitByDelimiterWithEscapeCharacter(option, '/', ESCAPE_CHARACTER, true);

        if (parts.length < 2 || parts.length > 3) {
            throw `Cannot parse ${option}`;
        }

        let modifiers = (parts[2] || '');
        if (modifiers.indexOf('g') < 0) {
            modifiers += 'g';
        }

        const pattern = new RegExp(parts[0], modifiers);
        const replacement = parts[1];

        const apply = input => input.replace(pattern, replacement);

        return {
            apply,
            optionText: option,
        };
    }

    function RedirectOption(option) {
        const getRedirectUrl = () => adguard.rules.RedirectFilterService.buildRedirectUrl(option);
        return { getRedirectUrl, redirectTitle: option };
    }

    /**
     * @typedef CookieOption
     * @type {object}
     * @property {RegExp} regex If not null this is a regex used to match cookie names
     * @property {string} cookieName An exact cookie name used to match cookies by name
     * @property {string} sameSite If not null, this is a Same-Site value to be forced for a matching cookie
     * @property {number} maxAge If not null, this is a cookie's maximum age to be enforced
     */

    /**
     * Represents a $cookie modifier option value.
     *
     * Learn more about it here:
     * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/961
     *
     * @param {string} option Option string value
     * @see {@link CookieOption}
     * @constructor
     */
    function CookieOption(option) {
        // Save the source text of the option modifier
        this.option = option || '';

        // Initialize properties with null
        this.regex = null;
        this.cookieName = null;
        this.sameSite = null;
        this.maxAge = null;

        // Parse cookie name/regex
        const parts = this.option.split(/;/);
        const cookieName = parts[0];
        if (adguard.utils.strings.startWith(cookieName, '/') && adguard.utils.strings.endsWith(cookieName, '/')) {
            const pattern = cookieName.substring(1, cookieName.length - 1);

            // Save regex to be used further for matching cookies
            this.regex = new RegExp(pattern);
        } else {
            // Match by cookie name
            this.cookieName = cookieName;
        }

        // Parse other cookie options
        if (parts.length > 1) {
            for (let i = 1; i < parts.length; i += 1) {
                const nameValue = parts[i].split('=');
                const optionName = nameValue[0];
                const optionValue = nameValue[1];

                if (optionName === UrlFilterRule.cookieOptions.MAX_AGE) {
                    this.maxAge = parseInt(optionValue);
                } else if (optionName === UrlFilterRule.cookieOptions.SAME_SITE) {
                    this.sameSite = optionValue;
                } else {
                    throw `Unknown $cookie option: ${optionName}`;
                }
            }
        }

        /**
         * Checks if cookie with the specified name matches this option
         *
         * @param {string} name Cookie name
         * @return {boolean} true if it does
         */
        this.matches = function (name) {
            if (!name) {
                return false;
            }

            if (this.regex) {
                return this.regex.test(name);
            } if (this.cookieName) {
                return this.cookieName === name;
            }
            // Empty regex and cookieName means that we must match all cookies
            return true;
        };

        /**
         * Checks if cookie rule has an empty $cookie option
         * @return {boolean} True if $cookie option is empty
         */
        this.isEmpty = function () {
            return !this.regex && !this.cookieName;
        };
    }

    /**
     * Check if the specified options mask contains the given option
     * @param options Options
     * @param option Option
     */
    function containsOption(options, option) {
        return options !== null
            && (options & option) === option;
    }

    /**
     * Rule for blocking requests to URLs.
     * Read here for details:
     * http://adguard.com/en/filterrules.html#baseRules
     */
    var UrlFilterRule = function (rule, filterId) {
        api.FilterRule.call(this, rule, filterId);

        // Url shortcut
        this.shortcut = null;
        // Content type masks
        this.permittedContentType = UrlFilterRule.contentTypes.ALL;
        this.restrictedContentType = 0;
        // Rule options
        this.enabledOptions = null;
        this.disabledOptions = null;

        // Parse rule text
        const parseResult = parseRuleText(rule);

        // Exception rule flag
        if (parseResult.whiteListRule) {
            this.whiteListRule = true;
        }

        // Load options
        if (parseResult.options) {
            this._loadOptions(parseResult.options);
        }

        const { urlRuleText } = parseResult;

        this.isRegexRule = adguard.utils.strings.startWith(urlRuleText, UrlFilterRule.MASK_REGEX_RULE)
            && adguard.utils.strings.endsWith(urlRuleText, UrlFilterRule.MASK_REGEX_RULE)
            || urlRuleText === ''
            || urlRuleText === UrlFilterRule.MASK_ANY_SYMBOL;

        if (this.isRegexRule) {
            this.urlRegExpSource = urlRuleText.substring(UrlFilterRule.MASK_REGEX_RULE.length, urlRuleText.length - UrlFilterRule.MASK_REGEX_RULE.length);

            // Pre compile regex rules
            const regexp = this.getUrlRegExp();
            if (!regexp) {
                throw Error('Illegal regexp rule');
            }

            // Except cookie rules, they have their own atmosphere
            if (!this.isCookieRule()
                && UrlFilterRule.ANY_URL_REGEX === regexp && !this.hasPermittedDomains()) {
                // Rule matches everything and does not have any domain restriction
                throw Error(`Too wide basic rule: ${urlRuleText}`);
            }

            // Extract shortcut from regexp rule
            this.shortcut = extractRegexpShortcut(urlRuleText);
        } else {
            // Searching for the rule shortcut
            this.shortcut = findShortcut(urlRuleText);
        }

        if (this.isCspRule()) {
            validateCspRule(this);
        }
    };

    UrlFilterRule.prototype = Object.create(api.FilterRule.prototype);

    // Lazy regexp source create
    UrlFilterRule.prototype.getUrlRegExpSource = function () {
        if (!this.urlRegExpSource) {
            // parse rule text
            const parseResult = parseRuleText(this.ruleText);
            // Creating regex source
            this.urlRegExpSource = api.SimpleRegex.createRegexText(parseResult.urlRuleText);
        }
        return this.urlRegExpSource;
    };

    UrlFilterRule.prototype.addStealthActions = function (actions) {
        this.stealthActions = actions;
    };

    /**
     * $replace modifier.
     * Learn more about this modifier syntax here:
     * https://github.com/AdguardTeam/AdguardForWindows/issues/591
     *
     * @return Parsed $replace modifier
     */
    UrlFilterRule.prototype.getReplace = function () {
        return this.replaceOption;
    };

    /**
     * $redirect modifier
     * Learn more about this modifier syntax here:
     * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1367
     *
     * @returns parsed $redirect modifier
     */
    UrlFilterRule.prototype.getRedirect = function () {
        return this.redirectOption;
    };

    /**
     * $cookie modifier
     * @return {CookieOption} Parsed $cookie modifier
     */
    UrlFilterRule.prototype.getCookieOption = function () {
        return this.cookieOption;
    };

    // Lazy regexp creation
    UrlFilterRule.prototype.getUrlRegExp = function () {
        // check already compiled but not successful
        if (this.wrongUrlRegExp) {
            return null;
        }

        if (!this.urlRegExp) {
            const urlRegExpSource = this.getUrlRegExpSource();
            try {
                if (!urlRegExpSource || UrlFilterRule.MASK_ANY_SYMBOL === urlRegExpSource) {
                    // Match any symbol
                    this.urlRegExp = UrlFilterRule.ANY_URL_REGEX;
                } else {
                    this.urlRegExp = new RegExp(urlRegExpSource, this.isMatchCase() ? '' : 'i');
                }

                delete this.urlRegExpSource;
            } catch (ex) {
                // malformed regexp
                adguard.console.error('Error create regexp from {0}', urlRegExpSource);
                this.wrongUrlRegExp = true;
                return null;
            }
        }

        return this.urlRegExp;
    };

    /**
     * Checks if url is for any url
     * @returns {boolean}
     */
    UrlFilterRule.prototype.isAnyUrl = function () {
        return this.shortcut === null
            && this.getUrlRegExp() === UrlFilterRule.ANY_URL_REGEX;
    };

    /**
     * There are two exceptions for domain permitting in url blocking rules.
     * White list rules must fire when request has no referrer.
     * Also rules without third-party option should fire.
     *
     * @param domainName
     * @returns {*}
     */
    UrlFilterRule.prototype.isPermitted = function (domainName) {
        if (!domainName) {
            const hasPermittedDomains = this.hasPermittedDomains();

            // For white list rules to fire when request has no referrer
            if (this.whiteListRule && !hasPermittedDomains) {
                return true;
            }

            // Also firing rules when there's no constraint on ThirdParty-FirstParty type
            if (!this.isCheckThirdParty() && !hasPermittedDomains) {
                return true;
            }
        }

        return api.FilterRule.prototype.isPermitted.call(this, domainName);
    };

    /**
     * Checks if this rule matches specified request
     *
     * @param requestUrl            Request url
     * @param thirdParty            true if request is third-party
     * @param requestType           Request type (one of adguard.RequestTypes)
     * @return {boolean} true if request url matches this rule
     */
    UrlFilterRule.prototype.isFiltered = function (requestUrl, thirdParty, requestType) {
        if (this.isOptionEnabled(UrlFilterRule.options.THIRD_PARTY) && !thirdParty) {
            // Rule is with $third-party modifier but request is not third party
            return false;
        }

        if (this.isOptionDisabled(UrlFilterRule.options.THIRD_PARTY) && thirdParty) {
            // Match only requests with a Referer header.
            // Rule is with $~third-party modifier but request is third party
            return false;
        }

        if (!this.checkContentType(requestType)) {
            return false;
        }

        // Shortcut is always in lower case
        if (this.shortcut !== null && requestUrl.toLowerCase().indexOf(this.shortcut) === -1) {
            return false;
        }

        const regexp = this.getUrlRegExp();
        if (!regexp) {
            // malformed regexp rule
            return false;
        }
        return regexp.test(requestUrl);
    };

    /**
     * Checks if request matches rule's content type constraints
     *
     * @param contentType Request type
     * @return true if request matches this content type
     */
    UrlFilterRule.prototype.checkContentType = function (contentType) {
        const contentTypeMask = UrlFilterRule.contentTypes[contentType];
        if (!contentTypeMask) {
            throw new Error(`Unsupported content type ${contentType}`);
        }
        return this.checkContentTypeMask(contentTypeMask);
    };

    /**
     * Checks if request matches rule's content type constraints
     *
     * @param contentTypeMask Request content types mask
     * @return true if request matches this content type
     */
    UrlFilterRule.prototype.checkContentTypeMask = function (contentTypeMask) {
        if (this.permittedContentType === UrlFilterRule.contentTypes.ALL
            && this.restrictedContentType === 0) {
            // Rule does not contain any constraint
            return true;
        }

        // Checking that either all content types are permitted or request content type
        // is in the permitted list
        const matchesPermitted = this.permittedContentType === UrlFilterRule.contentTypes.ALL
            || (this.permittedContentType & contentTypeMask) !== 0;

        // Checking that either no content types are restricted or request content type
        // is not in the restricted list
        const notMatchesRestricted = this.restrictedContentType === 0
            || (this.restrictedContentType & contentTypeMask) === 0;

        return matchesPermitted && notMatchesRestricted;
    };

    /**
     * Checks if specified option is enabled
     *
     * @param option Option to check
     * @return true if enabled
     */
    UrlFilterRule.prototype.isOptionEnabled = function (option) {
        return containsOption(this.enabledOptions, option);
    };

    /**
     * Checks if specified option is disabled
     *
     * @param option Option to check
     * @return true if disabled
     */
    UrlFilterRule.prototype.isOptionDisabled = function (option) {
        return containsOption(this.disabledOptions, option);
    };

    /**
     * Returns true if this rule can be applied to DOCUMENT only.
     * Examples: $popup, $elemhide and such.
     * Such rules have higher priority than common rules.
     *
     * @return true for document-level rules
     */
    UrlFilterRule.prototype.isDocumentLevel = function () {
        return this.documentLevelRule;
    };

    /**
     * True if this filter should check if request is third- or first-party.
     *
     * @return True if we should check third party property
     */
    UrlFilterRule.prototype.isCheckThirdParty = function () {
        return this.isOptionEnabled(UrlFilterRule.options.THIRD_PARTY)
            || this.isOptionDisabled(UrlFilterRule.options.THIRD_PARTY);
    };

    /**
     * If true - filter is only applied to requests from
     * a different origin that the currently viewed page.
     *
     * @return If true - filter third-party requests only
     */
    UrlFilterRule.prototype.isThirdParty = function () {
        if (this.isOptionEnabled(UrlFilterRule.options.THIRD_PARTY)) {
            return true;
        }
        if (this.isOptionDisabled(UrlFilterRule.options.THIRD_PARTY)) {
            return false;
        }
        return false;
    };

    /**
     * If true -- CssFilter cannot be applied to page
     *
     * @return true if CssFilter cannot be applied to page
     */
    UrlFilterRule.prototype.isElemhide = function () {
        return this.isOptionEnabled(UrlFilterRule.options.ELEMHIDE);
    };

    /**
     * Does not inject adguard javascript to page
     *
     * @return If true - we do not inject adguard js to page matching this rule
     */
    UrlFilterRule.prototype.isJsInject = function () {
        return this.isOptionEnabled(UrlFilterRule.options.JSINJECT);
    };

    /**
     * If true -- ContentFilter rules cannot be applied to page matching this rule.
     *
     * @return true if ContentFilter should not be applied to page matching this rule.
     */
    UrlFilterRule.prototype.isContent = function () {
        return this.isOptionEnabled(UrlFilterRule.options.CONTENT);
    };

    /**
     * Checks if the specified rule contains all document level options
     * @returns If true - contains $jsinject, $elemhide and $urlblock options
     */
    UrlFilterRule.prototype.isDocumentWhiteList = function () {
        return this.isOptionEnabled(UrlFilterRule.options.DOCUMENT_WHITELIST);
    };

    /**
     * If true - do not apply generic UrlFilter rules to the web page.
     *
     * @return true if generic url rules should not be applied.
     */
    UrlFilterRule.prototype.isGenericBlock = function () {
        return this.isOptionEnabled(UrlFilterRule.options.GENERICBLOCK);
    };

    /**
     * If true - do not apply generic CSS rules to the web page.
     *
     * @return true if generic CSS rules should not be applied.
     */
    UrlFilterRule.prototype.isGenericHide = function () {
        return this.isOptionEnabled(UrlFilterRule.options.GENERICHIDE);
    };

    /**
     * This attribute is only for exception rules. If true - do not use
     * url blocking rules for urls where referrer satisfies this rule.
     *
     * @return If true - do not block requests originated from the page matching this rule.
     */
    UrlFilterRule.prototype.isUrlBlock = function () {
        return this.isOptionEnabled(UrlFilterRule.options.URLBLOCK);
    };

    /**
     * If rule is case sensitive returns true
     *
     * @return true if rule is case sensitive
     */
    UrlFilterRule.prototype.isMatchCase = function () {
        return this.isOptionEnabled(UrlFilterRule.options.MATCH_CASE);
    };

    /**
     * If BlockPopups is true, than window should be closed
     *
     * @return true if window should be closed
     */
    UrlFilterRule.prototype.isBlockPopups = function () {
        return this.isOptionEnabled(UrlFilterRule.options.BLOCK_POPUPS);
    };

    /**
     * @returns true if this rule is csp
     */
    UrlFilterRule.prototype.isCspRule = function () {
        return this.isOptionEnabled(UrlFilterRule.options.CSP_RULE);
    };

    /**
     * @returns true if this rule is cookie
     */
    UrlFilterRule.prototype.isCookieRule = function () {
        return this.isOptionEnabled(UrlFilterRule.options.COOKIE_RULE);
    };

    /**
     * @returns true if this rule is redirect rule
     */
    UrlFilterRule.prototype.isRedirectRule = function () {
        return this.isOptionEnabled(UrlFilterRule.options.REDIRECT);
    };

    UrlFilterRule.prototype.isDocumentRule = function () {
        return this.isOptionEnabled(UrlFilterRule.options.DOCUMENT);
    };

    /**
     * @returns true if this rule is stealth
     */
    UrlFilterRule.prototype.isStealthRule = function () {
        return this.isOptionEnabled(UrlFilterRule.options.STEALTH);
    };

    /**
     * If rule is bad-filter returns true
     */
    UrlFilterRule.prototype.isBadFilter = function () {
        return this.badFilter != null;
    };

    /**
     * If rule is replace rule
     * @returns {Boolean}
     */
    UrlFilterRule.prototype.isReplaceRule = function () {
        return this.isOptionEnabled(UrlFilterRule.options.REPLACE);
    };

    /**
     * we recognize rules with $extension modifier, but
     * ignore them when create RequestFilter
     */
    UrlFilterRule.prototype.isIgnored = function () {
        return this.isOptionEnabled(UrlFilterRule.options.EXTENSION);
    };

    /**
     * Function gets options name, checks if there are alternative variants of this name
     * and returns it if found. If not found returns same name.
     * @param {string} optionName
     * @returns {string} options names in array
     */
    const checkAndReplaceIfAlias = (optionName) => {
        const OPTION_ALIASES_MAP = {
            'FIRST-PARTY': api.FilterRule.NOT_MARK + UrlFilterRule.THIRD_PARTY_OPTION,
            'XHR': UrlFilterRule.XMLHTTPREQUEST_OPTION,
            'POPUNDER': UrlFilterRule.POPUP_OPTION,
            '1P': api.FilterRule.NOT_MARK + UrlFilterRule.THIRD_PARTY_OPTION,
            '3P': UrlFilterRule.THIRD_PARTY_OPTION,
            'CSS': UrlFilterRule.STYLESHEET_OPTION,
            'FRAME': UrlFilterRule.SUBDOCUMENT_OPTION,
        };

        const upperCaseOptionName = optionName.toUpperCase();

        return OPTION_ALIASES_MAP[upperCaseOptionName] || optionName;
    };

    /**
     * Extracts options and their values from string
     * @param options
     * @returns {{optionName: string, optionValue: string}[]}
     */
    const extractOptionsAndValues = (options) => {
        const optionsParts = adguard.utils.strings.splitByDelimiterWithEscapeCharacter(
            options,
            api.FilterRule.COMA_DELIMITER,
            ESCAPE_CHARACTER,
            false
        );

        return optionsParts.reduce((acc, optionPart) => {
            const valueIndex = optionPart.indexOf(api.FilterRule.EQUAL);
            let optionName = valueIndex >= 0 ? optionPart.substr(0, valueIndex) : optionPart;
            const optionValue = valueIndex >= 0 ? optionPart.substr(valueIndex + 1) : '';
            optionName = checkAndReplaceIfAlias(optionName);

            acc.push({ optionName, optionValue });

            return acc;
        }, []);
    };

    /**
     * Loads rule options
     * @param options Options string
     * @private
     */
    UrlFilterRule.prototype._loadOptions = function (options) {
        const optionsParts = extractOptionsAndValues(options);

        for (let i = 0; i < optionsParts.length; i += 1) {
            // eslint-disable-next-line prefer-const
            let { optionName, optionValue } = optionsParts[i];

            switch (optionName) {
                case UrlFilterRule.DOMAIN_OPTION:
                    if (optionValue) {
                        // Load domain option
                        this.loadDomains(optionValue);
                    }
                    break;
                case UrlFilterRule.THIRD_PARTY_OPTION:
                    this._setUrlFilterRuleOption(UrlFilterRule.options.THIRD_PARTY, true);
                    break;
                case api.FilterRule.NOT_MARK + UrlFilterRule.THIRD_PARTY_OPTION:
                    this._setUrlFilterRuleOption(UrlFilterRule.options.THIRD_PARTY, false);
                    break;
                case UrlFilterRule.MATCH_CASE_OPTION:
                    this._setUrlFilterRuleOption(UrlFilterRule.options.MATCH_CASE, true);
                    break;
                case UrlFilterRule.IMPORTANT_OPTION:
                    this.isImportant = true;
                    break;
                case api.FilterRule.NOT_MARK + UrlFilterRule.IMPORTANT_OPTION:
                    this.isImportant = false;
                    break;
                case UrlFilterRule.ELEMHIDE_OPTION:
                    this._setUrlFilterRuleOption(UrlFilterRule.options.ELEMHIDE, true);
                    break;
                case UrlFilterRule.GENERICHIDE_OPTION:
                    this._setUrlFilterRuleOption(UrlFilterRule.options.GENERICHIDE, true);
                    break;
                case UrlFilterRule.JSINJECT_OPTION:
                    this._setUrlFilterRuleOption(UrlFilterRule.options.JSINJECT, true);
                    break;
                case UrlFilterRule.CONTENT_OPTION:
                    this._setUrlFilterRuleOption(UrlFilterRule.options.CONTENT, true);
                    break;
                case UrlFilterRule.URLBLOCK_OPTION:
                    this._setUrlFilterRuleOption(UrlFilterRule.options.URLBLOCK, true);
                    break;
                case UrlFilterRule.GENERICBLOCK_OPTION:
                    this._setUrlFilterRuleOption(UrlFilterRule.options.GENERICBLOCK, true);
                    break;
                case UrlFilterRule.DOCUMENT_OPTION:
                    this._setUrlFilterRuleOption(UrlFilterRule.options.DOCUMENT_WHITELIST, true);
                    this._setUrlFilterRuleOption(UrlFilterRule.options.DOCUMENT, true);
                    break;
                case UrlFilterRule.POPUP_OPTION:
                    this._setUrlFilterRuleOption(UrlFilterRule.options.BLOCK_POPUPS, true);
                    break;
                case UrlFilterRule.EXTENSION_OPTION:
                    this._setUrlFilterRuleOption(UrlFilterRule.options.EXTENSION, true);
                    break;
                case UrlFilterRule.CSP_OPTION:
                    this._setUrlFilterRuleOption(UrlFilterRule.options.CSP_RULE, true);
                    this.cspDirective = optionValue;
                    break;
                case UrlFilterRule.COOKIE_OPTION:
                    this._setUrlFilterRuleOption(UrlFilterRule.options.COOKIE_RULE, true);
                    this.cookieOption = new CookieOption(optionValue);
                    break;
                case UrlFilterRule.REDIRECT_OPTION: {
                    // In case if redirect source doesn't exists, throw error;
                    const redirectSource = adguard.rules.RedirectFilterService.hasRedirect(optionValue);
                    if (!redirectSource) {
                        throw new Error(`Unknown redirect source title: ${optionValue}`);
                    }
                    this._setUrlFilterRuleOption(UrlFilterRule.options.REDIRECT, true);
                    this.redirectOption = new RedirectOption(optionValue);
                    break;
                }
                case UrlFilterRule.REPLACE_OPTION:
                    // In case of .features or .features.responseContentFilteringSupported are not defined
                    const responseContentFilteringSupported = adguard.prefs.features
                        && adguard.prefs.features.responseContentFilteringSupported;
                    if (!responseContentFilteringSupported) {
                        throw new Error('Unknown option: REPLACE');
                    }
                    this._setUrlFilterRuleOption(UrlFilterRule.options.REPLACE, true);
                    this.replaceOption = new ReplaceOption(optionValue);
                    break;
                case UrlFilterRule.BADFILTER_OPTION:
                    this.badFilter = this.ruleText
                        .replace(UrlFilterRule.OPTIONS_DELIMITER + UrlFilterRule.BADFILTER_OPTION + api.FilterRule.COMA_DELIMITER, UrlFilterRule.OPTIONS_DELIMITER)
                        .replace(api.FilterRule.COMA_DELIMITER + UrlFilterRule.BADFILTER_OPTION, '')
                        .replace(UrlFilterRule.OPTIONS_DELIMITER + UrlFilterRule.BADFILTER_OPTION, '');
                    break;
                case UrlFilterRule.STEALTH_OPTION:
                    this._setUrlFilterRuleOption(UrlFilterRule.options.STEALTH, true);
                    break;
                default:
                    optionName = optionName.toUpperCase();

                    if (optionName in UrlFilterRule.contentTypes) {
                        this._appendPermittedContentType(UrlFilterRule.contentTypes[optionName]);
                    } else if (optionName[0] === api.FilterRule.NOT_MARK && optionName.substring(1) in UrlFilterRule.contentTypes) {
                        this._appendRestrictedContentType(UrlFilterRule.contentTypes[optionName.substring(1)]);
                    } else if (optionName in UrlFilterRule.ignoreOptions) {
                        // Ignore others
                    } else {
                        throw `Unknown option: ${optionName}`;
                    }
            }
        }

        /**
         * Rules of this types can be applied to documents only
         * for whitelist rules: $jsinject, $elemhide, $urlblock, $genericblock,
         * $generichide and $content
         * for url blocking: $popup
         */
        if (this.isOptionEnabled(UrlFilterRule.options.JSINJECT)
            || this.isOptionEnabled(UrlFilterRule.options.ELEMHIDE)
            || this.isOptionEnabled(UrlFilterRule.options.CONTENT)
            || this.isOptionEnabled(UrlFilterRule.options.URLBLOCK)
            || this.isOptionEnabled(UrlFilterRule.options.BLOCK_POPUPS)
            || this.isOptionEnabled(UrlFilterRule.options.GENERICBLOCK)
            || this.isOptionEnabled(UrlFilterRule.options.GENERICHIDE)) {
            this.permittedContentType = UrlFilterRule.contentTypes.DOCUMENT;
            this.documentLevelRule = true;
        }
    };

    /**
     * Appends new content type value to permitted list
     * (depending on the current permitted content types)
     *
     * @param contentType Content type to append
     */
    UrlFilterRule.prototype._appendPermittedContentType = function (contentType) {
        if (this.permittedContentType === UrlFilterRule.contentTypes.ALL) {
            this.permittedContentType = contentType;
        } else {
            this.permittedContentType |= contentType;
        }
    };

    /**
     * Appends new content type to restricted list
     * (depending on the current restricted content types)
     *
     * @param contentType Content type to append
     */
    UrlFilterRule.prototype._appendRestrictedContentType = function (contentType) {
        if (this.restrictedContentType === 0) {
            this.restrictedContentType = contentType;
        } else {
            this.restrictedContentType |= contentType;
        }
    };

    /**
     * Sets UrlFilterRuleOption
     *
     * @param option  Option
     * @param enabled Enabled or not
     */
    UrlFilterRule.prototype._setUrlFilterRuleOption = function (option, enabled) {
        if (enabled) {
            if (!this.whiteListRule && containsOption(UrlFilterRule.options.WHITELIST_OPTIONS, option)) {
                throw new Error(`${option} cannot be applied to this type of rule`);
            }

            if (this.enabledOptions === null) {
                this.enabledOptions = option;
            } else {
                this.enabledOptions |= option;
            }
        } else if (this.disabledOptions === null) {
            this.disabledOptions = option;
        } else {
            this.disabledOptions |= option;
        }
    };

    UrlFilterRule.OPTIONS_DELIMITER = '$';
    UrlFilterRule.DOMAIN_OPTION = 'domain';
    UrlFilterRule.THIRD_PARTY_OPTION = 'third-party';
    UrlFilterRule.MATCH_CASE_OPTION = 'match-case';
    UrlFilterRule.DOCUMENT_OPTION = 'document';
    UrlFilterRule.ELEMHIDE_OPTION = 'elemhide';
    UrlFilterRule.GENERICHIDE_OPTION = 'generichide';
    UrlFilterRule.URLBLOCK_OPTION = 'urlblock';
    UrlFilterRule.GENERICBLOCK_OPTION = 'genericblock';
    UrlFilterRule.JSINJECT_OPTION = 'jsinject';
    UrlFilterRule.CONTENT_OPTION = 'content';
    UrlFilterRule.POPUP_OPTION = 'popup';
    UrlFilterRule.IMPORTANT_OPTION = 'important';
    UrlFilterRule.MASK_REGEX_RULE = '/';
    UrlFilterRule.MASK_ANY_SYMBOL = '*';
    UrlFilterRule.ANY_URL_REGEX = /.*/;
    UrlFilterRule.EMPTY_OPTION = 'empty';
    // Extension doesn't support replace rules, $replace option is here only for correct parsing
    UrlFilterRule.REPLACE_OPTION = 'replace';
    // Extension doesn't support extension rules, $extension option is here only for correct parsing
    UrlFilterRule.EXTENSION_OPTION = 'extension';
    UrlFilterRule.CSP_OPTION = 'csp';
    UrlFilterRule.COOKIE_OPTION = 'cookie';
    UrlFilterRule.BADFILTER_OPTION = 'badfilter';
    UrlFilterRule.STEALTH_OPTION = 'stealth';
    UrlFilterRule.REDIRECT_OPTION = 'redirect';
    UrlFilterRule.XMLHTTPREQUEST_OPTION = 'xmlhttprequest';
    UrlFilterRule.STYLESHEET_OPTION = 'stylesheet';
    UrlFilterRule.SUBDOCUMENT_OPTION = 'subdocument';
    UrlFilterRule.PING_OPTION = 'ping';

    UrlFilterRule.contentTypes = {
        OTHER: 1 << 0,
        SCRIPT: 1 << 1,
        IMAGE: 1 << 2,
        STYLESHEET: 1 << 3,
        OBJECT: 1 << 4,
        SUBDOCUMENT: 1 << 5,
        XMLHTTPREQUEST: 1 << 6,
        MEDIA: 1 << 7,
        FONT: 1 << 8,
        WEBSOCKET: 1 << 9,
        WEBRTC: 1 << 10,
        DOCUMENT: 1 << 11,
        PING: 1 << 12,
    };

    UrlFilterRule.contentTypes.ALL = 0;
    for (const key in UrlFilterRule.contentTypes) {
        if (UrlFilterRule.contentTypes.hasOwnProperty(key)) {
            UrlFilterRule.contentTypes.ALL |= UrlFilterRule.contentTypes[key];
        }
    }

    /**
     * $cookie options that can be used in the cookie rule.
     *
     * See here for the details:
     * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/961
     */
    UrlFilterRule.cookieOptions = {
        MAX_AGE: 'maxAge',
        SAME_SITE: 'sameSite',
    };

    UrlFilterRule.options = {
        /**
         * $elemhide modifier.
         * it makes sense to use this parameter for exceptions only.
         * It prohibits element hiding rules on pages affected by the current rule.
         * Element hiding rules will be described below.
         */
        ELEMHIDE: 1 << 0,

        /**
         * limitation on third-party and own requests.
         * If the third-party parameter is used, the rule is applied only to requests
         * coming from external sources. Similarly, ~third-party restricts the rule
         * to requests from the same source that the page comes from. Lets use an example.
         * The ||domain.com$third-party rule is applied to all sites, except domain.com
         * itself. If we rewrite it as ||domain.com$~third-party, it will be applied
         * only to domain.com, but will not work on other sites.
         */
        THIRD_PARTY: 1 << 1,

        /**
         * If this option is enabled, Adguard won't apply generic CSS rules to the web page.
         */
        GENERICHIDE: 1 << 2,

        /**
         * If this option is enabled, Adguard won't apply generic UrlFilter rules to the web page.
         */
        GENERICBLOCK: 1 << 3,

        /**
         * it makes sense to use this parameter for exceptions only.
         * It prohibits the injection of javascript code to web pages.
         * Javascript code is added for blocking banners by size and for
         * the proper operation of Adguard Assistant
         */
        JSINJECT: 1 << 4,

        /**
         * It makes sense to use this parameter for exceptions only.
         * It prohibits the blocking of requests from pages
         * affected by the current rule.
         *
         * This attribute is only for exception rules. If true - do not use urlblocking rules
         * for urls where referrer satisfies this rule.
         */
        URLBLOCK: 1 << 5,

        /**
         * it makes sense to use this parameter for exceptions only.
         * It prohibits HTML filtration rules on pages affected by the current rule.
         * HTML filtration rules will be described below.
         */
        CONTENT: 1 << 6,

        /**
         * For any address matching a&nbsp;blocking rule with this option
         * Adguard will try to&nbsp;automatically close the browser tab.
         */
        BLOCK_POPUPS: 1 << 7,

        /**
         * defines a rule applied only to addresses with exact letter case matches.
         * For example, /BannerAd.gif$match-case will block http://example.com/BannerAd.gif,
         * but not http://example.com/bannerad.gif.
         * By default, the letter case is not matched.
         */
        MATCH_CASE: 1 << 8,

        /**
         * defines a CSP rule
         * For example, ||xpanama.net^$third-party,csp=connect-src 'none'
         */
        CSP_RULE: 1 << 9,

        /**
         * defines a Cookie rule
         * For example, ||example.com^$third-party,cookie=c_user
         */
        COOKIE_RULE: 1 << 10,

        /**
         * defines rules with $extension modifier
         * for example, @@||example.org^$extension
         */
        EXTENSION: 1 << 11,

        /**
         * defines rules with $replace modifier
         * for example, "||example.org^$replace=/replace-me/replacement/i"
         */
        REPLACE: 1 << 12,

        /**
         * defines rules with $stealth modifier
         * for example, "@@||example.com^$stealth"
         */
        STEALTH: 1 << 13,

        /**
         * defines rules with $redirect modifier
         * for example, "||example.com/someadd.js^$redirect=noopjs"
         */
        REDIRECT: 1 << 14,

        /**
         * defines rules with $document modifier
         * for example, "||example.org$document"
         */
        DOCUMENT: 1 << 15,
    };

    /**
     * These options can be applied to whitelist rules only
     */
    UrlFilterRule.options.WHITELIST_OPTIONS = UrlFilterRule.options.ELEMHIDE
        | UrlFilterRule.options.JSINJECT
        | UrlFilterRule.options.CONTENT
        | UrlFilterRule.options.GENERICHIDE
        | UrlFilterRule.options.GENERICBLOCK
        | UrlFilterRule.options.STEALTH;

    /**
     * These options define a document whitelisted rule
     */
    UrlFilterRule.options.DOCUMENT_WHITELIST = UrlFilterRule.options.ELEMHIDE
        | UrlFilterRule.options.URLBLOCK
        | UrlFilterRule.options.JSINJECT
        | UrlFilterRule.options.CONTENT;

    UrlFilterRule.ignoreOptions = {
        // Deprecated modifiers
        'BACKGROUND': true,
        '~BACKGROUND': true,
        // Unused modifiers
        'COLLAPSE': true,
        '~COLLAPSE': true,
        '~DOCUMENT': true,
        'EXTENSION': true,
        '~EXTENSION': true,
    };

    api.UrlFilterRule = UrlFilterRule;
})(adguard, adguard.rules);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (api) {
    'use strict';

    /**
     * Filter for Url filter rules.
     * Read here for details:
     * http://adguard.com/en/filterrules.html#baseRules
     */
    const UrlFilter = function (rules, badFilterRules) {
        this.basicRulesTable = new api.UrlFilterRuleLookupTable();
        this.badFilterRules = badFilterRules;

        if (rules) {
            for (let i = 0; i < rules.length; i += 1) {
                this.addRule(rules[i]);
            }
        }
    };

    UrlFilter.prototype = {

        /**
         * Adds rule to UrlFilter
         *
         * @param rule Rule object
         */
        addRule(rule) {
            this.basicRulesTable.addRule(rule);
        },

        /**
         * Removes rule from UrlFilter
         *
         * @param rule Rule to remove
         */
        removeRule(rule) {
            this.basicRulesTable.removeRule(rule);
        },

        /**
         * Searches for first rule matching specified request
         *
         * @param url           Request url
         * @param documentHost  Document host
         * @param requestType   Request content type (UrlFilterRule.contentTypes)
         * @param thirdParty    true if request is third-party
         * @param skipGenericRules    skip generic rules
         * @return matching rule or null if no match found
         */
        isFiltered(url, documentHost, requestType, thirdParty, skipGenericRules) {
            return this.basicRulesTable.findRule(url,
                documentHost,
                thirdParty,
                requestType,
                !skipGenericRules,
                this.badFilterRules);
        },

        /**
         * Returns the array of loaded rules
         */
        getRules() {
            return this.basicRulesTable.getRules();
        },
    };

    api.UrlFilter = UrlFilter;
})(adguard.rules);

(function (adguard, api) {

    'use strict';

    var ATTRIBUTE_START_MARK = '[';
    var ATTRIBUTE_END_MARK = ']';
    var QUOTES = '"';
    var TAG_CONTENT_MASK = 'tag-content';
    var WILDCARD_MASK = 'wildcard';
    var TAG_CONTENT_MAX_LENGTH = 'max-length';
    var TAG_CONTENT_MIN_LENGTH = 'min-length';
    var PARENT_ELEMENTS = 'parent-elements';
    var PARENT_SEARCH_LEVEL = 'parent-search-level';
    var DEFAULT_PARENT_SEARCH_LEVEL = 3;

    function Wildcard(pattern) {

        this.regexp = new RegExp(wildcardToRegex(pattern), 'i');
        this.shortcut = extractShortcut(pattern);

        /**
         * Converts wildcard to regular expression
         *
         * @param pattern The wildcard pattern to convert
         * @return A regex equivalent of the given wildcard
         */
        function wildcardToRegex(pattern) {

            var specials = [
                '\\', '*', '+', '?', '|', '{', '}', '[', ']', '(', ')', '^', '$', '.', '#'
            ];
            var specialsRegex = new RegExp('[' + specials.join('\\') + ']', 'g');
            pattern = pattern.replace(specialsRegex, '\\$&');

            pattern = adguard.utils.strings.replaceAll(pattern, '\\*', '[\\s\\S]*');
            pattern = adguard.utils.strings.replaceAll(pattern, '\\?', '.');
            return '^' + pattern + '$';
        }

        /**
         * Extracts longest string that does not contain * or ? symbols.
         *
         * @param pattern Wildcard pattern
         * @return Longest string without special symbols
         */
        function extractShortcut(pattern) {

            var wildcardChars = ['*', '?'];
            var startIndex = 0;
            var endIndex = adguard.utils.strings.indexOfAny(pattern, wildcardChars);

            if (endIndex < 0) {
                return pattern.toLowerCase();
            }

            var shortcut = endIndex === startIndex ? '' : pattern.substring(startIndex, endIndex - startIndex);

            while (endIndex >= 0) {

                startIndex = startIndex + endIndex + 1;
                if (pattern.length <= startIndex) {
                    break;
                }

                endIndex = adguard.utils.strings.indexOfAny(pattern.substring(startIndex), wildcardChars);
                var tmpShortcut = endIndex < 0 ? pattern.substring(startIndex) : pattern.substring(startIndex, endIndex + startIndex);

                if (tmpShortcut.length > shortcut.length) {
                    shortcut = tmpShortcut;
                }
            }

            return shortcut.toLowerCase();
        }

        /**
         * Returns 'true' if input text is matching wildcard.
         * This method first checking shortcut -- if shortcut exists in input string -- than it checks regexp.
         *
         * @param input Input string
         * @return true if input string matches wildcard
         */
        this.matches = function (input) {

            if (!input) {
                return false;
            }

            if (input.toLowerCase().indexOf(this.shortcut) < 0) {
                return false;
            }

            return this.regexp.test(input);
        }
    }

    function getQuoteIndex(text, startIndex) {

        var nextChar = '"';
        var quoteIndex = startIndex - 2;

        while (nextChar === '"') {
            quoteIndex = text.indexOf(QUOTES, quoteIndex + 2);
            if (quoteIndex === -1) {
                return -1;
            }
            nextChar = text.length === (quoteIndex + 1) ? '0' : text.charAt(quoteIndex + 1);
        }

        return quoteIndex;
    }

    /**
     * Creates an instance of the ContentFilterRule from its text format
     */
    var ContentFilterRule = function (ruleText, filterId) {

        api.FilterRule.call(this, ruleText, filterId);

        this.parentSearchLevel = DEFAULT_PARENT_SEARCH_LEVEL;
        this.maxLength = 8192;

        var mask = api.FilterRule.MASK_CONTENT_EXCEPTION_RULE;
        var indexOfMask = ruleText.indexOf(mask);
        if (indexOfMask >= 0) {
            this.whiteListRule = true;
        } else {
            mask = api.FilterRule.MASK_CONTENT_RULE;
            indexOfMask = ruleText.indexOf(mask);
        }

        if (indexOfMask < 0) {
            throw 'Invalid rule ' + ruleText;
        }

        this.elementsFilter = ruleText.substring(indexOfMask + mask.length);
        var ruleStartIndex = ruleText.indexOf(ATTRIBUTE_START_MARK);

        // Cutting tag name from string
        if (ruleStartIndex === -1) {
            this.tagName = ruleText.substring(indexOfMask + mask.length);
        } else {
            this.tagName = ruleText.substring(indexOfMask + mask.length, ruleStartIndex);
        }

        // Loading domains (if any))
        if (indexOfMask > 0) {
            var domains = ruleText.substring(0, indexOfMask);
            this.loadDomains(domains);
        }

        if (!this.whiteListRule && this.isGeneric()) {
            throw 'Content rule must have at least one permitted domain';
        }

        var selector = [this.tagName];

        // Loading attributes filter
        while (ruleStartIndex !== -1) {
            var equalityIndex = ruleText.indexOf(api.FilterRule.EQUAL, ruleStartIndex + 1);
            var quoteStartIndex = ruleText.indexOf(QUOTES, equalityIndex + 1);
            var quoteEndIndex = getQuoteIndex(ruleText, quoteStartIndex + 1);
            if (quoteStartIndex === -1 || quoteEndIndex === -1) {
                break;
            }
            var ruleEndIndex = ruleText.indexOf(ATTRIBUTE_END_MARK, quoteEndIndex + 1);

            var attributeName = ruleText.substring(ruleStartIndex + 1, equalityIndex);
            var attributeValue = ruleText.substring(quoteStartIndex + 1, quoteEndIndex);
            attributeValue = adguard.utils.strings.replaceAll(attributeValue, '""', '"');

            switch (attributeName) {
                case TAG_CONTENT_MASK:
                    this.tagContentFilter = attributeValue;
                    break;
                case WILDCARD_MASK:
                    this.wildcard = new Wildcard(attributeValue);
                    break;
                case TAG_CONTENT_MAX_LENGTH:
                    this.maxLength = parseInt(attributeValue);
                    break;
                case TAG_CONTENT_MIN_LENGTH:
                    this.minLength = parseInt(attributeValue);
                    break;
                case PARENT_ELEMENTS:
                    this.parentElements = attributeValue.split(',');
                    break;
                case PARENT_SEARCH_LEVEL:
                    this.parentSearchLevel = parseInt(attributeValue);
                    break;
                default:
                    selector.push('[');
                    selector.push(attributeName);
                    selector.push('*="');
                    selector.push(attributeValue);
                    selector.push('"]');
                    break;
            }

            if (ruleEndIndex === -1) {
                break;
            }
            ruleStartIndex = ruleText.indexOf(ATTRIBUTE_START_MARK, ruleEndIndex + 1);
        }

        this.selector = selector.join('');

        // Validates selector immediately
        window.document.querySelectorAll(this.selector);
    };

    ContentFilterRule.prototype = Object.create(api.FilterRule.prototype);

    ContentFilterRule.prototype.getMatchedElements = function (document) {

        var elements = document.querySelectorAll(this.selector);

        var result = null;

        for (var i = 0; i < elements.length; i++) {

            var element = elements[i];

            var elementToDelete = null;

            if (this.isFiltered(element)) {

                if (this.parentElements) {
                    var parentElement = this.searchForParentElement(element);
                    if (parentElement) {
                        elementToDelete = parentElement;
                    }
                } else {
                    elementToDelete = element;
                }

                if (elementToDelete) {
                    if (result === null) {
                        result = [];
                    }
                    result.push(element);
                }
            }
        }

        return result;
    };

    /**
     * Checks if HtmlElement is filtered by this content filter.
     *
     * @param element Evaluated element
     * @return true if element should be filtered
     */
    ContentFilterRule.prototype.isFiltered = function (element) {

        // Checking tag content length limits
        var content = element.innerHTML || '';
        if (this.maxLength > 0) {
            // If max-length is set - checking content length (it should be lesser than max length)
            if (content.length > this.maxLength) {
                return false;
            }
        }

        if (this.minLength > 0) {
            // If min-length is set - checking content length (it should be greater than min length)
            if (content.length < this.minLength) {
                return false;
            }
        }

        if (!this.tagContentFilter && !this.wildcard) {
            // Rule does not depend on content
            return true;
        }

        if (!content) {
            return false;
        }

        // Checking tag content against filter
        if (this.tagContentFilter && content.indexOf(this.tagContentFilter) < 0) {
            return false;
        }

        // Checking tag content against the wildcard
        if (this.wildcard && !this.wildcard.matches(content)) {
            return false;
        }

        // All filters are passed, tag is filtered
        return true;
    };

    /**
     * Searches for parent element to delete.
     * Suitable parent elements are set by 'parent-elements' attribute.
     * If suitable element found - returns it. Otherwise - returns null.
     *
     * @param element Element evaluated against this rule
     * @return Parent element to be deleted
     */
    ContentFilterRule.prototype.searchForParentElement = function (element) {

        if (!this.parentElements || this.parentElements.length === 0) {
            return null;
        }

        var parentElement = element.parentNode;

        for (var i = 0; i < this.parentSearchLevel; i++) {
            if (!parentElement) {
                return null;
            }
            if (this.parentElements.indexOf(parentElement.tagName.toLowerCase()) > 0) {
                return parentElement;
            }
            parentElement = parentElement.parentNode;
        }

        return null;
    };

    /**
     * All content rules markers start with this character
     */
    ContentFilterRule.RULE_MARKER_FIRST_CHAR = '$';

    /**
     * Content rule markers
     */
    ContentFilterRule.RULE_MARKERS = [
        api.FilterRule.MASK_CONTENT_EXCEPTION_RULE,
        api.FilterRule.MASK_CONTENT_RULE
    ];

    api.ContentFilterRule = ContentFilterRule;
    api.Wildcard = Wildcard;

})(adguard, adguard.rules);
/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (adguard, api) {

    'use strict';

    /**
     * Simple MultiMap implementation
     * @constructor
     */
    var MultiMap = function () {

        this.map = Object.create(null);
        this.size = 0;

        this.put = function (key, value) {
            var values = this.map[key];
            if (!values) {
                this.map[key] = values = [];
                this.size++;
            }
            values.push(value);
        };

        this.remove = function (key, value) {
            var values = this.map[key];
            if (!values) {
                return;
            }
            adguard.utils.collections.removeRule(values, value);
            if (values.length === 0) {
                delete this.map[key];
                this.size--;
            }
        };

        this.get = function (key) {
            return this.map[key];
        };

        this.clear = function () {
            this.map = Object.create(null);
        };

        this.isEmpty = function () {
            return this.size === 0;
        };
    };

    /**
     * Filter that applies content rules
     */
    var ContentFilter = function (rules) {

        this.contentRules = [];
        this.exceptionRulesMap = new MultiMap();
        this.dirty = false;

        if (rules) {
            for (var i = 0; i < rules.length; i++) {
                this.addRule(rules[i]);
            }
        }
    };

    ContentFilter.prototype = {

        /**
         * Adds new rule to ContentFilter
         *
         * @param rule Rule to add
         */
        addRule: function (rule) {

            if (!rule.tagName) {
                // Ignore invalid rules
                return;
            }

            if (rule.whiteListRule) {
                this.exceptionRulesMap.put(rule.elementsFilter, rule);
            } else {
                this.contentRules.push(rule);
            }

            this.dirty = true;
        },

        /**
         * Removes rule from the ContentFilter
         *
         * @param rule Rule to remove
         */
        removeRule: function (rule) {
            adguard.utils.collections.removeRule(this.contentRules, rule);
            this.exceptionRulesMap.remove(rule.elementsFilter, rule);
            this.rollbackExceptionRule(rule);
            this.dirty = true;
        },

        /**
         * Searches for the content rules
         *
         * @param domainName Domain
         * @returns Collection of the content rules or null
         */
        getRulesForDomain: function (domainName) {

            if (this.dirty) {
                this.rebuild();
            }

            var result = null;

            for (var i = 0; i < this.contentRules.length; i++) {
                var rule = this.contentRules[i];
                if (rule.isPermitted(domainName)) {
                    if (result === null) {
                        result = [];
                    }
                    result.push(rule);
                }
            }

            return result;
        },

        /**
         * Searches for elements in document that matches given content rules
         * @param doc Document
         * @param rules Content rules
         * @returns Matched elements
         */
        getMatchedElementsForRules: function (doc, rules) {

            if (!rules || rules.length === 0) {
                return null;
            }

            var result = null;

            for (var i = 0; i < rules.length; i++) {
                var rule = rules[i];
                var elements = rule.getMatchedElements(doc);
                if (elements && elements.length > 0) {
                    if (result === null) {
                        result = [];
                    }
                    result = result.concat(elements);
                }
            }

            return result;
        },

        /**
         * Searches for elements in document that matches content rules for the specified domain
         * @param doc Document
         * @param domainName Domain
         * @returns Matched elements
         */
        getMatchedElements: function (doc, domainName) {

            if (this.dirty) {
                this.rebuild();
            }

            var rules = this.getRulesForDomain(domainName);
            if (rules) {
                return this.getMatchedElementsForRules(doc, rules);
            }
            return null;
        },

        /**
         * Rebuilds content filter and re-applies exceptions rules
         */
        rebuild: function () {
            if (!this.dirty) {
                return;
            }

            if (!this.exceptionRulesMap.isEmpty()) {
                for (var i = 0; i < this.contentRules.length; i++) {
                    this.applyExceptionRules(this.contentRules[i]);
                }
            }
            this.dirty = false;
        },

        /**
         * Finds exception rules corresponding to this rule and applies them.
         *
         * @param rule Regular script rule
         */
        applyExceptionRules: function (rule) {

            var exceptionRules = this.exceptionRulesMap.get(rule.elementsFilter);

            if (exceptionRules) {
                for (var i = 0; i < exceptionRules.length; i++) {
                    var exceptionRule = exceptionRules[i];
                    this.applyExceptionRule(rule, exceptionRule);
                }
            }
        },

        /**
         * Tries to apply specified exception rule to a regular rule.
         *
         * @param rule          Regular rule
         * @param exceptionRule Exception rule
         */
        applyExceptionRule: function (rule, exceptionRule) {
            // If cannot be applied - exiting
            if (rule.elementsFilter !== exceptionRule.elementsFilter) {
                return;
            }

            // Permitted domains from exception rule --> restricted domains in common rule
            rule.addRestrictedDomains(exceptionRule.getPermittedDomains());
        },

        /**
         * Rolls back specified exception rule
         *
         * @param exceptionRule Exception rule to rollback
         */
        rollbackExceptionRule: function (exceptionRule) {

            if (!exceptionRule.whiteListRule) {
                return;
            }

            for (var i = 0; i < this.contentRules.length; i++) {
                var rule = this.contentRules[i];
                if (rule.elementsFilter === exceptionRule.elementsFilter) {
                    rule.removeRestrictedDomains(exceptionRule.getPermittedDomains());
                }
            }
        }
    };

    api.ContentFilter = ContentFilter;

})(adguard, adguard.rules);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */
(function (adguard, api) {

    'use strict';

    /**
     * Returns rule priority
     * @param rule CSP rule
     */
    function getRulePriority(rule) {
        if (!rule) {
            return 0;
        }
        if (rule.whiteListRule && rule.isImportant) {
            return 4;
        } else if (rule.isImportant) {
            return 3;
        } else if (rule.whiteListRule) {
            return 2;
        }
        return 1;
    }

    /**
     * Decides which rule should be put into the given map.
     * Compares priorities of the two given rules with the equal CSP directive and the rule that may already in the map.
     *
     * @param rule CSP rule (not null)
     * @param whiteListRule CSP whitelist rule (may be null)
     * @param map Rules mapped by csp directive
     */
    function putWithPriority(rule, whiteListRule, map) {

        var cspDirective = rule.cspDirective;
        var existRule = map[cspDirective];

        var pr1 = getRulePriority(rule);
        var pr2 = getRulePriority(whiteListRule);
        var pr3 = getRulePriority(existRule);

        var max = Math.max(pr1, pr2, pr3);
        if (max === pr1) {
            map[cspDirective] = rule;
        } else if (max === pr2) {
            map[cspDirective] = whiteListRule;
        } else if (max === pr3) {
            map[cspDirective] = existRule;
        }
    }

    /**
     * Filter for CSP filter rules
     * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/685
     */
    api.CspFilter = function (rules, badFilterRules) {

        var cspWhiteFilter = new api.UrlFilterRuleLookupTable();
        var cspBlockFilter = new api.UrlFilterRuleLookupTable();

        /**
         * Add rules to CSP filter
         * @param rules Collection of $csp rules
         */
        function addRules(rules) {
            for (var i = 0; i < rules.length; i++) {
                addRule(rules[i]);
            }
        }

        /**
         * Add rule to CSP filter
         * @param rule Rule object
         */
        function addRule(rule) {
            if (rule.whiteListRule) {
                cspWhiteFilter.addRule(rule);
            } else {
                cspBlockFilter.addRule(rule);
            }
        }

        /**
         * Removes from CSP filter
         * @param rule Rule to remove
         */
        function removeRule(rule) {
            if (rule.whiteListRule) {
                cspWhiteFilter.removeRule(rule);
            } else {
                cspBlockFilter.removeRule(rule);
            }
        }

        function getRules() {
            var rules = cspWhiteFilter.getRules();
            return rules.concat(cspBlockFilter.getRules());
        }

        /**
         * Searches for CSP rules matching specified request.
         * It worth noting that all (blocked and whitelisted!) CSP rules will be returned: client should select which CSP rules will be added to headers.
         * @param url URL
         * @param documentHost Document Host
         * @param thirdParty true if request is third-party
         * @param requestType   Request content type. $CSP rules are applied only at DOCUMENT or SUB_DOCUMENT levels.
         * @returns Matching rules
         */
        function findCspRules(url, documentHost, thirdParty, requestType) {

            /**
             * CSP rules support only $SUBDOCUMENT and $DOCUMENT request type modifiers.
             * If it presents, we should match this rule when an iframe is loaded.
             * If a main_frame is loaded we should match rules without $SUBDOCUMENT modifier (or with negation $~SUBDOCUMENT)
             * So if we pass `adguard.RequestTypes.OTHER` we won't match rules with $SUBDOCUMENT modifier, as we expected
             *
             * For example:
             * rule1 = '||$csp'
             * rule2 = '||$csp,subdocument'
             * rule3 = '||$csp,~subdocument'
             * findCspRules(adguard.RequestTypes.SUBDOCUMENT) = [rule1, rule2];
             * findCspRules(adguard.RequestTypes.DOCUMENT) = [rule1, rule3];
             * view test "CSP rules are found correctly"
             */
            if (requestType !== adguard.RequestTypes.DOCUMENT
                && requestType !== adguard.RequestTypes.SUBDOCUMENT) {
                requestType = adguard.RequestTypes.OTHER;
            }

            var whiteRules = cspWhiteFilter.findRules(url, documentHost, thirdParty, requestType, badFilterRules);

            var whitelistedRulesByDirective = Object.create(null);

            var i, rule;

            // Collect whitelisted CSP rules
            if (whiteRules) {
                for (i = 0; i < whiteRules.length; i++) {
                    rule = whiteRules[i];
                    if (!rule.cspDirective) { // Global whitelist rule
                        return [rule];
                    }
                    putWithPriority(rule, null, whitelistedRulesByDirective);
                }
            }

            var blockingRules = cspBlockFilter.findRules(url, documentHost, thirdParty, requestType, badFilterRules);

            var rulesByDirective = Object.create(null);

            // Collect whitelist and blocking CSP rules in one array
            if (blockingRules) {

                for (i = 0; i < blockingRules.length; i++) {
                    rule = blockingRules[i];
                    var whiteListRule = whitelistedRulesByDirective[rule.cspDirective];
                    putWithPriority(rule, whiteListRule, rulesByDirective);
                }
            }

            var cspRules = [];
            Object.keys(rulesByDirective).forEach(function (key) {
                cspRules.push(rulesByDirective[key]);
            });
            return cspRules;
        }

        if (rules) {
            addRules(rules);
        }

        return {
            addRules: addRules,
            addRule: addRule,
            removeRule: removeRule,
            getRules: getRules,
            findCspRules: findCspRules
        };
    };

    api.CspFilter.DEFAULT_DIRECTIVE = 'connect-src http: https:; frame-src http: https:; child-src http: https:';

})(adguard, adguard.rules);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (adguard, api) {
    'use strict';

    /**
     * Filter for cookie filter rules
     * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/961
     */
    api.CookieFilter = function (rules) {
        const cookieWhiteFilter = new api.UrlFilterRuleLookupTable();
        const cookieBlockFilter = new api.UrlFilterRuleLookupTable();

        /**
         * Add rule to filter
         * @param rule Rule object
         */
        function addRule(rule) {
            if (rule.whiteListRule) {
                cookieWhiteFilter.addRule(rule);
            } else {
                cookieBlockFilter.addRule(rule);
            }
        }

        /**
         * Add rules to filter
         * @param rules Collection of rules
         */
        function addRules(rules) {
            for (let i = 0; i < rules.length; i += 1) {
                addRule(rules[i]);
            }
        }

        /**
         * Removes from filter
         * @param rule Rule to remove
         */
        function removeRule(rule) {
            if (rule.whiteListRule) {
                cookieWhiteFilter.removeRule(rule);
            } else {
                cookieBlockFilter.removeRule(rule);
            }
        }

        /**
         * All rules in filter
         *
         * @returns {*|Array.<T>|string|Buffer}
         */
        function getRules() {
            const rules = cookieWhiteFilter.getRules();
            return rules.concat(cookieBlockFilter.getRules());
        }

        /**
         * Finds exception rule for blocking rule
         *
         * @param {object} blockRule Blocking rule
         * @param {Array} whiteListRules Whitelist rules
         * @return {object} Found whitelist rule or null
         */
        function findWhiteListRule(blockRule, whiteListRules) {
            for (let i = 0; i < whiteListRules.length; i += 1) {
                const whiteRule = whiteListRules[i];
                const whiteCookieOption = whiteRule.getCookieOption();

                const blockCookieOption = blockRule.getCookieOption();
                const blockCookieName = blockCookieOption.cookieName;
                const blockCookieRegex = blockCookieOption.regex;

                // Matches by cookie name
                if (whiteCookieOption.matches(blockCookieName)) {
                    return whiteRule;
                }

                // Rules have the same regex
                if (blockCookieRegex && whiteCookieOption.regex
                    && String(blockCookieRegex) === String(whiteCookieOption.regex)) {
                    return whiteRule;
                }

                // Blocking rule with empty $cookie option value will be unblocked by @@$cookie rule
            }

            return null;
        }

        /**
         * Searches for rules matching specified request.
         *
         * @param url           URL
         * @param documentHost  Document Host
         * @param thirdParty    true if request is third-party
         * @param requestType   Request content type
         * @returns             Matching rules
         */
        function findCookieRules(url, documentHost, thirdParty, requestType) {
            const blockRules = cookieBlockFilter.findRules(url, documentHost, thirdParty, requestType);
            if (!blockRules || blockRules.length === 0) {
                return null;
            }

            const whiteRules = cookieWhiteFilter.findRules(url, documentHost, thirdParty, requestType);
            if (!whiteRules || whiteRules.length === 0) {
                return blockRules;
            }

            // Try to find whitelist rule with empty $cookie option => unblock all
            const commonWhiteRule = whiteRules.filter(r => r.getCookieOption().isEmpty())[0];
            if (commonWhiteRule) {
                return [commonWhiteRule];
            }

            const rulesToApply = blockRules.map((blockRule) => {
                const whiteRule = findWhiteListRule(blockRule, whiteRules);
                return whiteRule || blockRule;
            });
            return rulesToApply.length > 0 ? rulesToApply : null;
        }

        if (rules) {
            addRules(rules);
        }

        return {
            addRules,
            addRule,
            removeRule,
            getRules,
            findCookieRules,
        };
    };
})(adguard, adguard.rules);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/* global adguard, Redirects */

(function (adguard, api) {
    'use strict';

    let redirects;

    api.RedirectFilterService = (function RedirectFilterService() {
        function setRedirectSources(rawYaml) {
            redirects = new Redirects(rawYaml);
        }

        function buildRedirectUrl(title) {
            if (!title) {
                return null;
            }

            const redirectSource = redirects.getRedirect(title);
            if (!redirectSource) {
                adguard.console.debug(`There is no redirect source with title: "${title}"`);
                return null;
            }
            let { content, contentType } = redirectSource;
            // if contentType does not include "base64" string we convert it to base64
            const BASE_64 = 'base64';
            if (!contentType.includes(BASE_64)) {
                content = window.btoa(content);
                contentType = `${contentType};${BASE_64}`;
            }

            return `data:${contentType},${content}`;
        }

        function hasRedirect(title) {
            return !!redirects.getRedirect(title);
        }

        return {
            setRedirectSources,
            hasRedirect,
            buildRedirectUrl,
        };
    })();
})(adguard, adguard.rules);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (adguard, api) {
    /**
     * Filter for replace filter rules
     * @param rules
     * @param badFilterRules
     * @constructor
     */
    api.ReplaceFilter = function (rules, badFilterRules) {
        const replaceWhiteFilter = new api.UrlFilterRuleLookupTable();
        const replaceBlockFilter = new api.UrlFilterRuleLookupTable();

        /**
         * Add rule to replace filter
         * @param rule Rule object
         */
        function addRule(rule) {
            if (rule.whiteListRule) {
                replaceWhiteFilter.addRule(rule);
            } else {
                replaceBlockFilter.addRule(rule);
            }
        }

        /**
         * Add rules to replace filter
         * @param rules Array of rules
         */
        function addRules(rules) {
            for (let i = 0; i < rules.length; i += 1) {
                const rule = rules[i];
                addRule(rule);
            }
        }

        /**
         * Remove rule from replace filter
         * @param rule Rule object
         */
        function removeRule(rule) {
            if (rule.whiteListRule) {
                replaceWhiteFilter.removeRule(rule);
            } else {
                replaceWhiteFilter.removeRule(rule);
            }
        }

        /**
         * Returns rules from replace filter
         * @returns {Array} array of rules
         */
        function getRules() {
            const whiteRules = replaceWhiteFilter.getRules();
            const blockRules = replaceBlockFilter.getRules();
            return whiteRules.concat(blockRules);
        }

        /**
         * Returns suitable white rule from the list of rules
         * @param whiteRules list of white rules
         * @param blockRule block rule
         * @returns {?object} suitable whiteRule or null
         */
        const getWhitelistingRule = (whiteRules, blockRule) => {
            for (let i = 0; i < whiteRules.length; i += 1) {
                const whiteRule = whiteRules[i];
                if (whiteRule.replaceOption.optionText === blockRule.replaceOption.optionText) {
                    return whiteRule;
                }
            }
            return null;
        };

        /**
         * Function returns filtered replace block rules
         * @param url
         * @param documentHost
         * @param thirdParty
         * @param requestType
         * @returns {?Array} array of filtered replace blockRules or null
         */
        function findReplaceRules(url, documentHost, thirdParty, requestType) {
            const blockRules = replaceBlockFilter.findRules(url, documentHost, thirdParty, requestType, badFilterRules);

            if (!blockRules) {
                return null;
            }

            const whiteRules = replaceWhiteFilter.findRules(url, documentHost, thirdParty, requestType, badFilterRules);
            if (!whiteRules) {
                return blockRules;
            }

            if (whiteRules.length > 0) {
                const whiteRulesWithEmptyOptionText = whiteRules.filter(whiteRule => whiteRule.replaceOption.optionText === '');

                // @@||example.org^$replace will disable all $replace rules matching ||example.org^.
                if (whiteRulesWithEmptyOptionText.length > 0) {
                    // return first matched rule
                    return whiteRulesWithEmptyOptionText.slice(0, 1);
                }

                const foundReplaceRules = [];
                blockRules.forEach((blockRule) => {
                    const whitelistingRule = getWhitelistingRule(whiteRules, blockRule);
                    if (whitelistingRule) {
                        foundReplaceRules.push(whitelistingRule);
                    } else {
                        foundReplaceRules.push(blockRule);
                    }
                });
                return foundReplaceRules;
            }

            return blockRules.length > 0 ? blockRules : null;
        }

        if (rules) {
            addRules(rules);
        }

        return {
            addRules: addRules,
            addRule: addRule,
            removeRule: removeRule,
            getRules: getRules,
            findReplaceRules: findReplaceRules,
        };
    };
})(adguard, adguard.rules);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (adguard, api) {
    'use strict';

    /**
     * Filters unsupported rules from third-party sources
     *
     * @param ruleText
     */
    const filterUnsupportedRules = function (ruleText) {
        // uBO HTML filters
        if (ruleText.includes('##^')) {
            return false;
        }
        return true;
    };

    /**
     * Filters untrusted rules from custom filters
     *
     * @param ruleText
     */
    const isUntrustedRule = function (ruleText) {
        if (ruleText.includes(api.FilterRule.MASK_SCRIPT_RULE)) {
            return true;
        }

        const optionsDelimiterIndex = ruleText.indexOf(api.UrlFilterRule.OPTIONS_DELIMITER);
        if (optionsDelimiterIndex >= 0) {
            const replaceOptionIndex = ruleText.indexOf(`${api.UrlFilterRule.REPLACE_OPTION}=`);
            if (replaceOptionIndex > optionsDelimiterIndex) {
                return true;
            }
        }

        return false;
    };

    /**
     * Checks if rule length is less than minimum rule length.
     * Rules with length less than 4 are ignored
     * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1600
     * @param ruleText
     * @returns {boolean}
     */
    const isRuleTooSmall = function (ruleText) {
        const MIN_RULE_LENGTH = 4;
        return ruleText.length < MIN_RULE_LENGTH;
    };

    /**
     * Method that parses rule text and creates object of a suitable class.
     *
     * @param {string} ruleText Rule text
     * @param {number} filterId Filter identifier
     * @param {boolean} isTrustedFilter - custom filter can be trusted and untrusted, default is true
     * @returns Filter rule object. Either UrlFilterRule or CssFilterRule or ScriptFilterRule.
     */
    const _createRule = function (ruleText, filterId, isTrustedFilter) {
        ruleText = ruleText ? ruleText.trim() : null;
        if (!ruleText) {
            return null;
        }

        try {
            const StringUtils = adguard.utils.strings;

            if (StringUtils.startWith(ruleText, api.FilterRule.COMMENT)) {
                return null;
            }

            if (isRuleTooSmall(ruleText)) {
                return null;
            }

            if (!filterUnsupportedRules(ruleText)) {
                return null;
            }

            if (!isTrustedFilter && isUntrustedRule(ruleText)) {
                return null;
            }

            if (StringUtils.startWith(ruleText, api.FilterRule.MASK_WHITE_LIST)) {
                return new api.UrlFilterRule(ruleText, filterId);
            }

            if (api.FilterRule.findRuleMarker(ruleText, api.ContentFilterRule.RULE_MARKERS, api.ContentFilterRule.RULE_MARKER_FIRST_CHAR)) {
                const responseContentFilteringSupported = adguard.prefs.features && adguard.prefs.features.responseContentFilteringSupported;
                if (!responseContentFilteringSupported) {
                    return null;
                }
                return new api.ContentFilterRule(ruleText, filterId);
            }

            if (api.FilterRule.findRuleMarker(ruleText, api.CssFilterRule.RULE_MARKERS, api.CssFilterRule.RULE_MARKER_FIRST_CHAR)) {
                return new api.CssFilterRule(ruleText, filterId);
            }

            if (api.FilterRule.findRuleMarker(ruleText, api.ScriptFilterRule.RULE_MARKERS, api.ScriptFilterRule.RULE_MARKER_FIRST_CHAR)) {
                if (api.ScriptletRule.isAdguardScriptletRule(ruleText)) {
                    return new api.ScriptletRule(ruleText, filterId);
                }

                return new api.ScriptFilterRule(ruleText, filterId);
            }

            return new api.UrlFilterRule(ruleText, filterId);
        } catch (ex) {
            adguard.console.debug('Cannot create rule from filter {0}: {1}, cause {2}', filterId || 0, ruleText, ex);
        }

        return null;
    };

    /**
     * Convert rules to AdGuard syntax and create rule
     *
     * @param {string} ruleText Rule text
     * @param {number} filterId Filter identifier
     * @param {boolean} isTrustedFilter - custom filter can be trusted and untrusted,
     * default is true
     * @returns Filter rule object. Either UrlFilterRule or CssFilterRule or ScriptFilterRule.
     */
    const createRule = (ruleText, filterId, isTrustedFilter = true) => {
        let conversionResult;
        try {
            conversionResult = api.ruleConverter.convertRule(ruleText);
        } catch (ex) {
            adguard.console.debug('Cannot convert rule from filter {0}: {1}, cause {2}', filterId || 0, ruleText, ex);
        }
        if (!conversionResult) {
            return null;
        }
        if (Array.isArray(conversionResult)) {
            const rules = conversionResult
                .map(rt => _createRule(rt, filterId, isTrustedFilter))
                .filter(rule => rule !== null);
            // composite rule shouldn't be with without rules inside it
            if (rules.length === 0) {
                return null;
            }
            return new api.CompositeRule(ruleText, rules);
        }
        const rule = _createRule(conversionResult, filterId, isTrustedFilter);
        if (rule && conversionResult !== ruleText) {
            rule.ruleText = ruleText;
            rule.convertedRuleText = conversionResult;
        }
        return rule;
    };

    api.builder = { createRule };
})(adguard, adguard.rules);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (adguard, api) {
    const stringUtils = adguard.utils.strings;

    /**
     * AdGuard scriptlet rule mask
     */
    const ADG_SCRIPTLET_MASK = '//scriptlet';

    /**
     * Helper to accumulate an array of strings char by char
     */
    function wordSaver() {
        let str = '';
        const strs = [];
        const saveSymb = s => str += s;
        const saveStr = () => {
            strs.push(str);
            str = '';
        };
        const getAll = () => [...strs];
        return { saveSymb, saveStr, getAll };
    }

    /**
     * Iterate over iterable argument and evaluate current state with transitions
     * @param {string} init first transition name
     * @param {Array|Collection|string} iterable
     * @param {Object} transitions transtion functions
     * @param {any} args arguments which should be passed to transition functions
     */
    function iterateWithTransitions(iterable, transitions, init, args) {
        let state = init || Object.keys(transitions)[0];
        for (let i = 0; i < iterable.length; i++) {
            state = transitions[state](iterable, i, args);
        }
        return state;
    }

    /**
     * Parse and validate scriptlet rule
     * @param {*} ruleText
     * @returns {{name: string, args: Array<string>}}
     */
    function parseRule(ruleText) {
        ruleText = stringUtils.substringAfter(ruleText, ADG_SCRIPTLET_MASK);
        /**
         * Transition names
         */
        const TRANSITION = {
            OPENED: 'opened',
            PARAM: 'param',
            CLOSED: 'closed',
        };

        /**
         * Transition function: the current index position in start, end or between params
         * @param {string} rule
         * @param {number} index
         * @param {Object} Object
         * @property {Object} Object.sep contains prop symb with current separator char
         */
        const opened = (rule, index, { sep }) => {
            const char = rule[index];
            switch (char) {
                case ' ':
                case '(':
                case ',':
                    return TRANSITION.OPENED;
                case '\'':
                case '"':
                    sep.symb = char;
                    return TRANSITION.PARAM;
                case ')':
                    return index === rule.length - 1
                        ? TRANSITION.CLOSED
                        : TRANSITION.OPENED;
            }
        };
        /**
         * Transition function: the current index position inside param
         * @param {string} rule
         * @param {number} index
         * @param {Object} Object
         * @property {Object} Object.sep contains prop `symb` with current separator char
         * @property {Object} Object.saver helper which allow to save strings by car by char
         */
        const param = (rule, index, { saver, sep }) => {
            const char = rule[index];
            switch (char) {
                case '\'':
                case '"':
                    const before = rule[index - 1];
                    if (char === sep.symb && before !== '\\') {
                        sep.symb = null;
                        saver.saveStr();
                        return TRANSITION.OPENED;
                    }
                default:
                    saver.saveSymb(char);
                    return TRANSITION.PARAM;
            }
        };
        const transitions = {
            [TRANSITION.OPENED]: opened,
            [TRANSITION.PARAM]: param,
            [TRANSITION.CLOSED]: () => { },
        };
        const sep = { symb: null };
        const saver = wordSaver();
        const state = iterateWithTransitions(ruleText, transitions, TRANSITION.OPENED, { sep, saver });
        if (state !== 'closed') {
            throw new Error(`Invalid scriptlet rule ${ruleText}`);
        }

        const args = saver.getAll();
        return {
            name: args[0],
            args: args.slice(1),
        };
    }

    const getScriptletCode = (params) => {
        const {
            name, args, ruleText, domainName, engine, version, debug,
        } = params;
        if (!scriptlets) { // eslint-disable-line no-undef
            return null;
        }
        const scriptletParam = {
            name, args, ruleText, domainName, engine, version,
        };

        if (debug) {
            scriptletParam.verbose = true;
        }
        /* eslint-enable no-unused-expressions, no-console */
        return scriptlets.invoke(scriptletParam); // eslint-disable-line no-undef
    };


    /**
     * JS Scriplet rule constructor
     * @constructor ScriptletRule
     * @property {string} ruleText
     * @property {number|string} filterId
     */
    function ScriptletRule(ruleText, filterId) {
        this.ruleText = ruleText;
        this.filterId = filterId;
        // Scriptlet rules are marked as "local" because the scriptlets code is built-in
        // the extension
        // See "lib/filter/rules/scriptlets/scriptlets.js" for the details
        this.scriptSource = 'local';
        this.whiteListRule = ruleText.includes(api.FilterRule.MASK_SCRIPT_EXCEPTION_RULE);
        const mask = this.whiteListRule
            ? api.FilterRule.MASK_SCRIPT_EXCEPTION_RULE
            : api.FilterRule.MASK_SCRIPT_RULE;
        const domain = stringUtils.substringBefore(ruleText, mask);
        domain && this.loadDomains(domain);
        this.ruleContent = stringUtils.substringAfter(ruleText, mask);
        this.scriptletParams = parseRule(ruleText);
    }

    /**
     * Scriptlet config provided to build rules with debug capabilities
     * @typedef {Object} ScriptletConfig
     * @property {boolean} debug - indicates whether debug mode is enabled or not
     * @param {string} engine - engine identifier
     * @param {string} version - engine version
     */

    /**
     * Returns script. If debug enabled, rebuilds script with new parameters
     * @param {ScriptletConfig} scriptletConfig
     * @return {string | null}
     */
    function getScript(scriptletConfig) {
        const debugMode = !!(scriptletConfig && scriptletConfig.debug);

        if (debugMode === !!this.scriptletParams.debug && this.script) {
            return this.script;
        }

        this.scriptletParams = Object.assign(
            {},
            this.scriptletParams,
            scriptletConfig,
            { ruleText: this.ruleText }
        );

        this.script = getScriptletCode(this.scriptletParams);
        return this.script;
    }

    /**
     * Check is AdGuard scriptlet rule
     * @static
     */
    ScriptletRule.isAdguardScriptletRule = rule => rule.indexOf(ADG_SCRIPTLET_MASK) > -1;


    /**
     * returns rule content after mask
     * e.g. "example.org#%#//scriptlet("abort-on-property-read", "alert")" ->
     * -> "//scriptlet("abort-on-property-read", "alert")"
     * @return {string}
     */
    function getRuleContent() {
        return this.ruleContent;
    }

    /**
     * Extends BaseFilterRule
     */
    ScriptletRule.prototype = Object.create(api.FilterRule.prototype);
    ScriptletRule.prototype.constructor = ScriptletRule;

    ScriptletRule.prototype.getScript = getScript;

    ScriptletRule.prototype.getRuleContent = getRuleContent;

    /**
     * @static ScriptletRule
     */
    api.ScriptletRule = ScriptletRule;
})(adguard, adguard.rules);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (api) {
    /**
     * This rule may contain a list of rules generated from one complex ruleText
     * @constructor
     *
     * @example
     * input
     * ABP snippet rule
     * `example.org#$#hide-if-has-and-matches-style someSelector; hide-if-contains someSelector2`
     *
     * output
     * Adguard scriptlet rules
     * `example.org#%#//scriptlet("hide-if-has-and-matches-style", "someSelector")`
     * `example.org#%#//scriptlet("hide-if-contains", "someSelector2")`
     *
     */
    function CompositeRule(ruleText, rules) {
        this.ruleText = ruleText;
        this.rules = rules;
    }

    /**
     * @static ScriptletRule
     */
    api.CompositeRule = CompositeRule;
})(adguard.rules);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/* global CryptoJS */

/**
 * Service that loads and parses filters metadata from backend server.
 * For now we just store filters metadata in an XML file within the extension.
 * In future we'll add an opportunity to update metadata along with filter rules update.
 */
adguard.subscriptions = (function (adguard) {
    'use strict';

    /**
     * Custom filters group identifier
     *
     * @type {number}
     */
    const CUSTOM_FILTERS_GROUP_ID = 0;

    /**
     * Custom filters group display number
     *
     * @type {number}
     */
    const CUSTOM_FILTERS_GROUP_DISPLAY_NUMBER = 99;

    let tags = [];
    let groups = [];
    let groupsMap = {};
    let filters = [];
    let filtersMap = {};

    /**
     * @param timeUpdatedString String in format 'yyyy-MM-dd'T'HH:mm:ssZ'
     * @returns timestamp from date string
     */
    function parseTimeUpdated(timeUpdatedString) {
        // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1272
        if (Number.isInteger(timeUpdatedString)) {
            return new Date(timeUpdatedString);
        }

        // https://developer.mozilla.org/ru/docs/Web/JavaScript/Reference/Global_Objects/Date/parse
        let timeUpdated = Date.parse(timeUpdatedString);
        if (Number.isNaN(timeUpdated)) {
            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/478
            timeUpdated = Date.parse(timeUpdatedString.replace(/\+(\d{2})(\d{2})$/, '+$1:$2'));
        }
        if (Number.isNaN(timeUpdated)) {
            timeUpdated = new Date().getTime();
        }
        return timeUpdated;
    }

    /**
     * Tag metadata
     */
    const FilterTag = function (tagId, keyword) {
        this.tagId = tagId;
        this.keyword = keyword;
    };

    /**
     * Group metadata
     */
    const SubscriptionGroup = function (groupId, groupName, displayNumber) {
        this.groupId = groupId;
        this.groupName = groupName;
        this.displayNumber = displayNumber;
    };

    /**
     * object containing filter data
     * @typedef {Object} FilterData
     * @property {number} filterId - filter id
     * @property {number} groupId - filter group id
     * @property {String} name - filter name
     * @property {String} description - filter description
     * @property {String} homepage - filter homepage url
     * @property {String} version - filter version
     * @property {number} timeUpdated - filter update time
     * @property {number} displayNumber - filter display number used to sort filters in the group
     * @property {array.<string>} languages - filter base languages
     * @property {number} expires - filter update interval
     * @property {String} subscriptionUrl - filter update url
     * @property {array.<number>} tags - filter tags ids
     * @property {String} [customUrl] - custom filter url
     * @property {Boolean} [trusted] - filter is trusted or not
     */

    /**
     * Filter metadata
     * @param {FilterData} filterData
     */
    const SubscriptionFilter = function (filterData) {
        const {
            filterId,
            groupId,
            name,
            description,
            homepage,
            version,
            timeUpdated,
            displayNumber,
            languages,
            expires,
            subscriptionUrl,
            tags,
            customUrl,
            trusted,
            checksum,
        } = filterData;

        this.filterId = filterId;
        this.groupId = groupId;
        this.name = name;
        this.description = description;
        this.homepage = homepage;
        this.version = version;
        this.timeUpdated = timeUpdated;
        this.displayNumber = displayNumber;
        this.languages = languages;
        this.expires = expires;
        this.subscriptionUrl = subscriptionUrl;
        this.tags = tags;
        // Custom filters data
        if (typeof customUrl !== 'undefined') {
            this.customUrl = customUrl;
        }
        if (typeof trusted !== 'undefined') {
            this.trusted = trusted;
        }
        if (typeof checksum !== 'undefined') {
            this.checksum = checksum;
        }
    };

    /**
     * Create tag from object
     * @param tag Object
     * @returns {FilterTag}
     */
    function createFilterTagFromJSON(tag) {
        const tagId = tag.tagId - 0;
        const { keyword } = tag;

        return new FilterTag(tagId, keyword);
    }

    /**
     * Create group from object
     * @param group Object
     * @returns {SubscriptionGroup}
     */
    function createSubscriptionGroupFromJSON(group) {
        const groupId = group.groupId - 0;
        const defaultGroupName = group.groupName;
        const displayNumber = group.displayNumber - 0;

        return new SubscriptionGroup(groupId, defaultGroupName, displayNumber);
    }

    /**
     * Create filter from object
     * @param filter Object
     */
    const createSubscriptionFilterFromJSON = function (filter) {
        const filterId = filter.filterId - 0;
        const groupId = filter.groupId - 0;
        const defaultName = filter.name;
        const defaultDescription = filter.description;
        const { homepage } = filter;
        const { version } = filter;
        const timeUpdated = parseTimeUpdated(filter.timeUpdated);
        const expires = filter.expires - 0;
        const { subscriptionUrl } = filter;
        const { languages } = filter;
        const displayNumber = filter.displayNumber - 0;
        const { tags } = filter;
        const { customUrl } = filter;
        const { trusted } = filter;
        const { checksum } = filter;
        if (tags.length === 0) {
            tags.push(0);
        }

        return new SubscriptionFilter({
            filterId,
            groupId,
            name: defaultName,
            description: defaultDescription,
            homepage,
            version,
            timeUpdated,
            displayNumber,
            languages,
            expires,
            subscriptionUrl,
            tags,
            customUrl,
            trusted,
            checksum,
        });
    };

    const parseExpiresStr = (str) => {
        const regexp = /(\d+)\s+(day|hour)/;

        const parseRes = str.match(regexp);

        if (!parseRes) {
            const parsed = Number.parseInt(str, 10);
            return Number.isNaN(parsed) ? 0 : parsed;
        }

        const [, num, period] = parseRes;

        let multiplier = 1;
        switch (period) {
            case 'day': {
                multiplier = 24 * 60 * 60;
                break;
            }
            case 'hour': {
                multiplier = 60 * 60;
                break;
            }
            default: {
                break;
            }
        }

        return num * multiplier;
    };

    /**
     * Parses filter metadata from rules header
     *
     * @param rules
     * @returns object
     */
    const parseFilterDataFromHeader = (rules) => {
        const parseTag = (tagName) => {
            let result = '';

            // Look up no more than 50 first lines
            const maxLines = Math.min(50, rules.length);
            for (let i = 0; i < maxLines; i += 1) {
                const rule = rules[i];
                const search = `! ${tagName}: `;
                const indexOfSearch = rule.indexOf(search);
                if (indexOfSearch >= 0) {
                    result = rule.substring(indexOfSearch + search.length);
                }
            }

            if (tagName === 'Expires') {
                result = parseExpiresStr(result);
            }

            return result;
        };

        return {
            name: parseTag('Title'),
            description: parseTag('Description'),
            homepage: parseTag('Homepage'),
            version: parseTag('Version'),
            expires: parseTag('Expires'),
            timeUpdated: parseTag('TimeUpdated'),
        };
    };

    const CUSTOM_FILTERS_START_ID = 1000;

    const addFilterId = () => {
        let max = 0;
        filters.forEach((f) => {
            if (f.filterId > max) {
                max = f.filterId;
            }
        });

        return max >= CUSTOM_FILTERS_START_ID ? max + 1 : CUSTOM_FILTERS_START_ID;
    };


    const CUSTOM_FILTERS_JSON_KEY = 'custom_filters';

    /**
     * Loads custom filters from storage
     *
     * @returns {Array}
     */
    const loadCustomFilters = () => {
        const customFilters = adguard.localStorage.getItem(CUSTOM_FILTERS_JSON_KEY);
        return customFilters ? JSON.parse(customFilters) : [];
    };

    /**
     * Saves custom filter to storage or updates it if filter with same id was found
     *
     * @param filter
     */
    const saveCustomFilterInStorage = (filter) => {
        const customFilters = loadCustomFilters();
        // check if filter exists
        let found = false;
        const updatedCustomFilters = customFilters.map((f) => {
            if (f.filterId === filter.filterId) {
                found = true;
                return filter;
            }
            return f;
        });
        if (!found) {
            updatedCustomFilters.push(filter);
        }
        adguard.localStorage.setItem(CUSTOM_FILTERS_JSON_KEY, JSON.stringify(updatedCustomFilters));
    };

    /**
     * Remove custom filter data from storage
     *
     * @param filter
     */
    const removeCustomFilterFromStorage = (filter) => {
        const customFilters = loadCustomFilters();
        const updatedCustomFilters = customFilters.filter((f) => {
            if (f.filterId === filter.filterId) {
                return filter.installed;
            }
            return true;
        });
        adguard.localStorage.setItem(CUSTOM_FILTERS_JSON_KEY, JSON.stringify(updatedCustomFilters));
    };

    /**
     * Compares filter version or filter checksum
     * @param newVersion
     * @param newChecksum
     * @param oldFilter
     * @returns {*}
     */
    function didFilterUpdate(newVersion, newChecksum, oldFilter) {
        if (newVersion) {
            return !adguard.utils.browser.isGreaterOrEqualsVersion(oldFilter.version, newVersion);
        }
        if (!oldFilter.checksum) {
            return true;
        }
        return newChecksum !== oldFilter.checksum;
    }

    /**
     * Count md5 checksum for the filter content
     * @param {Array<String>} rules
     * @returns {String} checksum string
     */
    const getChecksum = (rules) => {
        const rulesText = rules.join('\n');
        return CryptoJS.MD5(rulesText).toString();
    };

    /**
     * Updates filter checksum and version in the storage and internal structures
     * @param filter
     * @param {object} info
     */
    const updateCustomFilterInfo = (filter, info) => {
        const {
            checksum,
            version,
            timeUpdated,
            lastCheckTime,
            expires,
        } = info;
        // set last checksum and version
        filter.checksum = checksum || filter.checksum;
        filter.version = version || filter.version;
        filter.timeUpdated = timeUpdated || filter.timeUpdated;
        filter.lastCheckTime = lastCheckTime || filter.lastCheckTime;
        filter.expires = expires || filter.expires;

        filters = filters.map((f) => {
            if (f.filterId === filter.filterId) {
                f.version = version || f.version;
                f.checksum = checksum || f.checksum;
                f.timeUpdated = timeUpdated || f.timeUpdated;
                f.lastCheckTime = lastCheckTime || filter.lastCheckTime;
                f.expires = expires || filter.expires;
                return f;
            }
            return f;
        });

        filtersMap[filter.filterId] = filter;
        saveCustomFilterInStorage(filter);
    };

    /**
     * Adds or updates custom filter
     *
     * @param url subscriptionUrl
     * @param options
     * @param callback
     */
    const updateCustomFilter = function (url, options, callback) {
        const { title, trusted } = options;
        adguard.backend.loadFilterRulesBySubscriptionUrl(url, (rules) => {
            const filterId = addFilterId();
            const parsedData = parseFilterDataFromHeader(rules);
            let { timeUpdated } = parsedData;
            const {
                description,
                homepage,
                version,
                expires,
            } = parsedData;

            const name = title;

            timeUpdated = timeUpdated || new Date().toISOString();
            const groupId = CUSTOM_FILTERS_GROUP_ID;
            const subscriptionUrl = url;
            const languages = [];
            const displayNumber = 0;
            const tags = [0];

            let checksum;
            if (!version) {
                checksum = getChecksum(rules);
            }

            // Check if filter from this url was added before
            let filter = filters.find(f => f.customUrl === url);

            let updateFilter = true;
            if (filter) {
                if (!didFilterUpdate(version, checksum, filter)) {
                    callback();
                    updateCustomFilterInfo(filter, { lastCheckTime: Date.now() });
                    return;
                }
            } else {
                filter = new SubscriptionFilter({
                    filterId,
                    groupId,
                    name,
                    description,
                    homepage,
                    version,
                    timeUpdated,
                    displayNumber,
                    languages,
                    expires,
                    subscriptionUrl,
                    tags,
                    customUrl: url,
                    checksum,
                    trusted,
                });

                filter.loaded = true;
                filters.push(filter);
                filtersMap[filter.filterId] = filter;

                // Save filter in separate storage
                saveCustomFilterInStorage(filter);
                updateFilter = false;
            }

            if (updateFilter) {
                updateCustomFilterInfo(filter, {
                    version,
                    checksum,
                    timeUpdated,
                    expires,
                });
            }

            updateCustomFilterInfo(filter, { lastCheckTime: Date.now() });

            adguard.listeners.notifyListeners(adguard.listeners.SUCCESS_DOWNLOAD_FILTER, filter);
            adguard.listeners.notifyListeners(adguard.listeners.UPDATE_FILTER_RULES, filter, rules);

            callback(filter.filterId);
        }, (cause) => {
            adguard.console.error(`Error download filter by url ${url}, cause: ${cause || ''}`);
            callback();
        });
    };

    const getCustomFilterInfo = (url, options, callback) => {
        const { title } = options;

        adguard.backend.loadFilterRulesBySubscriptionUrl(url, (rules) => {
            const parsedData = parseFilterDataFromHeader(rules);
            let { name, timeUpdated } = parsedData;
            const {
                description,
                homepage,
                version,
                expires,
            } = parsedData;

            name = name || title;
            timeUpdated = timeUpdated || new Date().toISOString();

            const groupId = CUSTOM_FILTERS_GROUP_ID;
            const subscriptionUrl = url;
            const languages = [];
            const displayNumber = 0;
            const tags = [0];
            const rulesCount = rules.filter(rule => rule.trim().indexOf('!') !== 0).length;

            // Check if filter from this url was added before
            let filter = filters.find(f => f.customUrl === url);

            if (filter) {
                callback({ error: adguard.i18n.getMessage('options_antibanner_custom_filter_already_exists') });
                return;
            }

            filter = new SubscriptionFilter({
                groupId,
                name,
                description,
                homepage,
                version,
                timeUpdated,
                displayNumber,
                languages,
                expires,
                subscriptionUrl,
                tags,
            });

            filter.loaded = true;
            // custom filters have special fields
            filter.customUrl = url;
            filter.rulesCount = rulesCount;

            callback({ filter });
        }, (cause) => {
            adguard.console.error(`Error download filter by url ${url}, cause: ${cause || ''}`);
            callback();
        });
    };

    /**
     * Load groups and filters metadata
     * @returns {Promise} returns promise
     */
    async function loadMetadata() {
        const metadata = await adguard.backend.loadLocalFiltersMetadata();
        tags = [];
        groups = [];
        groupsMap = {};
        filters = [];
        filtersMap = {};

        for (let i = 0; i < metadata.tags.length; i += 1) {
            tags.push(createFilterTagFromJSON(metadata.tags[i]));
        }

        for (let j = 0; j < metadata.filters.length; j += 1) {
            const filter = createSubscriptionFilterFromJSON(metadata.filters[j]);
            filters.push(filter);
            filtersMap[filter.filterId] = filter;
        }

        for (let k = 0; k < metadata.groups.length; k += 1) {
            const group = createSubscriptionGroupFromJSON(metadata.groups[k]);
            groups.push(group);
            groupsMap[group.groupId] = group;
        }

        const customFiltersGroup = new SubscriptionGroup(CUSTOM_FILTERS_GROUP_ID,
            adguard.i18n.getMessage('options_antibanner_custom_group'),
            CUSTOM_FILTERS_GROUP_DISPLAY_NUMBER);
        groups.push(customFiltersGroup);
        groupsMap[customFiltersGroup.groupId] = customFiltersGroup;

        // Load custom filters
        const customFilters = loadCustomFilters();
        customFilters.forEach((f) => {
            const customFilter = createSubscriptionFilterFromJSON(f);
            filters.push(customFilter);
            filtersMap[customFilter.filterId] = customFilter;
        });

        filters.sort((f1, f2) => f1.displayNumber - f2.displayNumber);

        groups.sort((f1, f2) => f1.displayNumber - f2.displayNumber);

        adguard.console.info('Filters metadata loaded');
    }

    /**
     * Localize tag
     * @param tag
     * @param i18nMetadata
     * @private
     */
    function applyFilterTagLocalization(tag, i18nMetadata) {
        const { tagId } = tag;
        const localizations = i18nMetadata[tagId];
        if (localizations) {
            const locale = adguard.utils.i18n.normalize(localizations, adguard.app.getLocale());
            const localization = localizations[locale];
            if (localization) {
                tag.name = localization.name;
                tag.description = localization.description;
            }
        }
    }

    /**
     * Localize filter
     * @param filter
     * @param i18nMetadata
     * @private
     */
    function applyFilterLocalization(filter, i18nMetadata) {
        const { filterId } = filter;
        const localizations = i18nMetadata[filterId];
        if (localizations) {
            const locale = adguard.utils.i18n.normalize(localizations, adguard.app.getLocale());
            const localization = localizations[locale];
            if (localization) {
                filter.name = localization.name;
                filter.description = localization.description;
            }
        }
    }

    /**
     * Localize group
     * @param group
     * @param i18nMetadata
     * @private
     */
    function applyGroupLocalization(group, i18nMetadata) {
        const { groupId } = group;
        const localizations = i18nMetadata[groupId];
        if (localizations) {
            const locale = adguard.utils.i18n.normalize(localizations, adguard.app.getLocale());
            const localization = localizations[locale];
            if (localization) {
                group.groupName = localization.name;
            }
        }
    }

    /**
     * Loads groups and filters localizations
     * @return {Promise} returns promise
     */
    async function loadMetadataI18n() {
        const i18nMetadata = await adguard.backend.loadLocalFiltersI18Metadata();
        const tagsI18n = i18nMetadata.tags;
        const filtersI18n = i18nMetadata.filters;
        const groupsI18n = i18nMetadata.groups;

        for (let i = 0; i < tags.length; i += 1) {
            applyFilterTagLocalization(tags[i], tagsI18n);
        }

        for (let j = 0; j < filters.length; j += 1) {
            applyFilterLocalization(filters[j], filtersI18n);
        }

        for (let k = 0; k < groups.length; k += 1) {
            applyGroupLocalization(groups[k], groupsI18n);
        }

        adguard.console.info('Filters i18n metadata loaded');
    }

    /**
     * Loads script rules from local file
     * @returns {Promise}
     * @private
     */
    async function loadLocalScriptRules() {
        const localScriptRulesService = adguard.rules.LocalScriptRulesService;
        if (typeof localScriptRulesService !== 'undefined') {
            const json = await adguard.backend.loadLocalScriptRules();
            localScriptRulesService.setLocalScriptRules(json);
            adguard.console.info('Filters local script rules loaded');
        }
    }

    /**
     * Loads redirect sources from local file
     * @returns {Promise}
     * @private
     */
    async function loadRedirectSources() {
        const redirectSourcesService = adguard.rules.RedirectFilterService;
        if (typeof redirectSourcesService !== 'undefined') {
            const txt = await adguard.backend.loadRedirectSources();
            redirectSourcesService.setRedirectSources(txt);
            adguard.console.info('Filters redirect sources loaded');
        }
    }

    /**
     * Initialize subscription service, loading local filters metadata
     * @return {Promise}
     */
    const init = async function () {
        try {
            await loadMetadata();
            await loadMetadataI18n();
            await loadLocalScriptRules();
            await loadRedirectSources();
        } catch (e) {
            adguard.console.error(`Error loading metadata, cause: ${e.message}`);
        }
    };

    /**
     * @returns Array of Filters metadata
     */
    const getFilters = function () {
        return filters;
    };

    const getCustomFilters = function () {
        return filters.filter(f => f.customUrl);
    };

    /**
     * Gets filter metadata by filter identifier
     */
    const getFilter = function (filterId) {
        return filtersMap[filterId];
    };

    const isTrustedFilter = (filterId) => {
        if (filterId < CUSTOM_FILTERS_START_ID) {
            return true;
        }
        const filter = filtersMap[filterId];
        return !!(filter && filter.trusted && filter.trusted === true);
    };

    /**
     * @returns Array of Tags metadata
     */
    const getTags = function () {
        return tags;
    };

    /**
     * @returns Array of Groups metadata
     */
    const getGroups = () => groups;

    /**
     * @returns Group metadata
     */
    const getGroup = groupId => groupsMap[groupId];

    /**
     * Checks if group has enabled status true or false
     * @param groupId
     * @returns {boolean}
     */
    const groupHasEnabledStatus = (groupId) => {
        const group = groupsMap[groupId];
        return typeof group.enabled !== 'undefined';
    };

    /**
     * Gets list of filters for the specified languages
     *
     * @param locale Locale to check
     * @returns {Array} List of filters identifiers
     */
    const getFilterIdsForLanguage = function (locale) {
        if (!locale) {
            return [];
        }
        const filterIds = [];
        for (let i = 0; i < filters.length; i += 1) {
            const filter = filters[i];
            const { languages } = filter;
            if (languages && languages.length > 0) {
                const language = adguard.utils.i18n.normalize(languages, locale);
                if (language) {
                    filterIds.push(filter.filterId);
                }
            }
        }
        return filterIds;
    };

    const getLangSuitableFilters = () => {
        // Get language-specific filters by user locale
        let filterIds = [];

        let localeFilterIds = getFilterIdsForLanguage(adguard.app.getLocale());
        filterIds = filterIds.concat(localeFilterIds);

        // Get language-specific filters by navigator languages
        // Get the 2 most commonly used languages
        const languages = adguard.utils.browser.getNavigatorLanguages(2);
        for (let i = 0; i < languages.length; i += 1) {
            localeFilterIds = getFilterIdsForLanguage(languages[i]);
            filterIds = filterIds.concat(localeFilterIds);
        }
        return [...new Set(filterIds)];
    };

    const removeCustomFilter = (filter) => {
        if (filter && filter.filterId) {
            delete filtersMap[filter.filterId];
            filters = filters.filter(f => f.filterId !== filter.filterId);
        }
    };

    // Add event listener to persist filter metadata to local storage
    adguard.listeners.addListener((event, payload) => {
        switch (event) {
            case adguard.listeners.FILTER_ADD_REMOVE:
                if (payload && payload.removed) {
                    removeCustomFilter(payload);
                    removeCustomFilterFromStorage(payload);
                }
                break;
            default:
                break;
        }
    });

    return {
        init,
        getFilterIdsForLanguage,
        getTags,
        getGroups,
        getGroup,
        groupHasEnabledStatus,
        getFilters,
        getCustomFilters,
        getFilter,
        isTrustedFilter,
        createSubscriptionFilterFromJSON,
        updateCustomFilter,
        getCustomFilterInfo,
        getLangSuitableFilters,
        CUSTOM_FILTERS_START_ID,
    };
})(adguard);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Service that manages extension version information and handles
 * extension update. For instance we may need to change storage schema on update.
 */
adguard.applicationUpdateService = (function (adguard) {
    /**
     * File storage adapter
     * @Deprecated Used now only to upgrade from versions older than v2.3.5
     */
    const FileStorage = {

        LINE_BREAK: '\n',
        FILE_PATH: 'filters.ini',

        readFromFile(path, callback) {
            const successCallback = function (fs, fileEntry) {
                fileEntry.file((file) => {
                    const reader = new FileReader();
                    reader.onloadend = function () {
                        if (reader.error) {
                            callback(reader.error);
                        } else {
                            let lines = [];
                            if (reader.result) {
                                lines = reader.result.split(/[\r\n]+/);
                            }
                            callback(null, lines);
                        }
                    };

                    reader.onerror = function (e) {
                        callback(e);
                    };

                    reader.readAsText(file);
                }, callback);
            };

            this._getFile(path, true, successCallback, callback);
        },

        _getFile(path, create, successCallback, errorCallback) {
            path = path.replace(/^.*[\/\\]/, '');

            const requestFileSystem = window.requestFileSystem || window.webkitRequestFileSystem;
            requestFileSystem(window.PERSISTENT, 1024 * 1024 * 1024, (fs) => {
                fs.root.getFile(path, { create }, (fileEntry) => {
                    successCallback(fs, fileEntry);
                }, errorCallback);
            }, errorCallback);
        },

        removeFile(path, successCallback, errorCallback) {
            this._getFile(path, false, (fs, fileEntry) => {
                fileEntry.remove(successCallback, errorCallback);
            }, errorCallback);
        },
    };

    /**
     * Helper to execute deferred objects
     *
     * @param methods Methods to execute
     * @returns {Deferred}
     * @private
     */
    function executeMethods(methods) {
        const mainDfd = new adguard.utils.Promise();

        var executeNextMethod = function () {
            if (methods.length === 0) {
                mainDfd.resolve();
            } else {
                const method = methods.shift();
                const dfd = method();
                dfd.then(executeNextMethod);
            }
        };

        executeNextMethod();

        return mainDfd;
    }

    /**
     * Updates filters storage - move from files to the storage API.
     *
     * Version 2.3.5
     * @returns {Promise}
     * @private
     */
    function onUpdateChromiumStorage() {
        adguard.console.info('Call update to version 2.3.5');

        const dfd = new adguard.utils.Promise();

        const filterId = adguard.utils.filters.USER_FILTER_ID;
        const filePath = `filterrules_${filterId}.txt`;

        FileStorage.readFromFile(filePath, (e, rules) => {
            if (e) {
                adguard.console.error('Error while reading rules from file {0} cause: {1}', filePath, e);
                return;
            }

            const onTransferCompleted = function () {
                adguard.console.info('Rules have been transferred to local storage for filter {0}', filterId);

                FileStorage.removeFile(filePath, () => {
                    adguard.console.info('File removed for filter {0}', filterId);
                }, () => {
                    adguard.console.error('File remove error for filter {0}', filterId);
                });
            };

            if (rules) {
                adguard.console.info(`Found rules:${rules.length}`);
            }

            adguard.rulesStorage.write(filterId, rules, onTransferCompleted);
        });

        dfd.resolve();
        return dfd;
    }

    /**
     * Migrates from the storage.local to the indexedDB
     * Version > 2.7.3
     */
    function onUpdateFirefoxWebExtRulesStorage() {
        const dfd = new adguard.utils.Promise();

        function writeFilterRules(keys, items) {
            if (keys.length === 0) {
                dfd.resolve();
            } else {
                const key = keys.shift();
                const lines = items[key] || [];
                const linesLength = lines.length;
                adguard.rulesStorageImpl.write(key, lines, () => {
                    adguard.console.info('Adguard filter "{0}" has been migrated. Rules: {1}', key, linesLength);
                    browser.storage.local.remove(key);
                    writeFilterRules(keys, items);
                });
            }
        }

        function migrate() {
            adguard.console.info('Call update to use indexedDB instead of storage.local for Firefox browser');

            browser.storage.local.get(null, (items) => {
                const keys = [];
                for (const key in items) {
                    if (items.hasOwnProperty(key) && key.indexOf('filterrules_') === 0) {
                        keys.push(key);
                    }
                }

                writeFilterRules(keys, items);
            });
        }

        if (adguard.rulesStorageImpl.isIndexedDB) {
            // Switch implementation to indexedDB
            migrate();
        } else {
            // indexedDB initialization failed, doing nothing
            dfd.resolve();
        }

        return dfd;
    }

    /**
     * Edge supports unlimitedStorage since Creators update.
     * Previously, we keep filter rules in localStorage, and now we have to migrate this rules to browser.storage.local
     * See https://github.com/AdguardTeam/AdguardBrowserExtension/issues/566
     */
    function onUpdateEdgeRulesStorage() {
        const dfd = new adguard.utils.Promise();

        const fixProperty = `edge-storage-local-fix-build${adguard.utils.browser.EDGE_CREATORS_UPDATE}`;
        if (adguard.localStorage.getItem(fixProperty)) {
            dfd.resolve();
            return dfd;
        }

        adguard.console.info('Call update to use storage.local for Edge browser');

        const keys = [];
        for (const key in localStorage) {
            if (localStorage.hasOwnProperty(key) && key.indexOf('filterrules_') === 0) {
                keys.push(key);
            }
        }

        function writeFilterRules() {
            if (keys.length === 0) {
                adguard.localStorage.setItem(fixProperty, true);
                dfd.resolve();
            } else {
                const key = keys.shift();
                let lines = [];
                const value = localStorage.getItem(key);
                if (value) {
                    lines = value.split(/[\r\n]+/);
                }
                adguard.rulesStorageImpl.write(key, lines, () => {
                    localStorage.removeItem(key);
                    writeFilterRules();
                });
            }
        }

        writeFilterRules();

        return dfd;
    }

    function handleUndefinedGroupStatuses() {
        const dfd = new adguard.utils.Promise();

        const filters = adguard.subscriptions.getFilters();

        const filtersState = adguard.filtersState.getFiltersState();

        const enabledFilters = filters.filter((filter) => {
            const { filterId } = filter;
            return !!(filtersState[filterId] && filtersState[filterId].enabled);
        });

        const groupState = adguard.filtersState.getGroupsState();

        enabledFilters.forEach((filter) => {
            const { groupId } = filter;
            if (typeof groupState[groupId] === 'undefined') {
                adguard.filters.enableGroup(filter.groupId);
            }
        });

        dfd.resolve();

        return dfd;
    }

    function handleDefaultUpdatePeriodSetting() {
        const dfd = new adguard.utils.Promise();
        const previousDefaultValue = 48 * 60 * 60 * 1000;

        const currentUpdatePeriod = adguard.settings.getFiltersUpdatePeriod();

        if (currentUpdatePeriod === previousDefaultValue) {
            adguard.settings.setFiltersUpdatePeriod(adguard.settings.DEFAULT_FILTERS_UPDATE_PERIOD);
        }

        dfd.resolve();

        return dfd;
    }

    /**
     * Function removes obsolete filters from the storage
     * @returns {Promise<any>}
     */
    function handleObsoleteFiltersRemoval() {
        const dfd = new adguard.utils.Promise();

        const filtersStateInfo = adguard.filtersState.getFiltersState();
        const allFiltersMetadata = adguard.subscriptions.getFilters();

        const installedFiltersIds = Object.keys(filtersStateInfo)
            .map(filterId => Number.parseInt(filterId, 10));

        const existingFiltersIds = installedFiltersIds.filter((filterId) => {
            return allFiltersMetadata.find(f => f.filterId === filterId);
        });

        const filtersIdsToRemove = installedFiltersIds.filter((id) => {
            return !existingFiltersIds.includes(id);
        });

        filtersIdsToRemove.forEach(filterId => adguard.filtersState.removeFilter(filterId));

        const removePromises = filtersIdsToRemove.map(filterId => new Promise((resolve) => {
            adguard.rulesStorage.remove(filterId, () => {
                adguard.console.info(`Filter with id: ${filterId} removed from the storage`);
                resolve();
            });
            resolve();
        }));

        Promise.all(removePromises).then(() => {
            dfd.resolve();
        });

        return dfd;
    }

    /**
     * Async returns extension run info
     *
     * @param callback Run info callback with passed object {{isFirstRun: boolean, isUpdate: (boolean|*), currentVersion: (Prefs.version|*), prevVersion: *}}
     */
    const getRunInfo = function (callback) {
        const prevVersion = adguard.utils.browser.getAppVersion();
        const currentVersion = adguard.app.getVersion();
        adguard.utils.browser.setAppVersion(currentVersion);

        const isFirstRun = (currentVersion !== prevVersion && !prevVersion);
        const isUpdate = !!(currentVersion !== prevVersion && prevVersion);

        callback({
            isFirstRun,
            isUpdate,
            currentVersion,
            prevVersion,
        });
    };

    /**
     * Handle extension update
     * @param runInfo   Run info
     * @param callback  Called after update was handled
     */
    const onUpdate = function (runInfo, callback) {
        const methods = [];
        if (adguard.utils.browser.isGreaterVersion('2.3.5', runInfo.prevVersion)
            && adguard.utils.browser.isChromium()) {
            methods.push(onUpdateChromiumStorage);
        }
        if (adguard.utils.browser.isEdgeBrowser() && !adguard.utils.browser.isEdgeBeforeCreatorsUpdate()) {
            methods.push(onUpdateEdgeRulesStorage);
        }
        if (adguard.utils.browser.isGreaterVersion('2.7.4', runInfo.prevVersion)
            && adguard.utils.browser.isFirefoxBrowser() && typeof browser !== 'undefined') {
            methods.push(onUpdateFirefoxWebExtRulesStorage);
        }
        if (adguard.utils.browser.isGreaterVersion('3.0.3', runInfo.prevVersion)) {
            methods.push(handleUndefinedGroupStatuses);
        }
        if (adguard.utils.browser.isGreaterVersion('3.3.5', runInfo.prevVersion)) {
            methods.push(handleDefaultUpdatePeriodSetting);
        }

        // On every update remove if necessary obsolete filters
        methods.push(handleObsoleteFiltersRemoval);

        const dfd = executeMethods(methods);
        dfd.then(callback);
    };

    return {
        getRunInfo,
        onUpdate,
    };
})(adguard);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

adguard.whitelist = (function (adguard) {

    var WHITE_LIST_DOMAINS_LS_PROP = 'white-list-domains';
    var BLOCK_LIST_DOMAINS_LS_PROP = 'block-list-domains';

    var allowAllWhiteListRule = new adguard.rules.UrlFilterRule('@@whitelist-all$document', adguard.utils.filters.WHITE_LIST_FILTER_ID);

    var whiteListFilter = new adguard.rules.UrlFilter();
    var blockListFilter = new adguard.rules.UrlFilter();

    /**
     * Whitelist filter may not have been initialized yet
     * @returns {*|UrlFilter}
     */
    function getWhiteListFilter() {
        // Request domains property for filter initialization
        whiteListDomainsHolder.domains; // jshint ignore:line
        return whiteListFilter;
    }

    /**
     * Blacklist filter may not have been initialized yet
     * @returns {*|UrlFilter}
     */
    function getBlockListFilter() {
        // Request domains property for filter initialization
        blockListDomainsHolder.domains; // jshint ignore:line
        return blockListFilter;
    }

    /**
     * Returns whitelist mode
     * In default mode filtration is enabled for all sites
     * In inverted model filtration is disabled for all sites
     */
    function isDefaultWhiteListMode() {
        return adguard.settings.isDefaultWhiteListMode();
    }

    /**
     * Read domains and initialize filters lazy
     */
    var whiteListDomainsHolder = {
        get domains() {
            return adguard.lazyGet(whiteListDomainsHolder, 'domains', function () {
                whiteListFilter = new adguard.rules.UrlFilter();
                // Reading from local storage
                var domains = getDomainsFromLocalStorage(WHITE_LIST_DOMAINS_LS_PROP);
                for (var i = 0; i < domains.length; i++) {
                    var rule = createWhiteListRule(domains[i]);
                    if (rule) {
                        whiteListFilter.addRule(rule);
                    }
                }
                return domains;
            });
        },
        add: function (domain) {
            if (this.domains.indexOf(domain) < 0) {
                this.domains.push(domain);
            }
        }
    };
    var blockListDomainsHolder = {
        get domains() {
            return adguard.lazyGet(blockListDomainsHolder, 'domains', function () {
                blockListFilter = new adguard.rules.UrlFilter();
                // Reading from local storage
                var domains = getDomainsFromLocalStorage(BLOCK_LIST_DOMAINS_LS_PROP);
                for (var i = 0; i < domains.length; i++) {
                    var rule = createWhiteListRule(domains[i]);
                    if (rule) {
                        blockListFilter.addRule(rule);
                    }
                }
                return domains;
            });
        },
        add: function (domain) {
            if (this.domains.indexOf(domain) < 0) {
                this.domains.push(domain);
            }
        }
    };

    function notifyWhiteListUpdated() {
        adguard.listeners.notifyListeners(adguard.listeners.UPDATE_WHITELIST_FILTER_RULES);
    }

    /**
     * Create whitelist rule from input text
     * @param domain Domain
     * @returns {*}
     * @private
     */
    function createWhiteListRule(domain) {
        if (adguard.utils.strings.isEmpty(domain)) {
            return null;
        }
        return adguard.rules.builder.createRule("@@//" + domain + "$document", adguard.utils.filters.WHITE_LIST_FILTER_ID);
    }

    /**
     * Adds domain to array of whitelist domains
     * @param domain
     */
    function addDomainToWhiteList(domain) {
        if (!domain) {
            return;
        }
        if (isDefaultWhiteListMode()) {
            whiteListDomainsHolder.add(domain);
        } else {
            blockListDomainsHolder.add(domain);
        }
    }

    /**
     * Remove domain form whitelist domains
     * @param domain
     */
    function removeDomainFromWhiteList(domain) {
        if (!domain) {
            return;
        }
        if (isDefaultWhiteListMode()) {
            adguard.utils.collections.removeAll(whiteListDomainsHolder.domains, domain);
        } else {
            adguard.utils.collections.removeAll(blockListDomainsHolder.domains, domain);
        }
    }

    /**
     * Remove domain from whitelist
     * @param domain
     */
    function removeFromWhiteList(domain) {
        var rule = createWhiteListRule(domain);
        if (rule) {
            if (isDefaultWhiteListMode()) {
                getWhiteListFilter().removeRule(rule);
            } else {
                getBlockListFilter().removeRule(rule);
            }
        }
        removeDomainFromWhiteList(domain);
        saveDomainsToLocalStorage();
        notifyWhiteListUpdated();
    }

    /**
     * Save domains to local storage
     */
    function saveDomainsToLocalStorage() {
        adguard.localStorage.setItem(WHITE_LIST_DOMAINS_LS_PROP,
            JSON.stringify(whiteListDomainsHolder.domains));
        adguard.localStorage.setItem(BLOCK_LIST_DOMAINS_LS_PROP,
            JSON.stringify(blockListDomainsHolder.domains));
    }

    /**
     * Retrieve domains from local storage
     * @param prop
     * @returns {Array}
     */
    function getDomainsFromLocalStorage(prop) {
        var domains = [];
        try {
            var json = adguard.localStorage.getItem(prop);
            if (json) {
                domains = JSON.parse(json);
            }
        } catch (ex) {
            adguard.console.error("Error retrieve whitelist domains {0}, cause {1}", prop, ex);
        }
        return domains;
    }

    /**
     * Adds domain to whitelist
     * @param domain
     */
    function addToWhiteList(domain) {
        var rule = createWhiteListRule(domain);
        if (rule) {
            if (isDefaultWhiteListMode()) {
                getWhiteListFilter().addRule(rule);
            } else {
                getBlockListFilter().addRule(rule);
            }
            addDomainToWhiteList(domain);
            saveDomainsToLocalStorage();
            notifyWhiteListUpdated();
        }
    }

    /**
     * Search for whitelist rule by url.
     */
    var findWhiteListRule = function (url) {

        if (!url) {
            return null;
        }

        var host = adguard.utils.url.getHost(url);

        if (isDefaultWhiteListMode()) {
            return getWhiteListFilter().isFiltered(url, host, adguard.RequestTypes.DOCUMENT, false);
        } else {
            var rule = getBlockListFilter().isFiltered(url, host, adguard.RequestTypes.DOCUMENT, false);
            if (rule) {
                //filtering is enabled on this website
                return null;
            } else {
                return allowAllWhiteListRule;
            }
        }
    };

    /**
     * Changes whitelist mode
     * @param defaultMode
     */
    var changeDefaultWhiteListMode = function (defaultMode) {
        adguard.settings.changeDefaultWhiteListMode(defaultMode);
        notifyWhiteListUpdated();
    };

    /**
     * Stop (or start in case of inverted mode) filtration for url
     * @param url
     */
    var whiteListUrl = function (url) {
        var domain = adguard.utils.url.getHost(url);
        if (isDefaultWhiteListMode()) {
            addToWhiteList(domain);
        } else {
            removeFromWhiteList(domain);
        }
    };

    /**
     * Start (or stop in case of inverted mode) filtration for url
     * @param url
     */
    var unWhiteListUrl = function (url) {
        var domain = adguard.utils.url.getHost(url);
        if (isDefaultWhiteListMode()) {
            removeFromWhiteList(domain);
        } else {
            addToWhiteList(domain);
        }
    };

    /**
     * Updates domains in whitelist
     * @param domains
     */
    var updateWhiteListDomains = function (domains) {
        domains = domains || [];
        if (isDefaultWhiteListMode()) {
            clearWhiteListed();
            addWhiteListed(domains);
        } else {
            clearBlockListed();
            addBlockListed(domains);
        }
        notifyWhiteListUpdated();
    };

    /**
     * Add domains to whitelist
     * @param domains
     */
    var addWhiteListed = function (domains) {
        if (!domains) {
            return;
        }
        for (var i = 0; i < domains.length; i++) {
            var domain = domains[i];
            whiteListDomainsHolder.add(domain);
            var rule = createWhiteListRule(domain);
            if (rule) {
                whiteListFilter.addRule(rule);
            }
        }
        saveDomainsToLocalStorage();
    };

    /**
     * Add domains to blocklist
     * @param domains
     */
    var addBlockListed = function (domains) {
        if (!domains) {
            return;
        }
        for (var i = 0; i < domains.length; i++) {
            var domain = domains[i];
            blockListDomainsHolder.add(domain);
            var rule = createWhiteListRule(domain);
            if (rule) {
                blockListFilter.addRule(rule);
            }
        }
        saveDomainsToLocalStorage();
    };

    /**
     * Clear whitelisted only
     */
    var clearWhiteListed = function () {
        adguard.localStorage.removeItem(WHITE_LIST_DOMAINS_LS_PROP);
        adguard.lazyGetClear(whiteListDomainsHolder, 'domains');
        whiteListFilter = new adguard.rules.UrlFilter();
    };

    /**
     * Clear blocklisted only
     */
    var clearBlockListed = function () {
        adguard.localStorage.removeItem(BLOCK_LIST_DOMAINS_LS_PROP);
        adguard.lazyGetClear(blockListDomainsHolder, 'domains');
        blockListFilter = new adguard.rules.UrlFilter();
    };

    /**
     * Configures whitelist service
     * @param whitelist Whitelist domains
     * @param blocklist Blocklist domains
     * @param whiteListMode Whitelist mode
     */
    var configure = function (whitelist, blocklist, whiteListMode) {
        clearWhiteListed();
        clearBlockListed();
        addWhiteListed(whitelist || []);
        addBlockListed(blocklist || []);
        adguard.settings.changeDefaultWhiteListMode(whiteListMode);
        notifyWhiteListUpdated();
    };

    /**
     * Returns the array of whitelist domains
     */
    var getWhiteListDomains = function () {
        if (isDefaultWhiteListMode()) {
            return whiteListDomainsHolder.domains;
        } else {
            return blockListDomainsHolder.domains;
        }
    };

    /**
     * Returns the array of whitelisted domains
     */
    var getWhiteListedDomains = function () {
        return whiteListDomainsHolder.domains;
    };

    /**
     * Returns the array of blocklisted domains, inverted mode
     */
    var getBlockListedDomains = function () {
        return blockListDomainsHolder.domains;
    };

    /**
     * Returns the array of loaded rules
     */
    var getRules = function () {
        //TODO: blockListFilter

        return getWhiteListFilter().getRules();
    };

    /**
     * Initializes whitelist filter
     */
    var init = function () {
        /**
         * Access to whitelist/blacklist domains before the proper initialization of localStorage leads to wrong caching of its values
         * To prevent it we should clear cached values
         * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/933
         */
        adguard.lazyGetClear(whiteListDomainsHolder, 'domains');
        adguard.lazyGetClear(blockListDomainsHolder, 'domains');
    };

    return {

        init: init,
        getRules: getRules,
        getWhiteListDomains: getWhiteListDomains,

        getWhiteListedDomains: getWhiteListedDomains,
        getBlockListedDomains: getBlockListedDomains,

        findWhiteListRule: findWhiteListRule,

        whiteListUrl: whiteListUrl,
        unWhiteListUrl: unWhiteListUrl,

        updateWhiteListDomains: updateWhiteListDomains,

        configure: configure,

        isDefaultMode: isDefaultWhiteListMode,
        changeDefaultWhiteListMode: changeDefaultWhiteListMode
    };

})(adguard);


/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Class for manage user rules
 */
adguard.userrules = (function (adguard) {
    'use strict';

    /**
     * Wraps access to getter. AntiBannerService hasn't been defined yet.
     * @returns {*}
     */
    function getAntiBannerService() {
        return adguard.antiBannerService;
    }

    /**
     * Adds list of rules to the user filter
     *
     * @param rulesText List of rules to add
     */
    const addRules = function (rulesText) {
        const rules = getAntiBannerService().addUserFilterRules(rulesText);
        return rules;
    };

    /**
     * Removes all user's custom rules
     */
    const clearRules = function () {
        getAntiBannerService().updateUserFilterRules([]);
    };

    /**
     * Removes user's custom rule
     *
     * @param ruleText Rule text
     */
    const removeRule = function (ruleText) {
        getAntiBannerService().removeUserFilterRule(ruleText);
    };

    /**
     * Save user rules text to storage
     * @param content Rules text
     */
    const updateUserRulesText = function (content) {
        const lines = content.length > 0 ? content.split(/\n/) : [];
        getAntiBannerService().updateUserFilterRules(lines);
    };

    /**
     * Loads user rules text from storage
     * @param callback Callback function
     */
    const getUserRulesText = function (callback) {
        adguard.rulesStorage.read(adguard.utils.filters.USER_FILTER_ID, (rulesText) => {
            const content = (rulesText || []).join('\n');
            callback(content);
        });
    };

    const unWhiteListFrame = function (frameInfo) {
        if (frameInfo.frameRule) {
            if (frameInfo.frameRule.filterId === adguard.utils.filters.WHITE_LIST_FILTER_ID) {
                adguard.whitelist.unWhiteListUrl(frameInfo.url);
            } else {
                removeRule(frameInfo.frameRule.ruleText);
            }
        }
    };

    return {
        addRules,
        clearRules,
        removeRule,
        updateUserRulesText,
        getUserRulesText,
        // TODO: fix
        unWhiteListFrame,
    };
})(adguard);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (adguard) {
    'use strict';

    /**
     * Simple request cache
     * @param requestCacheMaxSize Max cache size
     */
    const RequestCache = function (requestCacheMaxSize) {
        this.requestCache = Object.create(null);
        this.requestCacheSize = 0;
        this.requestCacheMaxSize = requestCacheMaxSize;

        /**
         * Searches for cached filter rule
         *
         * @param requestUrl Request url
         * @param refHost Referrer host
         * @param requestType Request type
         */
        this.searchRequestCache = function (requestUrl, refHost, requestType) {
            const cacheItem = this.requestCache[requestUrl];
            if (!cacheItem) {
                return null;
            }

            const c = cacheItem[requestType];
            if (c && c[1] === refHost) {
                return c;
            }

            return null;
        };

        /**
         * Saves resulting filtering rule to requestCache
         *
         * @param requestUrl Request url
         * @param rule Rule found
         * @param refHost Referrer host
         * @param requestType Request type
         */
        this.saveResultToCache = function (requestUrl, rule, refHost, requestType) {
            if (this.requestCacheSize > this.requestCacheMaxSize) {
                this.clearRequestCache();
            }
            if (!this.requestCache[requestUrl]) {
                this.requestCache[requestUrl] = Object.create(null);
                this.requestCacheSize += 1;
            }

            // Two-levels gives us an ability to not to override cached item for
            // different request types with the same url
            this.requestCache[requestUrl][requestType] = [rule, refHost];
        };

        /**
         * Clears request cache
         */
        this.clearRequestCache = function () {
            if (this.requestCacheSize === 0) {
                return;
            }
            this.requestCache = Object.create(null);
            this.requestCacheSize = 0;
        };
    };

    /**
     * Request filter is main class which applies filter rules.
     *
     * @type {Function}
     */
    const RequestFilter = function () {
        // Bad-filter rules collection
        // https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#badfilter-modifier
        this.badFilterRules = {};

        // Filter that applies URL blocking rules
        // Basic rules: https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#basic-rules
        this.urlBlockingFilter = new adguard.rules.UrlFilter([], this.badFilterRules);

        // Filter that applies whitelist rules
        // Exception rules: https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#exceptions-modifiers
        this.urlWhiteFilter = new adguard.rules.UrlFilter([], this.badFilterRules);

        // Filter that applies CSS rules
        // https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#cosmetic-rules
        this.cssFilter = new adguard.rules.CssFilter();

        // Filter that applies JS rules
        // https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#javascript-rules
        this.scriptFilter = new adguard.rules.ScriptFilter();

        // Filter that applies CSP rules
        // https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#csp-modifier
        this.cspFilter = new adguard.rules.CspFilter([], this.badFilterRules);

        // Filter that applies cookie rules
        // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/961
        this.cookieFilter = new adguard.rules.CookieFilter();

        // Filter that applies stealth rules
        // https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#stealth-modifier
        this.stealthFilter = new adguard.rules.UrlFilter([], this.badFilterRules);

        // Filter that applies replace rules
        // https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#replace-modifier
        this.replaceFilter = new adguard.rules.ReplaceFilter([], this.badFilterRules);

        // Filter that applies HTML filtering rules
        // https://kb.adguard.com/en/general/how-to-create-your-own-ad-filters#html-filtering-rules
        this.contentFilter = new adguard.rules.ContentFilter();

        // Rules count (includes all types of rules)
        this.rulesCount = 0;

        // Init small caches for url filtering rules
        this.urlBlockingCache = new RequestCache(this.requestCacheMaxSize);
        this.urlExceptionsCache = new RequestCache(this.requestCacheMaxSize);
    };

    RequestFilter.prototype = {

        /**
         * Cache capacity
         */
        requestCacheMaxSize: 1000,

        /**
         * Adds rules to the request filter
         *
         * @param rules List of rules to add
         */
        addRules(rules) {
            if (!rules) {
                return;
            }
            for (let i = 0; i < rules.length; i += 1) {
                this.addRule(rules[i]);
            }
        },

        /**
         * Adds rule to the request filter.
         * Rule is added to one of underlying filter objects depending on the rule type.
         *
         * @param rule     Rule to add. Rule should be an object of
         *                 one of these classes: UrlFilterRule, CssFilterRule, ScriptFilterRule
         */
        addRule(rule) {
            if (rule === null || !rule.ruleText) {
                adguard.console.error('FilterRule must not be null');
                return;
            }

            if (rule instanceof adguard.rules.UrlFilterRule) {
                if (typeof rule.isIgnored === 'function' && rule.isIgnored()) {
                    adguard.console.debug(`FilterRule with $extension modifier was omitted. Rule text: "${rule.ruleText}"`);
                    return;
                }
                if (rule.isCspRule() && !rule.isBadFilter()) {
                    this.cspFilter.addRule(rule);
                } else if (rule.isCookieRule()) {
                    this.cookieFilter.addRule(rule);
                } else if (rule.isStealthRule() && !rule.isBadFilter()) {
                    this.stealthFilter.addRule(rule);
                } else if (rule.isReplaceRule() && !rule.isBadFilter()) {
                    this.replaceFilter.addRule(rule);
                } else if (rule.isBadFilter()) {
                    this.badFilterRules[rule.badFilter] = rule;
                } else if (rule.whiteListRule) {
                    this.urlWhiteFilter.addRule(rule);
                } else {
                    this.urlBlockingFilter.addRule(rule);
                }
            } else if (rule instanceof adguard.rules.CssFilterRule) {
                this.cssFilter.addRule(rule);
            } else if (rule instanceof adguard.rules.ScriptFilterRule) {
                this.scriptFilter.addRule(rule);
            } else if (rule instanceof adguard.rules.ScriptletRule) {
                this.scriptFilter.addRule(rule);
            } else if (rule instanceof adguard.rules.CompositeRule) {
                rule.rules.forEach(this.addRule.bind(this));
            } else if (rule instanceof adguard.rules.ContentFilterRule) {
                this.contentFilter.addRule(rule);
            }

            this.rulesCount++;
            this.urlBlockingCache.clearRequestCache();
            this.urlExceptionsCache.clearRequestCache();
        },

        /**
         * Removes rule from the RequestFilter.
         * Rule is removed from one of underlying filters depending on the rule type.
         *
         * @param rule Rule to be removed
         */
        removeRule(rule) {
            if (rule === null) {
                adguard.console.error('FilterRule must not be null');
                return;
            }
            if (rule instanceof adguard.rules.UrlFilterRule) {
                if (rule.isCspRule()) {
                    this.cspFilter.removeRule(rule);
                } else if (rule.isCookieRule()) {
                    this.cookieFilter.removeRule(rule);
                } else if (rule.isStealthRule()) {
                    this.stealthFilter.removeRule(rule);
                } else if (rule.isBadFilter()) {
                    delete this.badFilterRules[rule.badFilter];
                } else if (rule.whiteListRule) {
                    this.urlWhiteFilter.removeRule(rule);
                } else {
                    this.urlBlockingFilter.removeRule(rule);
                }
            } else if (rule instanceof adguard.rules.CssFilterRule) {
                this.cssFilter.removeRule(rule);
            } else if (rule instanceof adguard.rules.ScriptFilterRule) {
                this.scriptFilter.removeRule(rule);
            } else if (rule instanceof adguard.rules.ScriptletRule) {
                this.scriptFilter.removeRule(rule);
            } else if (rule instanceof adguard.rules.CompositeRule) {
                rule.rules.forEach(this.removeRule.bind(this));
            } else if (rule instanceof adguard.rules.ContentFilterRule) {
                this.contentFilter.removeRule(rule);
            }
            this.rulesCount -= 1;
            this.urlBlockingCache.clearRequestCache();
            this.urlExceptionsCache.clearRequestCache();
        },

        /**
         * Returns the array of loaded rules
         */
        getRules() {
            let result = [];

            result = result.concat(this.urlWhiteFilter.getRules());
            result = result.concat(this.urlBlockingFilter.getRules());
            result = result.concat(this.cssFilter.getRules());
            result = result.concat(this.scriptFilter.getRules());
            result = result.concat(this.cspFilter.getRules());
            result = result.concat(this.cookieFilter.getRules());
            result = result.concat(this.stealthFilter.getRules());

            for (const badFilter in this.badFilterRules) {
                result.push(this.badFilterRules[badFilter]);
            }

            return result;
        },

        /**
         * An object with the information on the CSS and ExtendedCss stylesheets which
         * need to be injected into a web page.
         *
         * @typedef {Object} SelectorsData
         * @property {Array.<string>} css Regular CSS stylesheets
         * @property {Array.<string>} extendedCss ExtendedCSS stylesheets
         * @property {boolean} cssHitsCounterEnabled If true - collecting CSS rules hits stats
         * is enabled
         */

        /**
         * Builds CSS for the specified web page.
         * http://adguard.com/en/filterrules.html#hideRules
         *
         * @param {string} url Page URL
         * @param {number} options CssFilter bitmask
         * @returns {SelectorsData} CSS and ExtCss data for the webpage
         */
        getSelectorsForUrl(url, options) {
            const domain = adguard.utils.url.getHost(url);

            const { CSS_INJECTION_ONLY } = adguard.rules.CssFilter;
            const cssInjectionOnly = (options & CSS_INJECTION_ONLY) === CSS_INJECTION_ONLY;

            if (!cssInjectionOnly
                && adguard.webRequestService.isCollectingCosmeticRulesHits()) {
                /**
                 * If user has enabled "Send statistics for ad filters usage" option we
                 * build CSS with enabled hits stats. In this case style contains "content"
                 * with filter identifier and rule text.
                 */
                return this.cssFilter.buildCssHits(domain, options);
            }
            return this.cssFilter.buildCss(domain, options);
        },

        /**
         * Builds domain-specific JS injection for the specified page.
         * http://adguard.com/en/filterrules.html#javascriptInjection
         *
         * @param url Page URL
         * @param {boolean} debug enabled or disabled debug
         * @returns {{scriptSource: string, rule: string}[]} Javascript for the specified URL
         */
        getScriptsForUrl(url, debug) {
            const domain = adguard.utils.url.getHost(url);
            const config = {
                debug,
                domainName: domain,
                engine: 'extension',
                version: adguard.app && adguard.app.getVersion && adguard.app.getVersion(),
            };
            return this.scriptFilter.buildScript(domain, config);
        },

        /**
         * Builds the final output string for the specified page.
         * Depending on the browser we either allow or forbid the new remote rules
         * (see how `scriptSource` is used).
         *
         * @param {string} url Page URL
         * @returns {string} Script to be applied
         */
        getScriptsStringForUrl(url, tab) {
            const debug = adguard.filteringLog && adguard.filteringLog.isOpen();
            const scriptRules = this.getScriptsForUrl(url, debug);

            const isFirefox = adguard.utils.browser.isFirefoxBrowser();
            const isOpera = adguard.utils.browser.isOperaBrowser();

            const selectedScriptRules = scriptRules.filter((scriptRule) => {
                if (scriptRule.scriptSource === 'local') {
                    return true;
                }
                if (scriptRule.scriptSource === 'remote') {
                    /**
                     * Note (!) (Firefox, Opera):
                     * In case of Firefox and Opera add-ons,
                     * JS filtering rules are hardcoded into add-on code.
                     * Look at ScriptFilterRule.getScriptSource to learn more.
                     */
                    /* @if remoteScripts == false */
                    if (!isFirefox && !isOpera) {
                        return true;
                    }
                    /* @endif */

                    /* @if remoteScripts == true */
                    if (!isOpera) {
                        return true;
                    }
                    /* @endif */
                }
                return false;
            });

            if (debug) {
                const domainName = adguard.utils.url.getHost(url);
                scriptRules.forEach((scriptRule) => {
                    if (scriptRule.rule instanceof adguard.rules.ScriptletRule
                        || scriptRule.rule.isDomainSpecific(domainName)) {
                        adguard.filteringLog.addScriptInjectionEvent(
                            tab,
                            url,
                            adguard.RequestTypes.DOCUMENT,
                            scriptRule.rule
                        );
                    }
                });
            }

            const scriptsCode = selectedScriptRules.map(scriptRule => scriptRule.script).join('\r\n');

            return `
            (function () {
                try {
                    ${scriptsCode}
                } catch (ex) {
                    console.error('Error executing AG js: ' + ex);
                }
            })();
            `;
        },

        /**
         * Searches for the whitelist rule for the specified pair (url/referrer)
         *
         * @param requestUrl  Request URL
         * @param referrer    Referrer
         * @param requestType Request type
         * @returns Filter rule found or null
         */
        findWhiteListRule(requestUrl, referrer, requestType) {
            const refHost = adguard.utils.url.getHost(referrer);
            const thirdParty = adguard.utils.url.isThirdPartyRequest(requestUrl, referrer);

            const cacheItem = this.urlExceptionsCache.searchRequestCache(requestUrl, refHost, requestType);

            if (cacheItem) {
                // Element with zero index is a filter rule found last time
                return cacheItem[0];
            }

            const rule = this._checkWhiteList(requestUrl, refHost, requestType, thirdParty);

            this.urlExceptionsCache.saveResultToCache(requestUrl, rule, refHost, requestType);
            return rule;
        },

        /**
         * Searches for stealth whitelist rule for the specified pair (url/referrer)
         *
         * @param requestUrl  Request URL
         * @param referrer    Referrer
         * @param requestType Request type
         * @returns Filter rule found or null
         */
        findStealthWhiteListRule(requestUrl, referrer, requestType) {
            const refHost = adguard.utils.url.getHost(referrer);
            const thirdParty = adguard.utils.url.isThirdPartyRequest(requestUrl, referrer);

            // Check if request is whitelisted with document wide rule
            // e.g. "@@||example.org^$stealth"
            let rule = this.stealthFilter.isFiltered(referrer, refHost, requestType, thirdParty);

            if (!rule) {
                // Check if request is whitelisted with third-party request
                // e.g. "@@||example.org^$domain=ya.ru,stealth"
                rule = this.stealthFilter.isFiltered(requestUrl, refHost, requestType, thirdParty);
            }

            return rule;
        },

        /**
         * Searches for the filter rule for the specified request.
         *
         * @param requestUrl            Request URL
         * @param documentUrl           Document URL
         * @param requestType           Request content type (one of UrlFilterRule.contentTypes)
         * @param documentWhitelistRule (optional) Document-level whitelist rule
         * @returns Rule found or null
         */
        findRuleForRequest(requestUrl, documentUrl, requestType, documentWhitelistRule) {
            const documentHost = adguard.utils.url.getHost(documentUrl);
            const thirdParty = adguard.utils.url.isThirdPartyRequest(requestUrl, documentUrl);

            const cacheItem = this.urlBlockingCache.searchRequestCache(requestUrl, documentHost, requestType);
            if (cacheItem) {
                // Element with zero index is a filter rule found last time
                return cacheItem[0];
            }

            const rule = this._findRuleForRequest(requestUrl, documentHost, requestType, thirdParty, documentWhitelistRule);

            this.urlBlockingCache.saveResultToCache(requestUrl, rule, documentHost, requestType);
            return rule;
        },

        /**
         * Searches for content rules for the specified domain
         * @param documentUrl Document URL
         * @returns Collection of content rules
         */
        getContentRulesForUrl(documentUrl) {
            const documentHost = adguard.utils.url.getHost(documentUrl);
            return this.contentFilter.getRulesForDomain(documentHost);
        },

        /**
         * Searches for elements in document that matches given content rules
         * @param doc Document
         * @param rules Content rules
         * @returns Matched elements
         */
        getMatchedElementsForContentRules(doc, rules) {
            return this.contentFilter.getMatchedElementsForRules(doc, rules);
        },

        /**
         * Searches for CSP rules for the specified request
         * @param requestUrl Request URL
         * @param documentUrl Document URL
         * @param requestType Request Type (DOCUMENT or SUBDOCUMENT)
         * @returns Collection of CSP rules for applying to the request or null
         */
        findCspRules(requestUrl, documentUrl, requestType) {
            const documentHost = adguard.utils.url.getHost(documentUrl);
            const thirdParty = adguard.utils.url.isThirdPartyRequest(requestUrl, documentUrl);
            return this.cspFilter.findCspRules(requestUrl, documentHost, thirdParty, requestType);
        },

        findReplaceRules(requestUrl, documentUrl, requestType) {
            const documentHost = adguard.utils.url.getHost(documentUrl);
            const thirdParty = adguard.utils.url.isThirdPartyRequest(requestUrl, documentUrl);

            return this.replaceFilter.findReplaceRules(requestUrl, documentHost, thirdParty, requestType);
        },

        /**
         * Searches for cookie rules matching specified request.
         *
         * @param requestUrl Request URL
         * @param documentUrl Document URL
         * @param requestType   Request content type
         * @returns             Matching rules
         */
        findCookieRules(requestUrl, documentUrl, requestType) {
            const documentHost = adguard.utils.url.getHost(documentUrl);
            const thirdParty = adguard.utils.url.isThirdPartyRequest(requestUrl, documentUrl);

            return this.cookieFilter.findCookieRules(requestUrl, documentHost, thirdParty, requestType);
        },

        /**
         * Checks if exception rule is present for the URL/Referrer pair
         *
         * @param requestUrl    Request URL
         * @param documentHost  Document URL host
         * @param requestType   Request content type (one of UrlFilterRule.contentTypes)
         * @param thirdParty    Is request third-party or not
         * @returns Filter rule found or null
         * @private
         */
        _checkWhiteList(requestUrl, documentHost, requestType, thirdParty) {
            if (this.urlWhiteFilter === null || !requestUrl) {
                return null;
            }
            return this.urlWhiteFilter.isFiltered(requestUrl, documentHost, requestType, thirdParty);
        },

        /**
         * Checks if there is a rule blocking this request
         *
         * @param requestUrl    Request URL
         * @param refHost       Referrer host
         * @param requestType   Request content type (one of UrlFilterRule.contentTypes)
         * @param thirdParty    Is request third-party or not
         * @param genericRulesAllowed    Is generic rules allowed
         * @returns Filter rule found or null
         * @private
         */
        _checkUrlBlockingList(requestUrl, refHost, requestType, thirdParty, genericRulesAllowed) {
            if (this.urlBlockingFilter === null || !requestUrl) {
                return null;
            }

            return this.urlBlockingFilter.isFiltered(
                requestUrl,
                refHost,
                requestType,
                thirdParty,
                !genericRulesAllowed
            );
        },

        /**
         * Searches the rule for request.
         *
         * @param requestUrl    Request URL
         * @param documentHost  Document host
         * @param requestType   Request content type (one of UrlFilterRule.contentTypes)
         * @param thirdParty    Is request third-party or not
         * @param documentWhiteListRule (optional) Document-level whitelist rule
         * @returns Filter rule found or null
         * @private
         */
        _findRuleForRequest(requestUrl, documentHost, requestType, thirdParty, documentWhiteListRule) {
            adguard.console.debug('Filtering http request for url: {0}, document: {1}, requestType: {2}', requestUrl, documentHost, requestType);

            // STEP 1: Looking for exception rule, which could be applied to the current request

            // Checks white list for a rule for this RequestUrl.
            // If something is found - returning it.
            const urlWhiteListRule = this._checkWhiteList(
                requestUrl,
                documentHost,
                requestType,
                thirdParty
            );

            // If UrlBlock is set - than we should not use UrlBlockingFilter against this request.
            // Now check if document rule has $genericblock or $urlblock modifier
            const genericRulesAllowed = !documentWhiteListRule
                || !documentWhiteListRule.isGenericBlock();

            const urlRulesAllowed = !documentWhiteListRule || !documentWhiteListRule.isUrlBlock();

            // STEP 2: Looking for blocking rule, which could be applied to the current request

            const ruleForRequest = this._checkUrlBlockingList(
                requestUrl,
                documentHost,
                requestType,
                thirdParty,
                genericRulesAllowed
            );

            // STEP 3: Analyze results, first - basic exception rule

            if (urlWhiteListRule
                // Please note, that if blocking rule has $important modifier, it could
                // overcome existing exception rule
                && (urlWhiteListRule.isImportant
                    || !ruleForRequest
                    || !ruleForRequest.isImportant)) {
                adguard.console.debug(
                    'White list rule found {0} for url: {1} document: {2}, requestType: {3}',
                    urlWhiteListRule.ruleText,
                    requestUrl,
                    documentHost,
                    requestType
                );
                return urlWhiteListRule;
            }

            if (!genericRulesAllowed || !urlRulesAllowed) {
                adguard.console.debug(
                    'White list rule {0} found for document: {1}',
                    documentWhiteListRule.ruleText,
                    documentHost
                );
            }

            if (!urlRulesAllowed) {
                // URL whitelisted
                return documentWhiteListRule;
            }

            if (ruleForRequest) {
                adguard.console.debug(
                    'Black list rule {0} found for url: {1}, document: {2}, requestType: {3}',
                    ruleForRequest.ruleText,
                    requestUrl,
                    documentHost,
                    requestType
                );
            }

            return ruleForRequest;
        },
    };

    adguard.RequestFilter = RequestFilter;
})(adguard);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Creating service that manages our filter rules.
 */
adguard.antiBannerService = (function (adguard) {
    // Add synthetic user filter
    const userFilter = { filterId: adguard.utils.filters.USER_FILTER_ID };

    // Request filter contains all filter rules
    // This class does the actual filtering (checking URLs, constructing CSS/JS to inject, etc)
    let requestFilter = new adguard.RequestFilter();

    // Service is not initialized yet
    let requestFilterInitTime = 0;

    // Application is running flag
    let applicationRunning = false;

    // Application initialized flag (Sets on first call of 'start' method)
    let applicationInitialized = false;

    // Get filters update period
    let filtersUpdatePeriod = adguard.settings.getFiltersUpdatePeriod();

    /**
     * Delay before doing first filters update check -- 5 minutes
     */
    const UPDATE_FILTERS_DELAY = 5 * 60 * 1000;

    /**
     * Delay on application updated event
     */
    const APP_UPDATED_NOTIFICATION_DELAY = 60 * 1000;

    const FILTERS_CHANGE_DEBOUNCE_PERIOD = 1000;
    const RELOAD_FILTERS_DEBOUNCE_PERIOD = 1000;

    /**
     * List of events which cause RequestFilter re-creation
     * @type {Array}
     */
    const UPDATE_REQUEST_FILTER_EVENTS = [
        adguard.listeners.UPDATE_FILTER_RULES,
        adguard.listeners.FILTER_ENABLE_DISABLE,
        adguard.listeners.FILTER_GROUP_ENABLE_DISABLE,
    ];

    const isUpdateRequestFilterEvent = el => UPDATE_REQUEST_FILTER_EVENTS.indexOf(el.event) >= 0;

    /**
     * List of events which cause saving filter rules to the rules storage
     * @type {Array}
     */
    const SAVE_FILTER_RULES_TO_STORAGE_EVENTS = [
        adguard.listeners.UPDATE_FILTER_RULES,
        adguard.listeners.ADD_RULES,
        adguard.listeners.REMOVE_RULE,
    ];

    const isSaveRulesToStorageEvent = function (el) {
        return SAVE_FILTER_RULES_TO_STORAGE_EVENTS.indexOf(el.event) >= 0;
    };

    let reloadedRules = false;

    /**
     * AntiBannerService initialize method. Process install, update or simple run.
     * @param options Constructor options
     * @param callback
     */
    function initialize(options, callback) {
        /**
         * Waits and notifies listener with application updated event
         *
         * @param runInfo
         */
        const notifyApplicationUpdated = function (runInfo) {
            setTimeout(() => {
                adguard.listeners.notifyListeners(adguard.listeners.APPLICATION_UPDATED, runInfo);
            }, APP_UPDATED_NOTIFICATION_DELAY);
        };

        /**
         * This method is called when filter subscriptions have been loaded from remote server.
         * It is used to recreate RequestFilter object.
         */
        const initRequestFilter = function () {
            loadFiltersVersionAndStateInfo();
            loadGroupsStateInfo();
            createRequestFilter(() => {
                addFiltersChangeEventListener();
                callback();
            });
        };

        /**
         * Callback for subscriptions loaded event
         */
        const onSubscriptionLoaded = function (runInfo) {
            // Subscribe to events which lead to update filters (e.g. swith to optimized and back to default)
            subscribeToFiltersChangeEvents();

            if (runInfo.isFirstRun) {
                // Add event listener for filters change
                addFiltersChangeEventListener();
                // Run callback
                // Request filter will be initialized during install
                if (typeof options.onInstall === 'function') {
                    options.onInstall(callback);
                } else {
                    callback();
                }
            } else if (runInfo.isUpdate) {
                // Updating storage schema on extension update (if needed)
                adguard.applicationUpdateService.onUpdate(runInfo, initRequestFilter);
                // Show updated version popup
                notifyApplicationUpdated(runInfo);
            } else {
                // Init RequestFilter object
                initRequestFilter();
            }
            // Schedule filters update job
            scheduleFiltersUpdate(runInfo.isFirstRun);
        };

        /**
         * Init extension common info.
         */
        adguard.applicationUpdateService.getRunInfo(async (runInfo) => {
            // Load subscription from the storage
            await adguard.subscriptions.init();
            onSubscriptionLoaded(runInfo);
        });
    }

    /**
     * Initialize application (process install or update) . Create and start request filter
     * @param options
     * @param callback
     */
    const start = function (options, callback) {
        if (applicationRunning === true) {
            callback();
            return;
        }
        applicationRunning = true;

        if (!applicationInitialized) {
            initialize(options, callback);
            applicationInitialized = true;
            return;
        }

        createRequestFilter(callback);
    };

    /**
     * Clear request filter
     */
    const stop = function () {
        applicationRunning = false;
        requestFilter = new adguard.RequestFilter();
        adguard.listeners.notifyListeners(adguard.listeners.REQUEST_FILTER_UPDATED, getRequestFilterInfo());
    };

    /**
     * Checks application has been initialized
     * @returns {boolean}
     */
    const isInitialized = function () {
        return applicationInitialized;
    };

    /**
     * Getter for request filter
     */
    const getRequestFilter = function () {
        return requestFilter;
    };

    /**
     * Loads filter from storage (if in extension package) or from backend
     *
     * @param filterId Filter identifier
     * @param callback Called when operation is finished
     */
    const addAntiBannerFilter = (filterId, callback) => {
        const filter = getFilterById(filterId);
        if (filter.installed) {
            callback(true);
            return;
        }

        const onFilterLoaded = (success) => {
            if (success) {
                filter.installed = true;
                adguard.listeners.notifyListeners(adguard.listeners.FILTER_ADD_REMOVE, filter);
            }
            callback(success);
        };

        if (filter.loaded) {
            onFilterLoaded(true);
            return;
        }

        /**
         * TODO: when we want to load filter from backend,
         *  we should retrieve metadata from backend too, but not from local file.
         */
        loadFilterRules(filter, false, onFilterLoaded);
    };

    /**
     * Reloads filters from backend
     *
     * @param successCallback
     * @param errorCallback
     * @private
     */
    function reloadAntiBannerFilters(successCallback, errorCallback) {
        resetFiltersVersion();
        checkAntiBannerFiltersUpdate(true, successCallback, errorCallback);
    }

    /**
     * Gets expires in sec end return in ms
     * If expires was less then minimumExpiresTime or we couldn't parse its value,
     * then return minimumExpiresTime
     * @param {*} expires
     * @returns {number}
     */
    const normalizeExpires = (expires) => {
        const minimumExpiresSec = 60 * 60;

        expires = Number.parseInt(expires, 10);

        if (Number.isNaN(expires) || expires < minimumExpiresSec) {
            expires = minimumExpiresSec;
        }

        return expires * 1000;
    };

    /**
     * Select filters for update. It depends on the time of last update,
     * on the filter enable status and group enable status
     * @param forceUpdate Force update flag.
     * @param filtersToUpdate Optional array of filters
     * @returns object
     */
    function selectFilterIdsToUpdate(forceUpdate, filtersToUpdate) {
        const filterIds = [];
        const customFilterIds = [];
        const filters = filtersToUpdate || adguard.subscriptions.getFilters();

        const needUpdate = (filter) => {
            const { lastCheckTime } = filter;
            let { expires } = filter;

            if (!lastCheckTime) {
                return true;
            }

            expires = normalizeExpires(expires);
            if (filtersUpdatePeriod === adguard.settings.DEFAULT_FILTERS_UPDATE_PERIOD) {
                return lastCheckTime + expires <= Date.now();
            }

            return lastCheckTime + filtersUpdatePeriod <= Date.now();
        };

        for (let i = 0; i < filters.length; i += 1) {
            const filter = filters[i];
            const group = adguard.subscriptions.getGroup(filter.groupId);
            if (filter.installed && filter.enabled && group.enabled) {
                if (forceUpdate || needUpdate(filter)) {
                    if (filter.customUrl) {
                        customFilterIds.push(filter.filterId);
                    } else {
                        filterIds.push(filter.filterId);
                    }
                }
            }
        }

        return {
            filterIds,
            customFilterIds,
        };
    }

    /**
     * Checks filters updates.
     *
     * @param forceUpdate Normally we respect filter update period. But if this parameter is
     *                    true - we ignore it and check updates for all filters.
     * @param successCallback Called if filters were updated successfully
     * @param errorCallback Called if something gone wrong
     * @param filters     Optional Array of filters to update
     */
    const checkAntiBannerFiltersUpdate = (forceUpdate, successCallback, errorCallback, filters) => {
        const noop = () => {}; // empty callback
        successCallback = successCallback || noop;
        errorCallback = errorCallback || noop;

        // Don't update in background if request filter isn't running
        if (!forceUpdate && !applicationRunning) {
            return;
        }

        adguard.console.info('Start checking filters updates');

        // Select filters for update
        const toUpdate = selectFilterIdsToUpdate(forceUpdate, filters);
        const filterIdsToUpdate = toUpdate.filterIds;
        const customFilterIdsToUpdate = toUpdate.customFilterIds;

        const totalToUpdate = filterIdsToUpdate.length + customFilterIdsToUpdate.length;
        if (totalToUpdate === 0) {
            successCallback([]);
            adguard.console.info('There is no filters to update');
            return;
        }

        adguard.console.info('Checking updates for {0} filters', totalToUpdate);

        // Load filters with changed version
        const loadFiltersFromBackendCallback = (filterMetadataList) => {
            loadFiltersFromBackend(filterMetadataList, (success, filterIds) => {
                if (success) {
                    const filters = filterIds
                        .map(adguard.subscriptions.getFilter)
                        .filter(f => f);

                    updateCustomFilters(customFilterIdsToUpdate, (customFilters) => {
                        successCallback(filters.concat(customFilters));
                    });
                } else {
                    errorCallback();
                }
            });
        };


        /**
         * Method is called after we have got server response
         * Now we check filters version and update filter if needed
         * @param success
         * @param filterMetadataList
         */
        const onLoadFilterMetadataList = (success, filterMetadataList) => {
            if (success) {
                const filterMetadataListToUpdate = [];
                for (let i = 0; i < filterMetadataList.length; i += 1) {
                    const filterMetadata = filterMetadataList[i];
                    const filter = adguard.subscriptions.getFilter(filterMetadata.filterId);
                    if (filter && filterMetadata.version && adguard.utils.browser.isGreaterVersion(filterMetadata.version, filter.version)) {
                        adguard.console.info(`Updating filter ${filter.filterId} to version ${filterMetadata.version}`);
                        filterMetadataListToUpdate.push(filterMetadata);
                    } else {
                        // remember that this filter version was checked
                        filter.lastCheckTime = Date.now();
                    }
                }
                loadFiltersFromBackendCallback(filterMetadataListToUpdate);
            } else {
                errorCallback();
            }
        };

        // Retrieve current filters metadata for update
        loadFiltersMetadataFromBackend(filterIdsToUpdate, onLoadFilterMetadataList);
    };

    /**
     * Update filters with custom urls
     *
     * @param customFilterIds
     * @param callback
     */
    function updateCustomFilters(customFilterIds, callback) {
        if (customFilterIds.length === 0) {
            callback([]);
            return;
        }

        const promises = customFilterIds.map(filterId => new Promise((resolve) => {
            const filter = adguard.subscriptions.getFilter(filterId);
            const onUpdate = (updatedFilterId) => {
                if (updatedFilterId) {
                    return resolve(filter);
                }
                return resolve();
            };
            adguard.subscriptions.updateCustomFilter(filter.customUrl, {}, onUpdate);
        }));

        Promise.all(promises).then((filters) => {
            const updatedFilters = filters.filter(f => f);
            if (updatedFilters.length > 0) {
                const filterIdsString = updatedFilters.map(f => f.filterId).join(', ');
                adguard.console.info(`Updated custom filters with ids: ${filterIdsString}`);
            }

            callback(updatedFilters);
        });
    }

    /**
     * Resets all filters versions
     */
    function resetFiltersVersion() {
        const RESET_VERSION = '0.0.0.0';

        const filters = adguard.subscriptions.getFilters();
        for (let i = 0; i < filters.length; i += 1) {
            const filter = filters[i];
            filter.version = RESET_VERSION;
        }
    }

    /**
     * Updates groups state info
     * Loads state info from the storage and then updates adguard.subscription.groups properly
     * @private
     */
    function loadGroupsStateInfo() {
        // Load filters state from the storage
        const groupsStateInfo = adguard.filtersState.getGroupsState();

        const groups = adguard.subscriptions.getGroups();

        for (let i = 0; i < groups.length; i += 1) {
            const group = groups[i];
            const { groupId } = group;
            const stateInfo = groupsStateInfo[groupId];
            if (stateInfo) {
                group.enabled = stateInfo.enabled;
            }
        }
    }

    /**
     * Updates filters version and state info.
     * Loads this data from the storage and then updates adguard.subscription.filters property
     *
     * @private
     */
    function loadFiltersVersionAndStateInfo() {
        // Load filters metadata from the storage
        const filtersVersionInfo = adguard.filtersState.getFiltersVersion();
        // Load filters state from the storage
        const filtersStateInfo = adguard.filtersState.getFiltersState();

        const filters = adguard.subscriptions.getFilters();

        for (let i = 0; i < filters.length; i += 1) {
            const filter = filters[i];
            const { filterId } = filter;
            const versionInfo = filtersVersionInfo[filterId];
            const stateInfo = filtersStateInfo[filterId];
            if (versionInfo) {
                filter.version = versionInfo.version;
                filter.lastCheckTime = versionInfo.lastCheckTime;
                filter.lastUpdateTime = versionInfo.lastUpdateTime;
                if (versionInfo.expires) {
                    filter.expires = versionInfo.expires;
                }
            }
            if (stateInfo) {
                filter.enabled = stateInfo.enabled;
                filter.installed = stateInfo.installed;
                filter.loaded = stateInfo.loaded;
            }
        }
    }

    /**
     * Called when filters were loaded from the storage
     *
     * @param rulesFilterMap Map for populating rules (filterId -> rules collection)
     * @param callback Called when request filter is initialized
     */
    function onFiltersLoadedFromStorage(rulesFilterMap, callback) {
        const start = new Date().getTime();

        // UI thread becomes blocked on the options page while request filter is created
        // that't why we create filter rules using chunks of the specified length
        // Request filter creation is rather slow operation so we should
        // use setTimeout calls to give UI thread some time.
        const async = adguard.requestFilter.isReady();
        const asyncStep = 1000;
        adguard.console.info('Starting request filter initialization. Async={0}', async);

        // Empty request filter
        const newRequestFilter = new adguard.RequestFilter();

        if (requestFilterInitTime === 0) {
            // Setting the time of request filter very first initialization
            requestFilterInitTime = new Date().getTime();
            adguard.listeners.notifyListeners(adguard.listeners.APPLICATION_INITIALIZED);
        }

        // Supplement object to make sure that we use only unique filter rules
        const uniqueRules = Object.create(null);

        /**
         * Checks rulesFilterMap is empty (no one of filters are enabled)
         * @param rulesFilterMap
         * @returns {boolean}
         */
        function isEmptyRulesFilterMap(rulesFilterMap) {
            const enabledFilterIds = Object.keys(rulesFilterMap);
            if (enabledFilterIds.length === 0) {
                return true;
            }

            // User filter is enabled by default, but it may not contain any rules
            const userFilterId = adguard.utils.filters.USER_FILTER_ID;
            if (enabledFilterIds.length === 1 && enabledFilterIds[0] == userFilterId) {
                const userRules = rulesFilterMap[userFilterId];
                if (!userRules || userRules.length === 0) {
                    return true;
                }
            }

            return false;
        }

        /**
         * STEP 3: Called when request filter has been filled with rules.
         * This is the last step of request filter initialization.
         */
        const requestFilterInitialized = function () {
            // Request filter is ready
            requestFilter = newRequestFilter;

            if (callback && typeof callback === 'function') {
                callback();
            }

            adguard.listeners.notifyListeners(adguard.listeners.REQUEST_FILTER_UPDATED, getRequestFilterInfo());
            adguard.console.info(
                'Finished request filter initialization in {0} ms. Rules count: {1}',
                (new Date().getTime() - start),
                newRequestFilter.rulesCount
            );

            /**
             * If no one of filters is enabled, don't reload rules
             */
            if (isEmptyRulesFilterMap(rulesFilterMap)) {
                return;
            }

            if (newRequestFilter.rulesCount === 0 && !reloadedRules) {
                // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/205
                adguard.console.info('No rules have been found - checking filter updates');
                reloadAntiBannerFilters();
                reloadedRules = true;
            } else if (newRequestFilter.rulesCount > 0 && reloadedRules) {
                adguard.console.info('Filters reloaded, deleting reloadRules flag');
                reloadedRules = false;
            }
        };

        /**
         * Supplement function for adding rules to the request filter
         *
         * @param filterId Filter identifier
         * @param rulesTexts Array with filter rules
         * @param startIdx Start index of the rules array
         * @param endIdx End index of the rules array
         */
        const addRules = function (filterId, rulesTexts, startIdx, endIdx) {
            if (!rulesTexts) {
                return;
            }

            const isTrustedFilter = adguard.subscriptions.isTrustedFilter(filterId);

            for (let i = startIdx; i < rulesTexts.length && i < endIdx; i += 1) {
                const ruleText = rulesTexts[i];
                if (ruleText in uniqueRules) {
                    // Do not allow duplicates
                    continue;
                }
                uniqueRules[ruleText] = true;
                const rule = adguard.rules.builder.createRule(ruleText, filterId, isTrustedFilter);

                if (rule !== null) {
                    newRequestFilter.addRule(rule);
                }
            }
        };

        /**
         * Asynchronously adds rules to the request filter.
         */
        const addRulesAsync = (filterId, rulesTexts, startIdx, stopIdx, prevPromise) => new Promise((resolve) => {
            prevPromise.then(() => {
                setTimeout(() => {
                    addRules(filterId, rulesTexts, startIdx, stopIdx);
                    resolve();
                }, 1);
            });
        });

        /**
         * Asynchronously fills request filter with rules.
         */
        const fillRequestFilterAsync = function () {
            const rootPromise = Promise.resolve();
            let prevPromise = null;
            const promises = [];

            // Go through all filters in the map
            for (let filterId in rulesFilterMap) { // jshint ignore:line
                // To number
                filterId -= 0;
                if (filterId !== adguard.utils.filters.USER_FILTER_ID) {
                    const rulesTexts = rulesFilterMap[filterId];

                    for (let i = 0; i < rulesTexts.length; i += asyncStep) {
                        prevPromise = addRulesAsync(filterId, rulesTexts, i, i + asyncStep, prevPromise || rootPromise);
                        promises.push(prevPromise);
                    }
                }
            }

            // User filter should be the last
            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/117
            const userFilterId = adguard.utils.filters.USER_FILTER_ID;
            const userRules = rulesFilterMap[userFilterId];
            const startIndex = 0;
            const endIndex = userRules.length;
            prevPromise = addRulesAsync(userFilterId, userRules, startIndex, endIndex, prevPromise || rootPromise);
            promises.push(prevPromise);

            Promise.all(promises).then(() => {
                requestFilterInitialized();
            });
        };

        /**
         * Synchronously fills request filter with rules
         */
        const fillRequestFilterSync = function () {
            // Go through all filters in the map
            for (let filterId in rulesFilterMap) { // jshint ignore:line
                // To number
                filterId -= 0;
                if (filterId != adguard.utils.filters.USER_FILTER_ID) {
                    const rulesTexts = rulesFilterMap[filterId];
                    addRules(filterId, rulesTexts, 0, rulesTexts.length);
                }
            }

            // User filter should be the last
            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/117
            const userRules = rulesFilterMap[adguard.utils.filters.USER_FILTER_ID];
            addRules(adguard.utils.filters.USER_FILTER_ID, userRules, 0, userRules.length);
            requestFilterInitialized();
        };

        if (async) {
            fillRequestFilterAsync();
        } else {
            fillRequestFilterSync();
        }
    }

    /**
     * Create new request filter and add distinct rules from the storage.
     *
     * @param callback Called after request filter has been created
     * @private
     */
    function createRequestFilter(callback) {
        if (applicationRunning === false) {
            if (typeof callback === 'function') {
                callback();
            }
            return;
        }

        const start = new Date().getTime();
        adguard.console.info('Starting loading filter rules from the storage');

        // Prepare map for filter rules
        // Map key is filter ID
        // Map value is array with filter rules
        const rulesFilterMap = Object.create(null);

        /**
         * STEP 2: Called when all filter rules have been loaded from storage
         */
        const loadAllFilterRulesDone = function () {
            adguard.console.info('Finished loading filter rules from the storage in {0} ms', (new Date().getTime() - start));
            onFiltersLoadedFromStorage(rulesFilterMap, callback);
        };

        /**
         * Loads filter rules from storage
         *
         * @param filterId Filter identifier
         * @param rulesFilterMap Map for loading rules
         * @returns {*} Deferred object
         */
        const loadFilterRulesFromStorage = (filterId, rulesFilterMap) => new Promise((resolve) => {
            adguard.rulesStorage.read(filterId, (rulesText) => {
                if (rulesText) {
                    rulesFilterMap[filterId] = rulesText;
                }
                resolve();
            });
        });

        /**
         * STEP 1: load all filters from the storage.
         */
        const loadFilterRules = function () {
            const promises = [];
            const filters = adguard.subscriptions.getFilters();
            for (let i = 0; i < filters.length; i += 1) {
                const filter = filters[i];
                const group = adguard.subscriptions.getGroup(filter.groupId);
                if (filter.enabled && group.enabled) {
                    promises.push(loadFilterRulesFromStorage(filter.filterId, rulesFilterMap));
                }
            }
            // get user filter rules from storage
            promises.push(loadFilterRulesFromStorage(adguard.utils.filters.USER_FILTER_ID, rulesFilterMap));

            // Load all filters and then recreate request filter
            Promise.all(promises).then(loadAllFilterRulesDone);
        };

        loadFilterRules();
    }

    /**
     * Request Filter info
     */
    var getRequestFilterInfo = function () {
        let rulesCount = 0;
        if (requestFilter) {
            rulesCount = requestFilter.rulesCount;
        }
        return {
            rulesCount,
        };
    };

    /**
     * Adds event listener for filters changes.
     * If filter is somehow changed this method checks if we should save changes to the storage
     * and if we should recreate RequestFilter.
     *
     * @private
     */
    function addFiltersChangeEventListener() {
        let filterEventsHistory = [];
        let onFilterChangeTimeout = null;

        const processEventsHistory = function () {
            const filterEvents = filterEventsHistory.slice(0);
            filterEventsHistory = [];
            onFilterChangeTimeout = null;

            const needCreateRequestFilter = filterEvents.some(isUpdateRequestFilterEvent);

            // Split by filterId
            const eventsByFilter = Object.create(null);
            for (let i = 0; i < filterEvents.length; i += 1) {
                const filterEvent = filterEvents[i];
                // don't add group events
                if (!filterEvent.filter) {
                    continue;
                }
                if (!(filterEvent.filter.filterId in eventsByFilter)) {
                    eventsByFilter[filterEvent.filter.filterId] = [];
                }
                eventsByFilter[filterEvent.filter.filterId].push(filterEvent);
            }

            const dfds = [];
            for (const filterId in eventsByFilter) {
                const needSaveRulesToStorage = eventsByFilter[filterId].some(isSaveRulesToStorageEvent);
                if (!needSaveRulesToStorage) {
                    continue;
                }
                const dfd = processSaveFilterRulesToStorageEvents(filterId, eventsByFilter[filterId]);
                dfds.push(dfd);
            }

            if (needCreateRequestFilter) {
                // Rules will be added to request filter lazy, listeners will be notified about REQUEST_FILTER_UPDATED later
                adguard.utils.Promise.all(dfds).then(createRequestFilter);
            } else {
                // Rules are already in request filter, notify listeners
                adguard.listeners.notifyListeners(adguard.listeners.REQUEST_FILTER_UPDATED, getRequestFilterInfo());
            }
        };

        const processFilterEvent = function (event, filter, rules) {
            filterEventsHistory.push({ event, filter, rules });

            if (onFilterChangeTimeout !== null) {
                clearTimeout(onFilterChangeTimeout);
            }

            onFilterChangeTimeout = setTimeout(processEventsHistory, FILTERS_CHANGE_DEBOUNCE_PERIOD);
        };

        const processGroupEvent = function (event, group) {
            filterEventsHistory.push({ event, group });

            if (onFilterChangeTimeout !== null) {
                clearTimeout(onFilterChangeTimeout);
            }

            onFilterChangeTimeout = setTimeout(processEventsHistory, FILTERS_CHANGE_DEBOUNCE_PERIOD);
        };

        adguard.listeners.addListener((event, filter, rules) => {
            switch (event) {
                case adguard.listeners.ADD_RULES:
                case adguard.listeners.REMOVE_RULE:
                case adguard.listeners.UPDATE_FILTER_RULES:
                case adguard.listeners.FILTER_ENABLE_DISABLE:
                    processFilterEvent(event, filter, rules);
                    break;
                default: break;
            }
        });

        adguard.listeners.addListener((event, group) => {
            switch (event) {
                case adguard.listeners.FILTER_GROUP_ENABLE_DISABLE:
                    processGroupEvent(event, group);
                    break;
                default:
                    break;
            }
        });
    }

    /**
     * Saves updated filter rules to the storage.
     *
     * @param filterId Filter id
     * @param events Events (what has changed?)
     * @private
     */
    function processSaveFilterRulesToStorageEvents(filterId, events) {
        const dfd = new adguard.utils.Promise();

        adguard.rulesStorage.read(filterId, (loadedRulesText) => {

            for (let i = 0; i < events.length; i += 1) {
                if (!loadedRulesText) {
                    loadedRulesText = [];
                }

                const event = events[i];
                const eventType = event.event;
                const eventRules = event.rules;

                switch (eventType) {
                    case adguard.listeners.ADD_RULES:
                        loadedRulesText = loadedRulesText.concat(eventRules);
                        adguard.console.debug('Add {0} rules to filter {1}', eventRules.length, filterId);
                        break;
                    case adguard.listeners.REMOVE_RULE:
                        var actionRule = eventRules[0];
                        adguard.utils.collections.removeAll(loadedRulesText, actionRule);
                        adguard.console.debug('Remove {0} rule from filter {1}', actionRule, filterId);
                        break;
                    case adguard.listeners.UPDATE_FILTER_RULES:
                        loadedRulesText = eventRules;
                        adguard.console.debug('Update filter {0} rules count to {1}', filterId, eventRules.length);
                        break;
                }
            }

            adguard.console.debug('Save {0} rules to filter {1}', loadedRulesText.length, filterId);
            adguard.rulesStorage.write(filterId, loadedRulesText, () => {
                dfd.resolve();
                if (filterId === adguard.utils.filters.USER_FILTER_ID) {
                    adguard.listeners.notifyListeners(
                        adguard.listeners.UPDATE_USER_FILTER_RULES,
                        getRequestFilterInfo()
                    );
                }
            });
        });

        return dfd;
    }

    /**
     * Subscribe to events which lead to filters update.
     * @private
     */
    function subscribeToFiltersChangeEvents() {
        // on USE_OPTIMIZED_FILTERS setting change we need to reload filters
        const onUsedOptimizedFiltersChange = adguard.utils.concurrent.debounce(
            reloadAntiBannerFilters,
            RELOAD_FILTERS_DEBOUNCE_PERIOD
        );

        adguard.settings.onUpdated.addListener((setting) => {
            if (setting === adguard.settings.USE_OPTIMIZED_FILTERS) {
                onUsedOptimizedFiltersChange();
                return;
            }
            if (setting === adguard.settings.DISABLE_COLLECT_HITS) {
                getRequestFilter().cssFilter.dirty = true;
            }
            if (setting === adguard.settings.FILTERS_UPDATE_PERIOD) {
                scheduleFiltersUpdate();
            }
        });
    }

    // Scheduling job
    let scheduleUpdateTimeoutId;
    function scheduleUpdate() {
        const checkTimeout = 1000 * 60 * 30;
        if (scheduleUpdateTimeoutId) {
            clearTimeout(scheduleUpdateTimeoutId);
        }

        // don't update filters if filters update period is equal to 0
        if (filtersUpdatePeriod === 0) {
            return;
        }

        scheduleUpdateTimeoutId = setTimeout(() => {
            try {
                checkAntiBannerFiltersUpdate();
            } catch (ex) {
                adguard.console.error('Error update filters, cause {0}', ex);
            }
            scheduleUpdate();
        }, checkTimeout);
    }

    /**
     * Schedules filters update job
     *
     * @param isFirstRun App first run flag
     * @private
     */
    function scheduleFiltersUpdate(isFirstRun) {
        filtersUpdatePeriod = adguard.settings.getFiltersUpdatePeriod();
        // First run delay
        if (isFirstRun) {
            setTimeout(checkAntiBannerFiltersUpdate, UPDATE_FILTERS_DELAY, isFirstRun);
        }
        scheduleUpdate();
    }

    /**
     * Gets filter by ID.
     * Throws exception if filter not found.
     *
     * @param filterId Filter identifier
     * @returns {*} Filter got from adguard.subscriptions.getFilter
     * @private
     */
    function getFilterById(filterId) {
        const filter = adguard.subscriptions.getFilter(filterId);
        if (!filter) {
            throw new Error(`Filter with id: ${filterId} not found`);
        }
        return filter;
    }

    /**
     * Loads filters (ony-by-one) from the remote server
     *
     * @param filterMetadataList List of filter metadata to load
     * @param callback Called when filters have been loaded
     * @private
     */
    function loadFiltersFromBackend(filterMetadataList, callback) {
        const promises = filterMetadataList
            .map(filterMetadata => new Promise((resolve, reject) => {
                loadFilterRules(filterMetadata, true, (success) => {
                    if (!success) {
                        return reject();
                    }
                    return resolve(filterMetadata.filterId);
                });
            }));

        Promise.all(promises)
            .then((filterIds) => {
                callback(true, filterIds);
            })
            .catch(() => {
                callback(false);
            });
    }

    /**
     * Loads filter rules
     *
     * @param filterMetadata Filter metadata
     * @param forceRemote Force download filter rules from remote server
     * (if false try to download local copy of rules if it's possible)
     * @param callback Called when filter rules have been loaded
     * @private
     */
    function loadFilterRules(filterMetadata, forceRemote, callback) {
        const filter = getFilterById(filterMetadata.filterId);

        filter._isDownloading = true;
        adguard.listeners.notifyListeners(adguard.listeners.START_DOWNLOAD_FILTER, filter);

        const successCallback = (filterRules) => {
            adguard.console.info('Retrieved response from server for filter {0}, rules count: {1}',
                filter.filterId,
                filterRules.length);
            delete filter._isDownloading;
            filter.version = filterMetadata.version;
            filter.lastUpdateTime = filterMetadata.timeUpdated;
            filter.lastCheckTime = forceRemote ? Date.now() : filterMetadata.timeUpdated;
            filter.loaded = true;
            filter.expires = filterMetadata.expires;
            // notify listeners
            adguard.listeners.notifyListeners(adguard.listeners.SUCCESS_DOWNLOAD_FILTER, filter);
            adguard.listeners.notifyListeners(adguard.listeners.UPDATE_FILTER_RULES, filter, filterRules);
            callback(true);
        };

        const errorCallback = (cause) => {
            adguard.console.error(
                'Error retrieving response from the server for filter {0}, cause: {1}:',
                filter.filterId,
                cause || ''
            );
            delete filter._isDownloading;
            adguard.listeners.notifyListeners(adguard.listeners.ERROR_DOWNLOAD_FILTER, filter);
            callback(false);
        };

        adguard.backend.loadFilterRules(filter.filterId,
            forceRemote,
            adguard.settings.isUseOptimizedFiltersEnabled()).then(successCallback, errorCallback);
    }

    /**
     * Loads filter versions from remote server
     *
     * @param filterIds Filter identifiers
     * @param callback Callback (called when load is finished)
     * @private
     */
    function loadFiltersMetadataFromBackend(filterIds, callback) {
        if (filterIds.length === 0) {
            callback(true, []);
            return;
        }

        const loadSuccess = (filterMetadataList) => {
            adguard.console.debug(
                'Retrieved response from server for {0} filters, result: {1} metadata',
                filterIds.length, filterMetadataList.length
            );
            callback(true, filterMetadataList);
        };

        const loadError = (request, cause) => {
            adguard.console.error(
                'Error retrieved response from server for filters {0}, cause: {1} {2}',
                filterIds, request.statusText,
                cause || ''
            );
            callback(false);
        };

        adguard.backend.loadFiltersMetadata(filterIds, loadSuccess, loadError);
    }

    /**
     * Get request filter initialization time
     * @returns {number}
     */
    const getRequestFilterInitTime = function () {
        return requestFilterInitTime;
    };

    /**
     * Add rules to filter
     * @param rulesText
     * @returns {Array}
     */
    const addUserFilterRules = function (rulesText) {
        const rules = [];
        for (let i = 0; i < rulesText.length; i += 1) {
            const rule = adguard.rules.builder.createRule(rulesText[i], adguard.utils.filters.USER_FILTER_ID);
            if (rule !== null) {
                rules.push(rule);
            }
        }
        requestFilter.addRules(rules);

        adguard.listeners.notifyListeners(adguard.listeners.ADD_RULES, userFilter, rulesText);
        adguard.listeners.notifyListeners(adguard.listeners.UPDATE_USER_FILTER_RULES, getRequestFilterInfo());

        return rules;
    };

    /**
     * Updates filter rules
     * @param rulesText Rules text
     */
    const updateUserFilterRules = function (rulesText) {
        adguard.listeners.notifyListeners(adguard.listeners.UPDATE_FILTER_RULES, userFilter, rulesText);
        adguard.listeners.notifyListeners(adguard.listeners.UPDATE_USER_FILTER_RULES, getRequestFilterInfo());
    };

    /**
     * Remove rule from filter
     * @param ruleText
     */
    const removeUserFilterRule = function (ruleText) {
        const rule = adguard.rules.builder.createRule(ruleText, adguard.utils.filters.USER_FILTER_ID);
        if (rule !== null) {
            requestFilter.removeRule(rule);
        }
        adguard.listeners.notifyListeners(adguard.listeners.REMOVE_RULE, userFilter, [ruleText]);
    };

    return {

        start,
        stop,
        isInitialized,

        addAntiBannerFilter,

        getRequestFilter,
        getRequestFilterInitTime,

        addUserFilterRules,
        updateUserFilterRules,
        removeUserFilterRule,

        getRequestFilterInfo,

        checkAntiBannerFiltersUpdate,
    };
})(adguard);

/**
 * Api for filtering and elements hiding.
 */
adguard.requestFilter = (function (adguard) {
    'use strict';

    const { antiBannerService } = adguard;

    function getRequestFilter() {
        return antiBannerService.getRequestFilter();
    }

    /**
     * @returns boolean true when request filter was initialized first time
     */
    const isReady = function () {
        return antiBannerService.getRequestFilterInitTime() > 0;
    };

    /**
     * When browser just started we need some time on request filter initialization.
     * This could be a problem in case when browser has a homepage and it is just started.
     * In this case request filter is not yet initalized so we don't block requests and inject css.
     * To fix this, content script will repeat requests for selectors until request filter is ready
     * and it will also collapse all elements which should have been blocked.
     *
     * @returns boolean true if we should collapse elements with content script
     */
    const shouldCollapseAllElements = function () {
        // We assume that if content script is requesting CSS in first 5 seconds after request filter init,
        // then it is possible, that we've missed some elements and now we should collapse these elements
        const requestFilterInitTime = antiBannerService.getRequestFilterInitTime();
        return (requestFilterInitTime > 0) && (requestFilterInitTime + 5000 > new Date().getTime());
    };

    const getRules = function () {
        return getRequestFilter().getRules();
    };

    const findRuleForRequest = function (requestUrl, documentUrl, requestType, documentWhitelistRule) {
        return getRequestFilter().findRuleForRequest(requestUrl, documentUrl, requestType, documentWhitelistRule);
    };

    const findWhiteListRule = function (requestUrl, referrer, requestType) {
        return getRequestFilter().findWhiteListRule(requestUrl, referrer, requestType);
    };

    const findStealthWhiteListRule = function (requestUrl, referrer, requestType) {
        return getRequestFilter().findStealthWhiteListRule(requestUrl, referrer, requestType);
    };

    const getSelectorsForUrl = function (documentUrl, genericHideFlag) {
        return getRequestFilter().getSelectorsForUrl(documentUrl, genericHideFlag);
    };

    const getInjectedSelectorsForUrl = function (documentUrl, genericHideFlag) {
        return getRequestFilter().getInjectedSelectorsForUrl(documentUrl, genericHideFlag);
    };

    const getScriptsForUrl = function (documentUrl) {
        return getRequestFilter().getScriptsForUrl(documentUrl);
    };

    const getScriptsStringForUrl = function (documentUrl, tab) {
        return getRequestFilter().getScriptsStringForUrl(documentUrl, tab);
    };

    const getContentRulesForUrl = function (documentUrl) {
        return getRequestFilter().getContentRulesForUrl(documentUrl);
    };

    const getMatchedElementsForContentRules = function (doc, rules) {
        return getRequestFilter().getMatchedElementsForContentRules(doc, rules);
    };

    const getCspRules = function (requestUrl, referrer, requestType) {
        return getRequestFilter().findCspRules(requestUrl, referrer, requestType);
    };

    const getCookieRules = function (requestUrl, referrer, requestType) {
        return getRequestFilter().findCookieRules(requestUrl, referrer, requestType);
    };

    const getReplaceRules = function (requestUrl, referrer, requestType) {
        return getRequestFilter().findReplaceRules(requestUrl, referrer, requestType);
    };

    const getRequestFilterInfo = function () {
        return antiBannerService.getRequestFilterInfo();
    };

    return {

        isReady,
        shouldCollapseAllElements,

        getRules,
        findRuleForRequest,
        findWhiteListRule,

        getSelectorsForUrl,
        getInjectedSelectorsForUrl,
        getScriptsForUrl,
        getScriptsStringForUrl,
        getContentRulesForUrl,
        getMatchedElementsForContentRules,
        getCspRules,
        getCookieRules,
        getReplaceRules,
        findStealthWhiteListRule,
        getRequestFilterInfo,
    };
})(adguard);

/**
 * Helper class for working with filters metadata storage (local storage)
 * //TODO: Duplicated in filters-storage.js
 */
adguard.filtersState = (function (adguard) {
    const FILTERS_STATE_PROP = 'filters-state';
    const FILTERS_VERSION_PROP = 'filters-version';
    const GROUPS_STATE_PROP = 'groups-state';

    /**
     * Gets filter version from the local storage
     * @returns {*}
     */
    const getFiltersVersion = function () {
        let filters = Object.create(null);
        try {
            const json = adguard.localStorage.getItem(FILTERS_VERSION_PROP);
            if (json) {
                filters = JSON.parse(json);
            }
        } catch (ex) {
            adguard.console.error('Error retrieve filters version info, cause {0}', ex);
        }
        return filters;
    };

    /**
     * Gets filters state from the local storage
     * @returns {*}
     */
    const getFiltersState = function () {
        let filters = Object.create(null);
        try {
            const json = adguard.localStorage.getItem(FILTERS_STATE_PROP);
            if (json) {
                filters = JSON.parse(json);
            }
        } catch (ex) {
            adguard.console.error('Error retrieve filters state info, cause {0}', ex);
        }
        return filters;
    };

    /**
     * Gets groups state from the local storage
     * @returns {any}
     */
    const getGroupsState = function () {
        let groups = Object.create(null);
        try {
            const json = adguard.localStorage.getItem(GROUPS_STATE_PROP);
            if (json) {
                groups = JSON.parse(json);
            }
        } catch (e) {
            adguard.console.error('Error retrieve groups state info, cause {0}', e);
        }
        return groups;
    };

    /**
     * Updates filter version in the local storage
     *
     * @param filter Filter version metadata
     */
    const updateFilterVersion = function (filter) {
        const filters = getFiltersVersion();
        filters[filter.filterId] = {
            version: filter.version,
            lastCheckTime: filter.lastCheckTime,
            lastUpdateTime: filter.lastUpdateTime,
            expires: filter.expires,
        };

        adguard.localStorage.setItem(FILTERS_VERSION_PROP, JSON.stringify(filters));
    };

    /**
     * Updates filter state in the local storage
     *
     * @param filter Filter state object
     */
    const updateFilterState = function (filter) {
        const filters = getFiltersState();
        filters[filter.filterId] = {
            loaded: filter.loaded,
            enabled: filter.enabled,
            installed: filter.installed,
        };
        adguard.localStorage.setItem(FILTERS_STATE_PROP, JSON.stringify(filters));
    };

    const removeFilter = (filterId) => {
        const filters = getFiltersState();
        delete filters[filterId];
        adguard.localStorage.setItem(FILTERS_STATE_PROP, JSON.stringify(filters));
    };

    /**
     * Updates group enable state in the local storage
     *
     * @param group - SubscriptionGroup object
     */
    const updateGroupState = function (group) {
        const groups = getGroupsState();
        groups[group.groupId] = {
            enabled: group.enabled,
        };
        adguard.localStorage.setItem(GROUPS_STATE_PROP, JSON.stringify(groups));
    };

    // Add event listener to persist filter metadata to local storage
    adguard.listeners.addListener((event, payload) => {
        switch (event) {
            case adguard.listeners.SUCCESS_DOWNLOAD_FILTER:
                updateFilterState(payload);
                updateFilterVersion(payload);
                break;
            case adguard.listeners.FILTER_ADD_REMOVE:
            case adguard.listeners.FILTER_ENABLE_DISABLE:
                updateFilterState(payload);
                break;
            case adguard.listeners.FILTER_GROUP_ENABLE_DISABLE:
                updateGroupState(payload);
                break;
            default:
                break;
        }
    });

    return {
        getFiltersVersion,
        getFiltersState,
        getGroupsState,
        // These methods are used only for migrate from old versions
        updateFilterVersion,
        updateFilterState,
        removeFilter,
    };
})(adguard);

/**
 * Class for manage filters state (enable, disable, add, remove, check updates)
 * Also includes method for initializing
 */
adguard.filters = (function (adguard) {
    'use strict';

    /**
     * TImeout for recently updated filters and again enabled filters - 5 minutes
     */
    const ENABLED_FILTERS_SKIP_TIMEOUT = 5 * 60 * 1000;

    const { antiBannerService } = adguard;

    const start = function (options, callback) {
        antiBannerService.start(options, callback);
    };

    const stop = function (callback) {
        antiBannerService.stop();
        callback();
    };

    /**
     * Checks application has been initialized
     * @returns {boolean}
     */
    const isInitialized = function () {
        return antiBannerService.isInitialized();
    };

    /**
     * Offer filters on extension install, select default filters and filters by locale and country
     * @param callback
     */
    const offerFilters = (callback) => {
        // These filters are enabled by default
        const filterIds = [
            adguard.utils.filters.ENGLISH_FILTER_ID,
            adguard.utils.filters.SEARCH_AND_SELF_PROMO_FILTER_ID,
        ];
        if (adguard.prefs.mobile) {
            filterIds.push(adguard.utils.filters.MOBILE_ADS_FILTER_ID);
        }
        filterIds.concat(adguard.subscriptions.getLangSuitableFilters());
        callback(filterIds);
    };

    /**
     * List of enabled filters.
     * User filter and whitelist filter are always enabled so they are excluded.
     *
     * @returns {Array} List of enabled filters
     */
    const getEnabledFilters = () => adguard.subscriptions.getFilters()
        .filter(f => f.installed && f.enabled);

    const getEnabledFiltersFromEnabledGroups = () => {
        const filters = adguard.subscriptions.getFilters();
        const enabledGroupsIds = adguard.subscriptions.getGroups()
            .filter(g => g.enabled)
            .map(g => g.groupId);
        return filters.filter(f => f.enabled && enabledGroupsIds.includes(f.groupId));
    };

    /**
     * Checks if specified filter is enabled
     *
     * @param filterId Filter identifier
     * @returns {*} true if enabled
     */
    const isFilterEnabled = function (filterId) {
        const filter = adguard.subscriptions.getFilter(filterId);
        return filter && filter.enabled;
    };

    /**
     * Checks if specified filter is installed (downloaded)
     *
     * @param filterId Filter id
     * @returns {*} true if installed
     */
    const isFilterInstalled = function (filterId) {
        const filter = adguard.subscriptions.getFilter(filterId);
        return filter && filter.installed;
    };

    /**
     * Force checks updates for filters if specified or all filters
     *
     * @param successCallback
     * @param errorCallback
     * @param {Object[]} [filters] optional list of filters
     */
    const checkFiltersUpdates = (successCallback, errorCallback, filters) => {
        if (filters) {
            // Skip recently downloaded filters
            const outdatedFilter = filters.filter(f => (f.lastCheckTime
                ? Date.now() - f.lastCheckTime > ENABLED_FILTERS_SKIP_TIMEOUT
                : true));

            if (outdatedFilter.length > 0) {
                antiBannerService.checkAntiBannerFiltersUpdate(
                    true,
                    successCallback,
                    errorCallback,
                    outdatedFilter
                );
            }
        } else {
            antiBannerService.checkAntiBannerFiltersUpdate(true, successCallback, errorCallback);
        }
    };

    /**
     * Enable group
     * @param {number} groupId filter group identifier
     */
    const enableGroup = function (groupId) {
        const group = adguard.subscriptions.getGroup(groupId);
        if (!group || group.enabled) {
            return;
        }
        group.enabled = true;
        adguard.listeners.notifyListeners(adguard.listeners.FILTER_GROUP_ENABLE_DISABLE, group);
    };

    /**
     * Disable group
     * @param {number} groupId filter group identifier
     */
    const disableGroup = function (groupId) {
        const group = adguard.subscriptions.getGroup(groupId);
        if (!group || !group.enabled) {
            return;
        }
        group.enabled = false;
        adguard.listeners.notifyListeners(adguard.listeners.FILTER_GROUP_ENABLE_DISABLE, group);
    };

    /**
     * Enable filter
     *
     * @param {Number} filterId Filter identifier
     * @param {{forceGroupEnable: boolean}} [options]
     * @returns {boolean} true if filter was enabled successfully
     */
    const enableFilter = (filterId, options) => {
        const filter = adguard.subscriptions.getFilter(filterId);
        if (!filter || filter.enabled || !filter.installed) {
            return false;
        }
        filter.enabled = true;
        /**
         * we enable group if it was never enabled or disabled early
         */
        const { groupId } = filter;
        const forceGroupEnable = options && options.forceGroupEnable;
        if (!adguard.subscriptions.groupHasEnabledStatus(groupId) || forceGroupEnable) {
            enableGroup(groupId);
        }
        adguard.listeners.notifyListeners(adguard.listeners.FILTER_ENABLE_DISABLE, filter);
        return true;
    };

    /**
     * Successively add filters from filterIds and then enable successfully added filters
     * @param filterIds Filter identifiers
     * @param {{forceGroupEnable: boolean}} [options]
     * @param callback We pass list of enabled filter identifiers to the callback
     */
    const addAndEnableFilters = (filterIds, callback, options) => {
        callback = callback || function noop() {}; // empty callback

        const enabledFilters = [];

        if (!filterIds || filterIds.length === 0) {
            callback(enabledFilters);
            return;
        }

        filterIds = adguard.utils.collections.removeDuplicates(filterIds.slice(0));
        const loadNextFilter = () => {
            if (filterIds.length === 0) {
                callback(enabledFilters);
            } else {
                const filterId = filterIds.shift();
                antiBannerService.addAntiBannerFilter(filterId, (success) => {
                    if (success) {
                        const changed = enableFilter(filterId, options);
                        if (changed) {
                            const filter = adguard.subscriptions.getFilter(filterId);
                            enabledFilters.push(filter);
                        }
                    }
                    loadNextFilter();
                });
            }
        };

        loadNextFilter();
    };

    /**
     * Disables filters by id
     *
     * @param {Array.<Number>} filterIds Filter identifiers
     * @returns {boolean} true if filter was disabled successfully
     */
    const disableFilters = function (filterIds) {
        // Copy array to prevent parameter mutation
        filterIds = adguard.utils.collections.removeDuplicates(filterIds.slice(0));
        for (let i = 0; i < filterIds.length; i += 1) {
            const filterId = filterIds[i];
            const filter = adguard.subscriptions.getFilter(filterId);
            if (!filter || !filter.enabled || !filter.installed) {
                continue;
            }
            filter.enabled = false;
            adguard.listeners.notifyListeners(adguard.listeners.FILTER_ENABLE_DISABLE, filter);
        }
    };

    /**
     * Uninstalls filters
     *
     * @param {Array.<Number>} filterIds Filter identifiers
     * @returns {boolean} true if filter was removed successfully
     */
    const uninstallFilters = function (filterIds) {
        // Copy array to prevent parameter mutation
        filterIds = adguard.utils.collections.removeDuplicates(filterIds.slice(0));

        for (let i = 0; i < filterIds.length; i += 1) {
            const filterId = filterIds[i];
            const filter = adguard.subscriptions.getFilter(filterId);
            if (!filter || !filter.installed) {
                continue;
            }

            adguard.console.debug('Uninstall filter {0}', filter.filterId);

            filter.enabled = false;
            filter.installed = false;
            adguard.listeners.notifyListeners(adguard.listeners.FILTER_ENABLE_DISABLE, filter);
            adguard.listeners.notifyListeners(adguard.listeners.FILTER_ADD_REMOVE, filter);
        }
    };

    /**
     * Removes filter
     *
     * @param {Number} filterId Filter identifier
     */
    const removeFilter = function (filterId) {
        const filter = adguard.subscriptions.getFilter(filterId);
        if (!filter || filter.removed) {
            return;
        }

        if (!filter.customUrl) {
            adguard.console.error('Filter {0} is not custom and could not be removed', filter.filterId);
            return;
        }

        adguard.console.debug('Remove filter {0}', filter.filterId);

        filter.enabled = false;
        filter.installed = false;
        filter.removed = true;
        adguard.listeners.notifyListeners(adguard.listeners.FILTER_ENABLE_DISABLE, filter);
        adguard.listeners.notifyListeners(adguard.listeners.FILTER_ADD_REMOVE, filter);
    };

    /**
     * Loads filter rules from url, then tries to parse header to filter metadata
     * and adds filter object to subscriptions from it.
     * These custom filters will have special attribute customUrl, from there it could be downloaded and updated.
     *
     * @param url custom url, there rules are
     * @param options object containing title of custom filter
     * @param successCallback
     * @param errorCallback
     */
    const loadCustomFilter = function (url, options, successCallback, errorCallback) {
        adguard.console.info('Downloading custom filter from {0}', url);

        if (!url) {
            errorCallback();
            return;
        }

        adguard.subscriptions.updateCustomFilter(url, options, (filterId) => {
            if (filterId) {
                adguard.console.info('Custom filter downloaded');

                const filter = adguard.subscriptions.getFilter(filterId);
                // In case filter is loaded again and was removed before
                delete filter.removed;
                successCallback(filter);
            } else {
                errorCallback();
            }
        });
    };

    const loadCustomFilterInfo = (url, options, successCallback, errorCallback) => {
        adguard.console.info(`Downloading custom filter info from ${url}`);
        if (!url) {
            errorCallback();
            return;
        }

        adguard.subscriptions.getCustomFilterInfo(url, options, (result = {}) => {
            const { error, filter } = result;
            if (filter) {
                adguard.console.info('Custom filter data downloaded');
                successCallback(filter);
                return;
            }
            errorCallback(error);
        });
    };

    return {

        start,
        stop,
        isInitialized,

        offerFilters,

        getEnabledFilters,

        isFilterEnabled,
        isFilterInstalled,

        checkFiltersUpdates,

        addAndEnableFilters,
        disableFilters,
        uninstallFilters,
        removeFilter,

        enableGroup,
        disableGroup,

        loadCustomFilter,
        loadCustomFilterInfo,
        getEnabledFiltersFromEnabledGroups,
    };
})(adguard);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

adguard.webRequestService = (function (adguard) {
    'use strict';

    const onRequestBlockedChannel = adguard.utils.channels.newChannel();

    /**
     * Checks if we can collect hit stats for this tab:
     * Option "Send ad filters usage" is enabled and tab isn't incognito
     * @param {object} tab
     * @returns {boolean}
     */
    const canCollectHitStatsForTab = function (tab) {
        if (!tab) {
            return adguard.settings.collectHitsCount();
        }

        return tab
            && adguard.settings.collectHitsCount()
            && !adguard.frames.isIncognitoTab(tab);
    };

    /**
     * Records filtering rule hit
     *
     * @param tab            Tab object
     * @param requestRule    Rule to record
     * @param requestUrl     Request URL
     */
    const recordRuleHit = function (tab, requestRule, requestUrl) {
        if (requestRule
            && !adguard.utils.filters.isUserFilterRule(requestRule)
            && !adguard.utils.filters.isWhiteListFilterRule(requestRule)
            && canCollectHitStatsForTab(tab)) {
            const domain = adguard.frames.getFrameDomain(tab);
            adguard.hitStats.addRuleHit(domain, requestRule.ruleText, requestRule.filterId, requestUrl);
        }
    };

    /**
     * An object with the selectors and scripts to be injected into the page
     * @typedef {Object} SelectorsAndScripts
     * @property {SelectorsData} selectors An object with the CSS styles that needs to be applied
     * @property {string} scripts Javascript to be injected into the page
     * @property {boolean} collapseAllElements If true, content script must force the collapse check of the page elements
     */

    /**
     * Prepares CSS and JS which should be injected to the page.
     *
     * @param tab                       Tab data
     * @param documentUrl               Document URL
     * @param cssFilterOptions          Bitmask for the CssFilter
     * @param {boolean} retrieveScripts Indicates whether to retrieve JS rules or not
     *
     * When cssFilterOptions and retrieveScripts are undefined, we handle it in a special way
     * that depends on whether the browser supports inserting CSS and scripts from the background page
     *
     * @returns {SelectorsAndScripts} an object with the selectors and scripts to be injected into the page
     */
    const processGetSelectorsAndScripts = function (tab, documentUrl, cssFilterOptions, retrieveScripts) {
        const result = Object.create(null);

        if (!tab) {
            return result;
        }

        if (!adguard.requestFilter.isReady()) {
            result.requestFilterReady = false;
            return result;
        }

        if (adguard.frames.isTabProtectionDisabled(tab)) {
            return result;
        }

        // Looking for the whitelist rule
        let whitelistRule = adguard.frames.getFrameWhiteListRule(tab);
        if (!whitelistRule) {
            // Check whitelist for current frame
            const mainFrameUrl = adguard.frames.getMainFrameUrl(tab);
            whitelistRule = adguard.requestFilter.findWhiteListRule(documentUrl, mainFrameUrl, adguard.RequestTypes.DOCUMENT);
        }

        const { CssFilter } = adguard.rules;


        // Check what exactly is disabled by this rule
        const elemHideFlag = whitelistRule && whitelistRule.isElemhide();
        const genericHideFlag = whitelistRule && whitelistRule.isGenericHide();

        // content-message-handler calls it in this way
        if (typeof cssFilterOptions === 'undefined' && typeof retrieveScripts === 'undefined') {
            // Build up default flags.
            const { canUseInsertCSSAndExecuteScript } = adguard.prefs.features;
            // If tabs.executeScript is unavailable, retrieve JS rules now.
            retrieveScripts = !canUseInsertCSSAndExecuteScript;
            if (!elemHideFlag) {
                cssFilterOptions = CssFilter.RETRIEVE_EXTCSS;
                if (!canUseInsertCSSAndExecuteScript) {
                    cssFilterOptions += CssFilter.RETRIEVE_TRADITIONAL_CSS;
                }
                if (genericHideFlag) {
                    cssFilterOptions += CssFilter.GENERIC_HIDE_APPLIED;
                }
            }
        } else if (!elemHideFlag && genericHideFlag) {
            cssFilterOptions += CssFilter.GENERIC_HIDE_APPLIED;
        }

        const retrieveSelectors = !elemHideFlag && (cssFilterOptions & (CssFilter.RETRIEVE_TRADITIONAL_CSS + CssFilter.RETRIEVE_EXTCSS)) !== 0;

        // It's important to check this after the recordRuleHit call
        // as otherwise we will never record $document rules hit for domain
        if (adguard.frames.isTabWhiteListed(tab)) {
            return result;
        }

        if (retrieveSelectors) {
            result.collapseAllElements = adguard.requestFilter.shouldCollapseAllElements();
            result.selectors = adguard.requestFilter.getSelectorsForUrl(documentUrl, cssFilterOptions);
        }

        if (retrieveScripts) {
            const jsInjectFlag = whitelistRule && whitelistRule.isJsInject();
            if (!jsInjectFlag) {
                // JS rules aren't disabled, returning them
                result.scripts = adguard.requestFilter.getScriptsStringForUrl(documentUrl, tab);
            }
        }
        // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1337
        result.collectRulesHits = elemHideFlag ? false : adguard.webRequestService.isCollectingCosmeticRulesHits(tab);

        return result;
    };

    /**
     * Checks if request that is wrapped in page script should be blocked.
     * We do this because browser API doesn't have full support for intercepting all requests, e.g. WebSocket or WebRTC.
     *
     * @param tab           Tab
     * @param requestUrl    request url
     * @param referrerUrl   referrer url
     * @param requestType   Request type (WEBSOCKET or WEBRTC)
     * @returns {boolean}   true if request is blocked
     */
    const checkPageScriptWrapperRequest = function (tab, requestUrl, referrerUrl, requestType) {
        if (!tab) {
            return false;
        }

        let requestRule = getRuleForRequest(tab, requestUrl, referrerUrl, requestType);
        requestRule = postProcessRequest(tab, requestUrl, referrerUrl, requestType, requestRule);

        adguard.requestContextStorage.recordEmulated(requestUrl, referrerUrl, requestType, tab, requestRule);

        return isRequestBlockedByRule(requestRule);
    };

    /**
     * Checks if request is blocked
     *
     * @param tab           Tab
     * @param requestUrl    request url
     * @param referrerUrl   referrer url
     * @param requestType   one of RequestType
     * @returns {boolean}   true if request is blocked
     */
    const processShouldCollapse = function (tab, requestUrl, referrerUrl, requestType) {
        if (!tab) {
            return false;
        }

        const requestRule = getRuleForRequest(tab, requestUrl, referrerUrl, requestType);
        return isRequestBlockedByRule(requestRule);
    };

    /**
     * Checks if requests are blocked
     *
     * @param tab               Tab
     * @param referrerUrl       referrer url
     * @param collapseRequests  requests array
     * @returns {*}             requests array
     */
    const processShouldCollapseMany = function (tab, referrerUrl, collapseRequests) {
        if (!tab) {
            return collapseRequests;
        }

        for (let i = 0; i < collapseRequests.length; i++) {
            const request = collapseRequests[i];
            const requestRule = getRuleForRequest(tab, request.elementUrl, referrerUrl, request.requestType);
            request.collapse = isRequestBlockedByRule(requestRule);
        }

        return collapseRequests;
    };

    /**
     * Checks if request is blocked by rule
     * Do not allow redirect rules because they can't be used in collapse check functions
     *
     * @param requestRule
     * @returns {*|boolean}
     */
    var isRequestBlockedByRule = function (requestRule) {
        return requestRule
            && !requestRule.whiteListRule
            && !requestRule.getReplace()
            && !requestRule.isRedirectRule();
    };

    /**
     * Checks if popup is blocked by rule
     * @param requestRule
     * @returns {*|boolean|true}
     */
    const isPopupBlockedByRule = function (requestRule) {
        return requestRule && !requestRule.whiteListRule && requestRule.isBlockPopups();
    };

    /**
     * Gets blocked response by rule
     * For details see https://developer.chrome.com/extensions/webRequest#type-BlockingResponse
     * or https://developer.mozilla.org/en-US/Add-ons/WebExtensions/API/webRequest/BlockingResponse
     * @param requestRule   Request rule or null
     * @param requestType   Request type
     * @param requestUrl    Request url
     * @returns {*} Blocked response or null
     */
    const getBlockedResponseByRule = function (requestRule, requestType, requestUrl) {
        if (isRequestBlockedByRule(requestRule)) {
            const isDocumentLevel = requestType === adguard.RequestTypes.DOCUMENT
                || requestType === adguard.RequestTypes.SUBDOCUMENT;

            if (isDocumentLevel && requestRule.isDocumentRule()) {
                const documentBlockedPage = adguard.rules.documentFilterService.getDocumentBlockPageUrl(
                    requestUrl,
                    requestRule.ruleText
                );

                if (documentBlockedPage) {
                    return { documentBlockedPage };
                }

                return null;
            }

            // Don't block main_frame request
            if (requestType !== adguard.RequestTypes.DOCUMENT) {
                return { cancel: true };
            }
        // check if request rule is blocked by rule and is redirect rule
        } else if (requestRule && !requestRule.whiteListRule && requestRule.isRedirectRule()) {
            const redirectOption = requestRule.getRedirect();
            const redirectUrl = redirectOption.getRedirectUrl();
            return { redirectUrl };
        }
        return null;
    };

    /**
     * Finds rule for request
     *
     * @param tab           Tab
     * @param requestUrl    request url
     * @param referrerUrl   referrer url
     * @param requestType   one of RequestType
     * @returns {*}         rule or null
     */
    var getRuleForRequest = function (tab, requestUrl, referrerUrl, requestType) {
        if (adguard.frames.isTabProtectionDisabled(tab)) {
            // don't process request
            return null;
        }

        let whitelistRule;
        /**
         * Background requests will be whitelisted if their referrer
         * url will match with user whitelist rule
         * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1032
         */
        if (tab.tabId === adguard.BACKGROUND_TAB_ID) {
            whitelistRule = adguard.whitelist.findWhiteListRule(referrerUrl);
        } else {
            whitelistRule = adguard.frames.getFrameWhiteListRule(tab);
        }

        if (whitelistRule && whitelistRule.isDocumentWhiteList()) {
            // Frame is whitelisted by the main frame's $document rule
            // We do nothing more in this case - return the rule.
            return whitelistRule;
        } if (!whitelistRule) {
            // If whitelist rule is not found for the main frame, we check it for referrer
            whitelistRule = adguard.requestFilter.findWhiteListRule(requestUrl, referrerUrl, adguard.RequestTypes.DOCUMENT);
        }

        return adguard.requestFilter.findRuleForRequest(requestUrl, referrerUrl, requestType, whitelistRule);
    };

    /**
     * Finds all content rules for the url
     * @param tab Tab
     * @param documentUrl Document URL
     * @returns collection of content rules or null
     */
    const getContentRules = function (tab, documentUrl) {
        if (adguard.frames.shouldStopRequestProcess(tab)) {
            // don't process request
            return null;
        }

        const whitelistRule = adguard.requestFilter.findWhiteListRule(documentUrl, documentUrl, adguard.RequestTypes.DOCUMENT);
        if (whitelistRule && whitelistRule.isContent()) {
            return null;
        }

        return adguard.requestFilter.getContentRulesForUrl(documentUrl);
    };

    /**
     * Find CSP rules for request
     * @param tab           Tab
     * @param requestUrl    Request URL
     * @param referrerUrl   Referrer URL
     * @param requestType   Request type (DOCUMENT or SUBDOCUMENT)
     * @returns {Array}     Collection of rules or null
     */
    const getCspRules = function (tab, requestUrl, referrerUrl, requestType) {
        if (adguard.frames.shouldStopRequestProcess(tab)) {
            // don't process request
            return null;
        }

        // @@||example.org^$document or @@||example.org^$urlblock  disables all the $csp rules on all the pages matching the rule pattern.
        const whitelistRule = adguard.requestFilter.findWhiteListRule(requestUrl, referrerUrl, adguard.RequestTypes.DOCUMENT);
        if (whitelistRule && whitelistRule.isUrlBlock()) {
            return null;
        }

        return adguard.requestFilter.getCspRules(requestUrl, referrerUrl, requestType);
    };

    /**
     * Find cookie rules for request
     * @param tab           Tab
     * @param requestUrl    Request URL
     * @param referrerUrl   Referrer URL
     * @param requestType   Request type
     * @returns {Array}     Collection of rules or null
     */
    const getCookieRules = (tab, requestUrl, referrerUrl, requestType) => {
        if (adguard.frames.shouldStopRequestProcess(tab)) {
            // Don't process request
            return null;
        }

        const whitelistRule = adguard.requestFilter.findWhiteListRule(requestUrl, referrerUrl, adguard.RequestTypes.DOCUMENT);
        if (whitelistRule && whitelistRule.isDocumentWhiteList()) {
            // $cookie rules are not affected by regular exception rules (@@) unless it's a $document exception.
            return null;
        }

        // Get all $cookie rules matching the specified request
        return adguard.requestFilter.getCookieRules(requestUrl, referrerUrl, requestType);
    };

    /**
     * Find replace rules for request
     * @param tab
     * @param requestUrl
     * @param referrerUrl
     * @param requestType
     * @returns {*} Collection of rules or null
     */
    const getReplaceRules = (tab, requestUrl, referrerUrl, requestType) => {
        if (adguard.frames.shouldStopRequestProcess(tab)) {
            // don't process request
            return null;
        }

        const whitelistRule = adguard.requestFilter.findWhiteListRule(requestUrl, referrerUrl, adguard.RequestTypes.DOCUMENT);

        if (whitelistRule && whitelistRule.isContent()) {
            return null;
        }

        return adguard.requestFilter.getReplaceRules(requestUrl, referrerUrl, requestType);
    };

    /**
     * Processes HTTP response.
     * It could do the following:
     * 1. Add event to the filtering log (for DOCUMENT requests)
     * 2. Record page stats (if it's enabled)
     *
     * @param tab Tab object
     * @param requestUrl Request URL
     * @param referrerUrl Referrer URL
     * @param requestType Request type
     * @return {void}
     */
    const processRequestResponse = function (tab, requestUrl, referrerUrl, requestType) {
        // add page view to stats
        if (requestType === adguard.RequestTypes.DOCUMENT) {
            const domain = adguard.frames.getFrameDomain(tab);
            if (canCollectHitStatsForTab(tab)) {
                adguard.hitStats.addDomainView(domain);
            }
        }
    };

    /**
     * Request post processing, firing events, add log records etc.
     *
     * @param tab           Tab
     * @param requestUrl    request url
     * @param referrerUrl   referrer url
     * @param requestType   one of RequestType
     * @param requestRule   rule
     * @return {object} Request rule if suitable by its own type and request type or null
     */
    var postProcessRequest = function (tab, requestUrl, referrerUrl, requestType, requestRule) {
        if (requestRule && !requestRule.whiteListRule) {
            const isRequestBlockingRule = isRequestBlockedByRule(requestRule);
            const isPopupBlockingRule = isPopupBlockedByRule(requestRule);
            const isReplaceRule = !!requestRule.getReplace();

            // Url blocking rules are not applicable to the main_frame
            if (isRequestBlockingRule && requestType === adguard.RequestTypes.DOCUMENT) {
                // except rules with $document and $popup modifiers
                if (!requestRule.isDocumentRule() && !isPopupBlockingRule) {
                    requestRule = null;
                }
            }

            // Replace rules are processed in content-filtering.js
            if (isReplaceRule) {
                requestRule = null;
            }

            if (requestRule) {
                adguard.listeners.notifyListenersAsync(adguard.listeners.ADS_BLOCKED, requestRule, tab, 1);
                const details = {
                    tabId: tab.tabId,
                    requestUrl,
                    referrerUrl,
                    requestType,
                };
                details.rule = requestRule.ruleText;
                details.filterId = requestRule.filterId;
                onRequestBlockedChannel.notify(details);
            }
        }

        return requestRule;
    };

    const isCollectingCosmeticRulesHits = (tab) => {
        /**
         * Edge Legacy browser doesn't support css content attribute for node elements except
         * :before and :after
         * Due to this we can't use cssHitsCounter for edge browser
         */
        if (adguard.utils.browser.isEdgeBrowser()) {
            return false;
        }

        return canCollectHitStatsForTab(tab) || adguard.filteringLog.isOpen();
    };


    // EXPOSE
    return {
        processGetSelectorsAndScripts,
        checkPageScriptWrapperRequest,
        processShouldCollapse,
        processShouldCollapseMany,
        isRequestBlockedByRule,
        isPopupBlockedByRule,
        getBlockedResponseByRule,
        getRuleForRequest,
        getCspRules,
        getCookieRules,
        getContentRules,
        getReplaceRules,
        processRequestResponse,
        postProcessRequest,
        recordRuleHit,
        onRequestBlocked: onRequestBlockedChannel,
        isCollectingCosmeticRulesHits,
    };
})(adguard);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Cookie filtering module
 * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/961
 *
 * Modifies Cookie/Set-Cookie headers.
 *
 * Let's look at an example:
 *
 * 1. ||example.org^$cookie=i_track_u should block the i_track_u cookie coming from example.org
 * 2. We've intercepted a request sent to https://example.org/count
 * 3. Cookie header value is i_track_u=1; JSESSIONID=321321
 * 4. First of all, modify the Cookie header so that the server doesn't receive the i_track_u value.
 *    Modified value: JSESSIONID=321321
 * 5. Wait for the response and check all the Set-Cookie headers received from the server.
 * 6. Remove the one that sets the i_track_u cookie (or modify it and strip that cookie if it contains more than one)
 * 7. Now we need to make sure that browser deletes that cookie.
 *    In order to do it, we should add a new Set-Cookie header that sets i_track_u with a negative
 *    expiration date: Set-Cookie: i_track_u=1; expires=[CURRENT_DATETIME]; path=/; domain=.example.org.
 *
 * Step 7 must not be executed when the rule has the third-party modifier.
 * third-party means that there is a case (first-party) when cookies must not be removed, i.e.
 * they can be actually useful, and removing them can be counterproductive.
 * For instance, Google and Facebook rely on their SSO cookies and forcing a browser to remove
 * them will also automatically log you out.
 *
 * @type {{filterRequestHeaders, filterResponseHeaders}}
 */
adguard.cookieFiltering = (function (adguard) {
    'use strict';

    /**
     * Cookie with name that matches some URL
     *
     * @typedef {object} RequestCookie
     * @property {string} url
     * @property {string} name
     * @property {boolean} thirdParty
     */

    /**
     * Cookie modification item
     *
     * @typedef {object} ModifyRequestCookie
     * @property {boolean} remove
     * @property {Array} rules
     * @property {RequestCookie} cookie
     */

    /**
     * API cookie
     *
     * @typedef {object} BrowserApiCookie
     * @property {string} name
     * @property {string} value
     * @property {string} domain
     * @property {string} path
     * @property {boolean} secure
     * @property {boolean} httpOnly
     * @property {boolean} sameSite
     * @property {number} expirationDate
     * @property {boolean} hostOnly
     */

    /**
     * Contains cookie to modify for each request
     * @type {Map<string, Array.<ModifyRequestCookie>>}
     */
    const cookiesMap = new Map();

    /**
     * Persist cookie for further processing
     *
     * @param {string} requestId
     * @param {string} name
     * @param {string} url
     * @param {boolean} thirdParty
     * @param {Array} rules
     * @param {boolean} remove
     */
    const scheduleProcessingCookie = (requestId, name, url, thirdParty, rules, remove) => {
        let values = cookiesMap.get(requestId);
        if (!values) {
            values = [];
            cookiesMap.set(requestId, values);
        }
        values.push({
            remove,
            cookie: { name, url, thirdParty },
            rules,
        });
    };

    /**
     * Removes cookies from processing
     *
     * @param {string} requestId
     * @param {Array.<string>} cookieNames Cookies to remove
     */
    const removeProcessingCookies = (requestId, cookieNames) => {
        const values = cookiesMap.get(requestId);
        if (!values) {
            return;
        }

        let iValues = values.length;
        // no-cond-assign disabled because we iterate in
        // the reverse order
        // eslint-disable-next-line no-cond-assign
        while (iValues -= 1) {
            const value = values[iValues];
            // eslint-disable-next-line prefer-destructuring
            const cookie = value.cookie;
            if (cookieNames.indexOf(cookie.name) >= 0) {
                values.splice(iValues, 1);
            }
        }
        if (values.length === 0) {
            cookiesMap.delete(requestId);
        }
    };

    /**
     * Adds cookie rule to filtering log
     *
     * @callback AddCookieLogEvent
     * @param {Object} tab
     * @param {string} cookieName
     * @param {string} cookieValue
     * @param {string} cookieDomain
     * @param {boolean} cookieThirdParty
     * @param {Array} rules
     * @param {boolean} isModifyingCookieRule
     */
    const addCookieLogEvent = (tab, cookieName, cookieValue, cookieDomain, cookieThirdParty,
        rules, isModifyingCookieRule) => {
        for (let i = 0; i < rules.length; i += 1) {
            adguard.filteringLog.addCookieEvent(tab, cookieName, cookieValue,
                cookieDomain, adguard.RequestTypes.COOKIE, rules[i],
                isModifyingCookieRule, cookieThirdParty);
        }
    };

    /**
     * Removes cookie
     *
     * @param {string} name Cookie name
     * @param {string} url Cookie url
     * @return {Promise<any>}
     */
    const apiRemoveCookie = (name, url) => new Promise((resolve) => {
        browser.cookies.remove({ url, name }, () => {
            const ex = browser.runtime.lastError;
            if (ex) {
                adguard.console.error('Error remove cookie {0} - {1}: {2}', name, url, ex);
            }
            resolve();
        });
    });

    /**
     * Updates cookie
     *
     * @param {BrowserApiCookie} apiCookie Cookie for update
     * @param {string} url Cookie url
     * @return {Promise<any>}
     */
    const apiUpdateCookie = (apiCookie, url) => {
        const update = {
            url,
            name: apiCookie.name,
            value: apiCookie.value,
            domain: apiCookie.domain,
            path: apiCookie.path,
            secure: apiCookie.secure,
            httpOnly: apiCookie.httpOnly,
            sameSite: apiCookie.sameSite,
            expirationDate: apiCookie.expirationDate,
        };
        /**
         * Removes domain for host-only cookies:
         * https://developer.chrome.com/extensions/cookies#method-set
         * The domain of the cookie. If omitted, the cookie becomes a host-only cookie.
         */
        if (apiCookie.hostOnly) {
            delete update.domain;
        }
        return new Promise((resolve) => {
            browser.cookies.set(update, () => {
                const ex = browser.runtime.lastError;
                if (ex) {
                    adguard.console.error('Error update cookie {0} - {1}: {2}', apiCookie.name, url, ex);
                }
                resolve();
            });
        });
    };

    /**
     * Get all cookies by name and url
     *
     * @param {string} name Cookie name
     * @param {string} url Cookie url
     * @return {Promise<Array.<BrowserApiCookie>>} array of cookies
     */
    const apiGetCookies = (name, url) => new Promise((resolve) => {
        browser.cookies.getAll({ name, url }, (cookies) => {
            resolve(cookies || []);
        });
    });


    /**
     * Retrieves all cookies by name and url and removes its
     *
     * @param {object} tab
     * @param {string} name Cookie name
     * @param {string} url Cookie url
     * @param {boolean} thirdParty
     * @param {object} rule
     * @param {AddCookieLogEvent} addCookieLogEvent
     * @return {Promise<any[] | never>}
     */
    // eslint-disable-next-line arrow-body-style
    const apiRemoveCookieByRule = (tab, name, url, thirdParty, rule, addCookieLogEvent) => {
        return apiGetCookies(name, url).then((cookies) => {
            const promises = [];
            if (cookies.length > 0) {
                const cookie = cookies[0];
                if (!rule.whiteListRule) {
                    const promise = apiRemoveCookie(name, url);
                    promises.push(promise);
                }
                addCookieLogEvent(tab, cookie.name, cookie.value, cookie.domain, thirdParty, [rule], false);
            }
            return Promise.all(promises);
        });
    };

    /**
     * Retrieves all cookies by name and url, modify by rules and then update
     *
     * @param {object} tab
     * @param {string} name Cookie name
     * @param {string} url Cookie url
     * @param {boolean} thirdParty
     * @param {AddCookieLogEvent} addCookieLogEvent
     * @param {Array} rules Cookie matching rules
     */
    // eslint-disable-next-line arrow-body-style
    const apiModifyCookiesWithRules = (tab, name, url, thirdParty, rules, addCookieLogEvent) => {
        return apiGetCookies(name, url).then((cookies) => {
            const promises = [];
            for (let i = 0; i < cookies.length; i += 1) {
                const cookie = cookies[i];
                // eslint-disable-next-line no-use-before-define
                const mRules = modifyApiCookieByRules(cookie, rules);
                if (mRules && mRules.length > 0) {
                    const promise = apiUpdateCookie(cookie, url);
                    promises.push(promise);
                    addCookieLogEvent(tab, cookie.name, cookie.value, cookie.domain, thirdParty, mRules, true);
                }
            }
            return Promise.all(promises);
        });
    };

    /**
     * Retrieves url for cookie
     * @param {Cookie} setCookie Cookie
     * @param {string} cookieDomain Domain
     * @return {string}
     */
    const getCookieUrl = (setCookie, cookieDomain) => {
        let domain = cookieDomain;
        if (domain[0] === '.') {
            domain = domain.substring(1);
        }
        const protocol = setCookie.secure ? 'https' : 'http';
        return `${protocol}://${domain}${setCookie.path || '/'}`;
    };

    /**
     * Checks if $cookie rule is modifying
     * @param {object} rule $cookie rule
     * @return {boolean}
     */
    const isModifyingRule = (rule) => {
        const opt = rule.getCookieOption();
        return !!opt.sameSite || (typeof opt.maxAge === 'number' && opt.maxAge > 0);
    };

    /**
     * Finds a rule that doesn't modify cookie: i.e. this rule cancels cookie or it's a whitelist rule.
     *
     * @param {string} cookieName Cookie name
     * @param {Array} rules Matching rules
     * @return {object} Found rule or null
     */
    const findNotModifyingRule = (cookieName, rules) => {
        if (rules && rules.length > 0) {
            for (let i = 0; i < rules.length; i += 1) {
                const rule = rules[i];
                const opt = rule.getCookieOption();
                if (opt.matches(cookieName) && !isModifyingRule(rule)) {
                    return rule;
                }
            }
        }
        return null;
    };

    /**
     * Finds rules that modify cookie
     *
     * @param {string} cookieName Cookie name
     * @param {Array} rules Matching rules
     * @return {Array} Modifying rules
     */
    const findModifyingRules = (cookieName, rules) => {
        let result = null;
        if (rules && rules.length > 0) {
            for (let i = 0; i < rules.length; i += 1) {
                const rule = rules[i];
                const opt = rule.getCookieOption();
                if (!opt.matches(cookieName)) {
                    continue;
                }
                // Blocking or whitelist rule exists
                if (!isModifyingRule(rule)) {
                    return null;
                }
                if (result === null) {
                    result = [];
                }
                result.push(rule);
            }
            return result;
        }
        return null;
    };

    /**
     * Updates set-cookie maxAge value
     * @param {Cookie} setCookie Cookie to modify
     * @param {number} maxAge
     * @return {boolean} if cookie was modified
     */
    const updateSetCookieMaxAge = (setCookie, maxAge) => {
        const currentTimeSec = Date.now() / 1000;
        let cookieExpiresTimeSec = null;
        if (setCookie.maxAge) {
            cookieExpiresTimeSec = currentTimeSec + setCookie.maxAge;
        } else if (setCookie.expires) {
            cookieExpiresTimeSec = setCookie.expires.getTime() / 1000;
        }
        const newCookieExpiresTimeSec = currentTimeSec + maxAge;
        if (cookieExpiresTimeSec === null || cookieExpiresTimeSec > newCookieExpiresTimeSec) {
            if (setCookie.expires) {
                setCookie.expires = new Date(newCookieExpiresTimeSec * 1000);
            } else {
                setCookie.maxAge = maxAge;
            }
            return true;
        }
        return false;
    };

    /**
     * Updates API cookie expirationDate value
     * @param {BrowserApiCookie} cookie Cookie to modify
     * @param {number} maxAge
     * @return {boolean} if cookie was modified
     */
    const updateApiCookieMaxAge = (cookie, maxAge) => {
        let cookieExpiresTimeSec = null;
        if (cookie.expirationDate) {
            cookieExpiresTimeSec = cookie.expirationDate;
        }
        const newCookieExpiresTimeSec = Date.now() / 1000 + maxAge;
        if (cookieExpiresTimeSec === null || cookieExpiresTimeSec > newCookieExpiresTimeSec) {
            cookie.expirationDate = newCookieExpiresTimeSec;
            return true;
        }
        return false;
    };

    /**
     * Modifies cookie by rules
     *
     * @param {Cookie} setCookie Cookie to modify
     * @param {Array} rules Cookie matching rules
     * @return {Array} applied rules
     */
    const modifySetCookieByRules = (setCookie, rules) => {
        if (!rules || rules.length === 0) {
            return null;
        }

        const appliedRules = [];
        for (let i = 0; i < rules.length; i += 1) {
            const rule = rules[i];
            const cookieOption = rule.getCookieOption();

            let modified = false;

            // eslint-disable-next-line prefer-destructuring
            const sameSite = cookieOption.sameSite;
            if (sameSite && setCookie.sameSite !== sameSite) {
                setCookie.sameSite = sameSite;
                modified = true;
            }

            if (typeof cookieOption.maxAge === 'number'
                && updateSetCookieMaxAge(setCookie, cookieOption.maxAge)) {
                modified = true;
            }

            if (modified) {
                appliedRules.push(rule);
            }
        }

        return appliedRules;
    };

    /**
     * Process Set-Cookie header modification by rules.
     * Adds corresponding event to the filtering log.
     *
     * @param {object} tab Tab
     * @param {Cookie} setCookie Cookie to modify
     * @param {string} cookieDomain Cookie domain
     * @param {boolean} thirdParty Is Third party request
     * @param {{name: string, value: string}} header Header to modify
     * @param {Array} rules Cookie matching rules
     * @return {boolean} True if Set-Cookie header were modified
     */
    const processModifySetCookieByRules = (tab, setCookie, cookieDomain, thirdParty, header, rules) => {
        const cookieName = setCookie.name;
        const cookieValue = setCookie.value;

        rules = modifySetCookieByRules(setCookie, rules);

        if (rules && rules.length > 0) {
            header.value = adguard.utils.cookie.serialize(setCookie);
            addCookieLogEvent(tab, cookieName, cookieValue, cookieDomain, thirdParty, rules, true);
            return true;
        }

        return false;
    };

    /**
     * Modifies cookie by rules (Cookie is browser.cookies.Cookie object)
     *
     * @param {BrowserApiCookie} cookie
     * @param {Array} rules
     * @return {Array} applied rules
     */
    const modifyApiCookieByRules = (cookie, rules) => {
        const appliedRules = [];

        for (let i = 0; i < rules.length; i += 1) {
            const rule = rules[i];
            const cookieOption = rule.getCookieOption();

            let modified = false;

            // eslint-disable-next-line prefer-destructuring
            const sameSite = cookieOption.sameSite;
            if (sameSite && cookie.sameSite !== sameSite) {
                cookie.sameSite = sameSite;
                modified = true;
            }

            if (typeof cookieOption.maxAge === 'number'
                && updateApiCookieMaxAge(cookie, cookieOption.maxAge)) {
                modified = true;
            }

            if (modified) {
                appliedRules.push(rule);
            }
        }

        return appliedRules;
    };

    /**
     * Modifies request headers according to matching $cookie rules.
     *
     * @param {string} requestId Request identifier
     * @param {Array} requestHeaders Request headers
     * @return {boolean} True if headers were modified
     */
    const filterRequestHeaders = function (requestId, requestHeaders) {
        // Permission is not granted
        if (!browser.cookies) {
            return false;
        }

        const context = adguard.requestContextStorage.get(requestId);
        if (!context) {
            return false;
        }

        const tab = context.tab || {};
        const requestUrl = context.requestUrl || '';
        // Sometimes requests are fired in a refreshed tab, and leading to wrong use
        // referrerUrl of the new tab instead of the origin initiator
        const referrerUrl = context.originUrl || context.referrerUrl;
        const requestType = context.requestType || adguard.RequestTypes.DOCUMENT;

        const cookieHeader = adguard.utils.browser.findHeaderByName(requestHeaders, 'Cookie');
        const cookies = adguard.utils.cookie.parseCookie(cookieHeader ? cookieHeader.value : null);
        if (!cookies) {
            return false;
        }

        // Marks requests without referrer as first-party.
        // It's important to prevent removing google auth cookies. (for requests in background tab)
        const thirdParty = referrerUrl && adguard.utils.url.isThirdPartyRequest(requestUrl, referrerUrl);
        const rules = adguard.webRequestService.getCookieRules(tab, requestUrl, referrerUrl, requestType);
        const stealthRules = adguard.stealthService.getCookieRules(requestUrl, referrerUrl, requestType);
        if ((!rules || rules.length === 0)
            && (!stealthRules || stealthRules.length === 0)) {
            // Nothing to apply
            return false;
        }

        let cookieHeaderModified = false;

        let iCookies = cookies.length;
        // modifying cookies here is safe because we're iterating in reverse order
        // eslint-disable-next-line no-cond-assign
        while (iCookies -= 1) {
            const cookie = cookies[iCookies];
            const cookieName = cookie.name;
            const bRule = findNotModifyingRule(cookieName, rules);
            if (bRule) {
                if (!bRule.whiteListRule) {
                    cookies.splice(iCookies, 1);
                    cookieHeaderModified = true;
                }
                scheduleProcessingCookie(requestId, cookieName, requestUrl, thirdParty, [bRule], true);
            }

            const mRules = findModifyingRules(cookieName, rules);
            if (mRules && mRules.length > 0) {
                scheduleProcessingCookie(requestId, cookieName, requestUrl, thirdParty, mRules, false);
            }

            // If cookie rules found - ignore stealth cookie rules
            const ignoreStealthRules = !!((bRule && !bRule.whiteListRule) || (mRules && mRules.length > 0));
            if (!ignoreStealthRules && stealthRules && stealthRules.length > 0) {
                scheduleProcessingCookie(requestId, cookieName, requestUrl, thirdParty, stealthRules, false);
            }
        }

        if (cookieHeaderModified) {
            cookieHeader.value = cookies.map(c => `${c.name}=${c.value}`).join('; ');
        }

        return cookieHeaderModified;
    };

    /**
     * Modifies response headers according to matching $cookie rules.
     *
     * @param {string} requestId Request identifier
     * @param {Array} responseHeaders Response headers
     * @return {boolean} True if headers were modified
     */
    const filterResponseHeaders = function (requestId, responseHeaders) {
        // Permission is not granted
        if (!browser.cookies) {
            return false;
        }

        /**
         * TODO: These two issues might change the way we're going to implement this:
         * https://bugs.chromium.org/p/chromium/issues/detail?id=827582
         * https://bugs.chromium.org/p/chromium/issues/detail?id=898461
         */

        const context = adguard.requestContextStorage.get(requestId);
        if (!context) {
            return false;
        }

        const tab = context.tab || {};
        const requestUrl = context.requestUrl || '';
        const referrerUrl = context.originUrl || context.referrerUrl;
        const requestType = context.requestType || adguard.RequestTypes.DOCUMENT;
        const requestHost = adguard.utils.url.getHost(requestUrl);

        /**
         * Collects cookies that will be blocked or modified via Set-Cookie header
         * @type {Array.<string>}
         */
        const processedCookies = [];

        let setCookieHeaderModified = false;

        let iResponseHeaders = responseHeaders.length;
        // modifying responseHeaders array here is safe because we're iterating
        // in reverse order
        while (iResponseHeaders > 0) {
            iResponseHeaders -= 1;
            const header = responseHeaders[iResponseHeaders];
            if (!header.name || header.name.toLowerCase() !== 'set-cookie') {
                continue;
            }

            const setCookie = adguard.utils.cookie.parseSetCookie(header.value);
            if (!setCookie) {
                continue;
            }

            const cookieName = setCookie.name;
            const cookieValue = setCookie.value;

            // If not specified, defaults to the host portion of the current document location
            const cookieDomain = setCookie.domain || requestHost;

            const cookieUrl = getCookieUrl(setCookie, cookieDomain);
            // Marks requests without referrer as first-party.
            // It's important to prevent removing google auth cookies. (for requests in background tab)
            const thirdParty = referrerUrl && adguard.utils.url.isThirdPartyRequest(cookieUrl, referrerUrl);
            const rules = adguard.webRequestService.getCookieRules(tab, cookieUrl, referrerUrl, requestType);

            const bRule = findNotModifyingRule(cookieName, rules);
            if (bRule) {
                if (!bRule.whiteListRule) {
                    delete setCookie.expires;
                    setCookie.maxAge = 0;
                    header.value = adguard.utils.cookie.serialize(setCookie);
                    setCookieHeaderModified = true;
                }
                processedCookies.push(cookieName);
                addCookieLogEvent(tab, cookieName, cookieValue, cookieDomain, thirdParty, [bRule], false);
            }

            const mRules = findModifyingRules(cookieName, rules);
            if (processModifySetCookieByRules(tab, setCookie, cookieDomain, thirdParty, header, mRules)) {
                setCookieHeaderModified = true;
                processedCookies.push(cookieName);
            }

            // If cookie rules found - ignore stealth cookie rules
            const ignoreStealthRules = !!((bRule && !bRule.whiteListRule) || (mRules && mRules.length > 0));
            if (!ignoreStealthRules) {
                const stealthRules = adguard.stealthService.getCookieRules(cookieUrl, referrerUrl, requestType);
                if (processModifySetCookieByRules(tab, setCookie, cookieDomain, thirdParty, header, stealthRules)) {
                    setCookieHeaderModified = true;
                    processedCookies.push(cookieName);
                }
            }
        }

        removeProcessingCookies(requestId, processedCookies);
        return setCookieHeaderModified;
    };

    /**
     * Modifies cookies with browser.api
     *
     * @param requestId
     */
    const modifyCookies = (requestId) => {
        // Permission is not granted
        if (!browser.cookies) {
            return false;
        }

        const context = adguard.requestContextStorage.get(requestId);
        if (!context) {
            return false;
        }

        const tab = context.tab || {};

        if (adguard.frames.shouldStopRequestProcess(tab)) {
            adguard.console.debug('Tab is whitelisted or protection is disabled');
            cookiesMap.delete(requestId);
            return false;
        }

        const values = cookiesMap.get(requestId);
        if (!values || values.length === 0) {
            return;
        }

        const promises = [];
        for (let i = 0; i < values.length; i += 1) {
            const value = values[i];
            const cookie = value.cookie || {};
            const rules = value.rules || [];

            let promise;
            if (value.remove) {
                promise = apiRemoveCookieByRule(tab, cookie.name, cookie.url,
                    cookie.thirdParty, rules[0], addCookieLogEvent);
            } else {
                promise = apiModifyCookiesWithRules(tab, cookie.name, cookie.url,
                    cookie.thirdParty, rules, addCookieLogEvent);
            }
            promises.push(promise);
        }

        Promise.all(promises).then(() => {
            cookiesMap.delete(requestId);
        });
    };

    return {
        filterRequestHeaders,
        filterResponseHeaders,
        modifyCookies,
    };
})(adguard);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Object for log http requests
 */
adguard.filteringLog = (function (adguard) {
    'use strict';

    const REQUESTS_SIZE_PER_TAB = 1000;

    const backgroundTabId = adguard.BACKGROUND_TAB_ID;
    const backgroundTab = {
        tabId: backgroundTabId,
        title: adguard.i18n.getMessage('background_tab_title'),
    };

    const tabsInfoMap = Object.create(null);
    let openedFilteringLogsPage = 0;

    // Force to add background tab if it's defined
    if (adguard.prefs.features.hasBackgroundTab) {
        tabsInfoMap[backgroundTabId] = backgroundTab;
    }

    /**
     * Updates tab info (title and url)
     * @param tab
     */
    function updateTabInfo(tab) {
        const tabInfo = tabsInfoMap[tab.tabId] || Object.create(null);
        tabInfo.tabId = tab.tabId;
        tabInfo.title = tab.title;
        tabInfo.isExtensionTab = tab.url && tab.url.indexOf(adguard.app.getExtensionUrl()) === 0;
        tabsInfoMap[tab.tabId] = tabInfo;
        return tabInfo;
    }

    /**
     * Adds tab
     * @param tab
     */
    function addTab(tab) {
        // Background tab can't be added
        // Synthetic tabs are used to send initial requests from new tab in chrome
        if (tab.tabId === backgroundTabId || tab.synthetic) {
            return;
        }

        const tabInfo = updateTabInfo(tab);
        if (tabInfo) {
            adguard.listeners.notifyListeners(adguard.listeners.TAB_ADDED, tabInfo);
        }
    }

    /**
     * Removes tab
     * @param tabId
     */
    function removeTabById(tabId) {
        // Background tab can't be removed
        if (tabId === backgroundTabId) {
            return;
        }

        const tabInfo = tabsInfoMap[tabId];
        if (tabInfo) {
            adguard.listeners.notifyListeners(adguard.listeners.TAB_CLOSE, tabInfo);
        }
        delete tabsInfoMap[tabId];
    }

    /**
     * Updates tab
     * @param tab
     */
    function updateTab(tab) {
        // Background tab can't be updated
        if (tab.tabId === backgroundTabId) {
            return;
        }

        const tabInfo = updateTabInfo(tab);
        if (tabInfo) {
            adguard.listeners.notifyListeners(adguard.listeners.TAB_UPDATE, tabInfo);
        }
    }

    const isScriptRule = rule => rule instanceof adguard.rules.ScriptFilterRule
        || rule instanceof adguard.rules.ScriptletRule;

    /**
     * Copy some properties from source rule to destination rule
     * @param destinationRule
     * @param sourceRule
     */
    const appendProperties = (destinationRule, sourceRule) => {
        if (!destinationRule || !sourceRule) {
            return;
        }

        destinationRule.filterId = sourceRule.filterId;
        destinationRule.ruleText = sourceRule.ruleText;
        if (sourceRule.isImportant) {
            destinationRule.isImportant = sourceRule.isImportant;
        }
        if (sourceRule.convertedRuleText) {
            destinationRule.convertedRuleText = sourceRule.convertedRuleText;
        }
        if (sourceRule.documentLevelRule) {
            destinationRule.documentLevelRule = sourceRule.documentLevelRule;
        }
        if (sourceRule instanceof adguard.rules.ContentFilterRule) {
            destinationRule.contentRule = true;
        } else if (sourceRule instanceof adguard.rules.CssFilterRule) {
            destinationRule.cssRule = true;
        } else if (isScriptRule(sourceRule)) {
            destinationRule.scriptRule = true;
        } else if (sourceRule instanceof adguard.rules.UrlFilterRule) {
            destinationRule.whiteListRule = sourceRule.whiteListRule;
            destinationRule.cspRule = sourceRule.isCspRule();
            destinationRule.cspDirective = sourceRule.cspDirective;
            destinationRule.cookieRule = !!sourceRule.getCookieOption();
        }
    };

    /**
     * Writes to filtering event some useful properties from the request rule
     * @param filteringEvent
     * @param requestRule
     */
    function addRuleToFilteringEvent(filteringEvent, requestRule) {
        filteringEvent.requestRule = {};
        appendProperties(filteringEvent.requestRule, requestRule);
    }

    /**
     * Writes to filtering event some useful properties from the replace rules
     * @param filteringEvent
     * @param replaceRules
     */
    const addReplaceRulesToFilteringEvent = (filteringEvent, replaceRules) => {
        // only replace rules can be applied together
        filteringEvent.requestRule = {};
        filteringEvent.requestRule.replaceRule = true;
        filteringEvent.replaceRules = [];
        replaceRules.forEach((replaceRule) => {
            const tempRule = {};
            appendProperties(tempRule, replaceRule);
            filteringEvent.replaceRules.push(tempRule);
        });
    };

    /**
     * Adds filtering event to log
     * @param tabInfo Tab
     * @param filteringEvent Event to add
     */
    function pushFilteringEvent(tabInfo, filteringEvent) {
        if (!tabInfo.filteringEvents) {
            tabInfo.filteringEvents = [];
        }

        tabInfo.filteringEvents.push(filteringEvent);

        if (tabInfo.filteringEvents.length > REQUESTS_SIZE_PER_TAB) {
            // don't remove first item, cause it's request to main frame
            tabInfo.filteringEvents.splice(1, 1);
        }

        adguard.listeners.notifyListeners(adguard.listeners.LOG_EVENT_ADDED, tabInfo, filteringEvent);
    }

    /**
     * Get filtering info for tab
     * @param tabId
     */
    const getFilteringInfoByTabId = function (tabId) {
        return tabsInfoMap[tabId];
    };

    /**
     * Add request to log
     * @param tab
     * @param requestUrl
     * @param frameUrl
     * @param requestType
     * @param requestRule
     * @param eventId
     */
    const addHttpRequestEvent = function (tab, requestUrl, frameUrl, requestType, requestRule, eventId) {
        if (openedFilteringLogsPage === 0) {
            return;
        }

        const tabInfo = tabsInfoMap[tab.tabId];
        if (!tabInfo) {
            return;
        }

        const requestDomain = adguard.utils.url.getDomainName(requestUrl);
        const frameDomain = adguard.utils.url.getDomainName(frameUrl);

        const filteringEvent = {
            eventId,
            requestUrl,
            requestDomain,
            frameUrl,
            frameDomain,
            requestType,
            requestThirdParty: adguard.utils.url.isThirdPartyRequest(requestUrl, frameUrl),
        };

        if (requestRule) {
            // Copy useful properties
            addRuleToFilteringEvent(filteringEvent, requestRule);
        }

        pushFilteringEvent(tabInfo, filteringEvent);
    };

    /**
     * Add event to log with the corresponding rule
     * @param {{tabId: Number}} tab - Tab object with one of properties tabId
     * @param {(string|Element)} element - String presentation of element or NodeElement
     * @param {String} frameUrl - Frame url
     * @param {String} requestType - Request type
     * @param {{ruleText: String, filterId: Number, isInjectRule: Boolean}} requestRule - Request rule
     */
    const addCosmeticEvent = function (tab, element, frameUrl, requestType, requestRule) {
        if (openedFilteringLogsPage === 0) {
            return;
        }

        if (!requestRule) {
            return;
        }

        const tabInfo = tabsInfoMap[tab.tabId];
        if (!tabInfo) {
            return;
        }

        const frameDomain = adguard.utils.url.getDomainName(frameUrl);
        const filteringEvent = {
            element: typeof element === 'string' ? element : adguard.utils.strings.elementToString(element),
            frameUrl,
            frameDomain,
            requestType,
        };
        if (requestRule) {
            // Copy useful properties
            addRuleToFilteringEvent(filteringEvent, requestRule);
        }

        pushFilteringEvent(tabInfo, filteringEvent);
    };

    /**
     * Add script event to log with the corresponding rule
     * @param {{tabId: Number}} tab - Tab object with one of properties tabId
     * @param {String} frameUrl - Frame url
     * @param {String} requestType - Request type
     * @param {Object} rule - script rule
     */
    const addScriptInjectionEvent = (tab, frameUrl, requestType, rule) => {
        if (openedFilteringLogsPage === 0 || !rule) {
            return;
        }
        const tabInfo = tabsInfoMap[tab.tabId];
        if (!tabInfo) {
            return;
        }
        const frameDomain = adguard.utils.url.getDomainName(frameUrl);
        const filteringEvent = {
            script: true,
            requestUrl: frameUrl,
            frameUrl,
            frameDomain,
            requestType,
        };
        addRuleToFilteringEvent(filteringEvent, rule);
        pushFilteringEvent(tabInfo, filteringEvent);
    };

    /**
     * Binds rule to HTTP request
     * @param tab Tab
     * @param requestRule Request rule
     * @param eventId Event identifier
     */
    const bindRuleToHttpRequestEvent = function (tab, requestRule, eventId) {
        if (openedFilteringLogsPage === 0) {
            return;
        }

        const tabInfo = tabsInfoMap[tab.tabId];
        if (!tabInfo) {
            return;
        }

        const events = tabInfo.filteringEvents;
        if (events) {
            for (let i = events.length - 1; i >= 0; i -= 1) {
                const event = events[i];
                if (event.eventId === eventId) {
                    addRuleToFilteringEvent(event, requestRule);
                    adguard.listeners.notifyListeners(adguard.listeners.LOG_EVENT_UPDATED, tabInfo, event);
                    break;
                }
            }
        }
    };

    /**
     * Replace rules are fired after the event was added
     * We should find event for this rule and update in log UI
     * @param tab
     * @param replaceRules
     * @param eventId
     */
    const bindReplaceRulesToHttpRequestEvent = function (tab, replaceRules, eventId) {
        if (openedFilteringLogsPage === 0) {
            return;
        }

        const tabInfo = tabsInfoMap[tab.tabId];
        if (!tabInfo) {
            return;
        }

        const events = tabInfo.filteringEvents;
        if (events) {
            for (let i = events.length - 1; i >= 0; i -= 1) {
                const event = events[i];
                if (event.eventId === eventId) {
                    addReplaceRulesToFilteringEvent(event, replaceRules);
                    adguard.listeners.notifyListeners(adguard.listeners.LOG_EVENT_UPDATED, tabInfo, event);
                    break;
                }
            }
        }
    };

    /**
     *
     * @param {object} tab
     * @param {string} cookieName
     * @param {string} cookieValue
     * @param {string} cookieDomain
     * @param {string} requestType
     * @param {object} cookieRule
     * @param {boolean} isModifyingCookieRule
     * @param {boolean} thirdParty
     */
    const addCookieEvent = function (tab, cookieName, cookieValue, cookieDomain, requestType, cookieRule, isModifyingCookieRule, thirdParty) {
        if (openedFilteringLogsPage === 0) {
            return;
        }

        const tabInfo = tabsInfoMap[tab.tabId];
        if (!tabInfo) {
            return;
        }

        const filteringEvent = {
            frameDomain: cookieDomain,
            requestType,
            requestThirdParty: thirdParty,
            cookieName,
            cookieValue,
        };

        if (cookieRule) {
            // Copy useful properties
            addRuleToFilteringEvent(filteringEvent, cookieRule);
            filteringEvent.requestRule.isModifyingCookieRule = isModifyingCookieRule;
            if (cookieRule.stealthActions) {
                filteringEvent.stealthActions = cookieRule.stealthActions;
            }
        }

        pushFilteringEvent(tabInfo, filteringEvent);
    };

    /**
     * Binds applied stealth actions to HTTP request
     *
     * @param {object} tab Request tab
     * @param {number} actions Applied actions
     * @param {number} eventId Event identifier
     */
    const bindStealthActionsToHttpRequestEvent = (tab, actions, eventId) => {
        if (openedFilteringLogsPage === 0) {
            return;
        }

        const tabInfo = tabsInfoMap[tab.tabId];
        if (!tabInfo) {
            return;
        }

        const events = tabInfo.filteringEvents;
        if (events) {
            for (let i = events.length - 1; i >= 0; i -= 1) {
                const event = events[i];
                if (event.eventId === eventId) {
                    event.stealthActions = actions;
                    adguard.listeners.notifyListeners(adguard.listeners.LOG_EVENT_UPDATED, tabInfo, event);
                    break;
                }
            }
        }
    };

    /**
     * Remove log requests for tab
     * @param tabId
     */
    const clearEventsByTabId = function (tabId) {
        const tabInfo = tabsInfoMap[tabId];
        if (tabInfo) {
            delete tabInfo.filteringEvents;
            adguard.listeners.notifyListeners(adguard.listeners.TAB_RESET, tabInfo);
        }
    };

    /**
     * Synchronize currently opened tabs with out state
     * @param callback
     */
    const synchronizeOpenTabs = function (callback) {
        adguard.tabs.getAll((tabs) => {
            // As Object.keys() returns strings we convert them to integers,
            // because tabId is integer in extension API
            const tabIdsToRemove = Object.keys(tabsInfoMap).map(id => parseInt(id, 10));
            for (let i = 0; i < tabs.length; i++) {
                const openTab = tabs[i];
                const tabInfo = tabsInfoMap[openTab.tabId];
                if (!tabInfo) {
                    // add tab
                    addTab(openTab);
                } else {
                    // update tab
                    updateTab(openTab);
                }
                const index = tabIdsToRemove.indexOf(openTab.tabId);
                if (index >= 0) {
                    tabIdsToRemove.splice(index, 1);
                }
            }
            for (let j = 0; j < tabIdsToRemove.length; j++) {
                removeTabById(tabIdsToRemove[j]);
            }
            if (typeof callback === 'function') {
                const syncTabs = [];
                for (const tabId in tabsInfoMap) { // jshint ignore:line
                    syncTabs.push(tabsInfoMap[tabId]);
                }
                callback(syncTabs);
            }
        });
    };

    /**
     * We collect filtering events if opened at least one page of log
     */
    const onOpenFilteringLogPage = function () {
        openedFilteringLogsPage++;
    };

    /**
     * Cleanup when last page of log closes
     */
    const onCloseFilteringLogPage = function () {
        openedFilteringLogsPage = Math.max(openedFilteringLogsPage - 1, 0);
        if (openedFilteringLogsPage === 0) {
            // Clear events
            for (const tabId in tabsInfoMap) { // jshint ignore:line
                const tabInfo = tabsInfoMap[tabId];
                delete tabInfo.filteringEvents;
            }
        }
    };

    const isOpen = function () {
        return openedFilteringLogsPage > 0;
    };

    /**
     * We should synchronize open tabs and add listeners to the tabs after application
     * is initialized. Otherwise updating tabs can return wrong stats values and
     * overwrite them with wrong data
     */
    const init = () => {
        // Initialize filtering log
        synchronizeOpenTabs();

        // Bind to tab events
        adguard.tabs.onCreated.addListener(addTab);
        adguard.tabs.onUpdated.addListener(updateTab);
        adguard.tabs.onRemoved.addListener((tab) => {
            removeTabById(tab.tabId);
        });
    };

    return {

        synchronizeOpenTabs,
        init,

        getFilteringInfoByTabId,
        addHttpRequestEvent,
        bindRuleToHttpRequestEvent,
        bindReplaceRulesToHttpRequestEvent,
        addCosmeticEvent,
        addCookieEvent,
        addScriptInjectionEvent,
        bindStealthActionsToHttpRequestEvent,
        clearEventsByTabId,

        isOpen,
        onOpenFilteringLogPage,
        onCloseFilteringLogPage,
    };
})(adguard);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Module for managing requests context.
 *
 * Each request has a context with unique key: requestId
 * Context contains information about this request: id, url, referrer, type, applied rules, original and modified headers
 *
 * This API is exposed via adguard.requestContextStorage:
 *
 * - get - Get context by key
 * - record - Initialize context for request (uses in onBeforeRequest)
 * - update - Updates context properties (rules)
 * - bindContentRule - Binds content rule and removed element to the context
 * - onContentModificationStarted - Must be called to point that content modification is started
 *   Following 2 methods have same logic (push rules to log, record rule hits and perform cleanup), but called in different cases:
 * - onRequestCompleted - Finishes request processing on request complete/error event.
 * - onContentModificationFinished - After content modification and applying all rules (replace and content)
 */
(function (adguard) {

    /**
     * @typedef {object} RequestContext
     * @property {string} requestId - Request identifier
     * @property {string} requestUrl - Request url
     * @property {string} referrerUrl - Request referrer url
     * @property {string} requestType - Request type
     * @property {{tabId: Number}} tab - Request tab
     * @property {Array} requestHeaders - Original request headers
     * @property {Array} modifiedRequestHeaders - Modified request headers
     * @property {Array} responseHeaders - Original response headers
     * @property {Array} modifiedResponseHeaders - Modified response headers
     * @property {object} requestRule - Request rule
     * @property {Array} replaceRules - Applied replace rules
     * @property {Array} contentRules - Content rules
     * @property {Array} cspRules CSP - rules
     * @property {number} eventId - Internal counter for log events
     * @property {number} requestState - Is request between onBeforeRequest and onCompleted/onErrorOccurred events
     * @property {number} contentModifyingState - Is content modification started
     * @property {Map<object, string[]>} elements - Content rules attached elements
     * @property {number} stealthActions - Applied stealth actions
     */

    /**
     * @typedef {object} States
     * @property {number} NONE - Ready for cleanup (not started or already finished and processed)
     * @property {number} PROCESSING - In progress
     * @property {number} DONE - Finished, ready for processing. Next transition to NONE and cleanup
     */
    const States = {
        NONE: 1,
        PROCESSING: 2,
        DONE: 3
    };

    /**
     * Collects context
     * @type {Map<string, RequestContext>}
     */
    const contexts = new Map();

    /**
     * Event counter for pushing rules to the filtering log on request complete/error
     * Don't use requestId, because redirected requests have the same request identifier
     * @type {number}
     */
    let nextEventId = 0;

    /**
     * Append rules to the current rules
     * @param {Array} original - Original value
     * @param {Array}toAppend - Value to append
     * @returns {Array} concatenated value
     */
    const appendRules = (original, toAppend) => {
        if (toAppend) {
            original = (original || []).concat(toAppend);
        }
        return original;
    };

    /**
     * Creates copy of headers array
     * @param headers Headers to copy
     * @return {{name: *, value: *}[]}
     */
    const copyHeaders = (headers) => (headers || []).map(h => ({ name: h.name, value: h.value }));

    /**
     * Generates next event identifier
     * @returns {number}
     */
    const getNextEventId = () => {
        nextEventId += 1;
        return nextEventId;
    };

    /**
     * Gets request context
     * @param {string} requestId Request identifier
     */
    const get = (requestId) => {
        return contexts.get(requestId);
    };

    /**
     * Records request context
     *
     * @param {string} requestId Request identifier
     * @param {string} requestUrl Request url
     * @param {string} referrerUrl Request referrer url
     * @param {string} originUrl Request origin url (initiator)
     * @param {string} requestType Request type
     * @param {object} tab Request tab
     */
    const record = (requestId, requestUrl, referrerUrl, originUrl, requestType, tab) => {

        const eventId = getNextEventId();

        // Clears filtering log. If contexts map already contains this requests that means that we caught redirect
        if (requestType === adguard.RequestTypes.DOCUMENT && !contexts.has(requestId)) {
            adguard.filteringLog.clearEventsByTabId(tab.tabId);
        }

        const context = {
            requestId, requestUrl, referrerUrl, originUrl, requestType, tab,
            eventId,
            requestState: States.PROCESSING,
            contentModifyingState: States.NONE,
        };
        contexts.set(requestId, context);

        adguard.filteringLog.addHttpRequestEvent(tab, requestUrl, referrerUrl, requestType, null, eventId);
    };

    /**
     * Some "requests" can't be intercepted by webRequest API: WS and WebRTC, popups.
     * So them don't have usual request identifier and must be processing in the other way.
     * @param requestUrl {string} Request URL
     * @param referrerUrl {string} Referrer
     * @param requestType {string} Request type
     * @param tab {object} Tab
     * @param requestRule {object} Request rule
     */
    const recordEmulated = (requestUrl, referrerUrl, requestType, tab, requestRule) => {
        adguard.filteringLog.addHttpRequestEvent(tab, requestUrl, referrerUrl, requestType, requestRule);
        adguard.webRequestService.recordRuleHit(tab, requestRule, requestUrl);
    };

    /**
     * Updates request context
     * @param {string} requestId Request identifier
     * @param {RequestContext} update
     */
    const update = (requestId, update) => {

        const context = contexts.get(requestId);
        if (!context) {
            return;
        }

        // Updates request lifecycle
        if ('requestState' in update) {
            context.requestState = update.requestState;
        }
        if ('contentModifyingState' in update) {
            context.contentModifyingState = update.contentModifyingState;
        }

        // Updates rules for request
        if ('requestRule' in update) {
            context.requestRule = update.requestRule;
            // Some requests may execute for a long time, that's why we update filtering log when
            // we get a request rule
            adguard.filteringLog.bindRuleToHttpRequestEvent(context.tab,
                context.requestRule,
                context.eventId);
        }
        if ('replaceRules' in update) {
            context.replaceRules = update.replaceRules;
        }
        if ('cspRules' in update) {
            context.cspRules = appendRules(context.cspRules, update.cspRules);
        }
        if ('stealthActions' in update) {
            context.stealthActions = update.stealthActions;
        }

        if ('requestHeaders' in update) {
            context.requestHeaders = copyHeaders(update.requestHeaders);
        }
        if ('responseHeaders' in update) {
            context.responseHeaders = copyHeaders(update.responseHeaders);
        }
        if ('modifiedRequestHeaders' in update) {
            context.modifiedRequestHeaders = copyHeaders(update.modifiedRequestHeaders);
        }
        if ('modifiedResponseHeaders' in update) {
            context.modifiedResponseHeaders = copyHeaders(update.modifiedResponseHeaders);
        }
    };

    /**
     * Binds content rule with serialized element to the request
     *
     * @param {string} requestId Request identifier
     * @param {object} rule Content rule
     * @param {object} elementHtml Serialized HTML element
     */
    const bindContentRule = (requestId, rule, elementHtml) => {

        const context = contexts.get(requestId);
        if (!context) {
            return;
        }

        context.contentRules = appendRules(context.contentRules, [rule]);
        if (!context.elements) {
            context.elements = new Map();
        }

        let ruleElements = context.elements.get(rule);
        if (!ruleElements) {
            ruleElements = [];
            context.elements.set(rule, ruleElements);
        }
        ruleElements.push(elementHtml);
    };

    /**
     * Finishes request processing
     *
     * Invoked in the following cases:
     * 1) on complete/error event for request
     * 2) on content modification finished
     *
     * In case of content modification don't forget to call onContentModificationStarted method
     * to prevent removing context for complete/error event for request
     *
     * @param {string} requestId Request identifier
     */
    const remove = (requestId) => {

        const context = contexts.get(requestId);
        if (!context) {
            return;
        }

        const tab = context.tab;
        const requestUrl = context.requestUrl;
        const referrerUrl = context.referrerUrl;

        let ruleHitsRecords = [];

        if (context.requestState === States.DONE) {

            context.requestState = States.NONE;

            const requestRule = context.requestRule;
            const cspRules = context.cspRules;
            const stealthActions = context.stealthActions;

            if (requestRule) {
                adguard.filteringLog.bindRuleToHttpRequestEvent(tab, requestRule, context.eventId);
                ruleHitsRecords.push(requestRule);
            }

            if (cspRules) {
                for (let cspRule of cspRules) {
                    adguard.filteringLog.addHttpRequestEvent(tab, requestUrl, referrerUrl, adguard.RequestTypes.CSP, cspRule);
                }
                ruleHitsRecords = ruleHitsRecords.concat(cspRules);
            }

            if (stealthActions) {
                adguard.filteringLog.bindStealthActionsToHttpRequestEvent(tab, stealthActions, context.eventId);
            }
        }

        if (context.contentModifyingState === States.DONE) {

            context.contentModifyingState = States.NONE;

            const replaceRules = context.replaceRules;
            const contentRules = context.contentRules;

            if (replaceRules) {
                adguard.filteringLog.bindReplaceRulesToHttpRequestEvent(tab, replaceRules, context.eventId);
                ruleHitsRecords.push(replaceRules);
            }

            if (contentRules) {
                for (let contentRule of contentRules) {
                    const elements = context.elements.get(contentRule) || [];
                    for (let element of elements) {
                        adguard.filteringLog.addCosmeticEvent(tab, element, requestUrl, context.requestType, contentRule);
                    }
                    context.elements.delete(contentRule);
                }
                ruleHitsRecords = ruleHitsRecords.concat(contentRules);
            }
        }

        for (let i = 0; i < ruleHitsRecords.length; i += 1) {
            adguard.webRequestService.recordRuleHit(tab, ruleHitsRecords[i], requestUrl);
        }

        // All processes finished
        if (context.requestState === States.NONE &&
            context.contentModifyingState === States.NONE) {

            contexts.delete(requestId);
        }
    };

    /**
     * Called on request complete/error event
     *
     * @param {string} requestId Request identifier
     */
    const onRequestCompleted = (requestId) => {
        update(requestId, { requestState: States.DONE });
        remove(requestId);
    };

    /**
     * Indicates that content modification in progress
     *
     * @param {string} requestId Request identifier
     */
    const onContentModificationStarted = (requestId) => {
        update(requestId, { contentModifyingState: States.PROCESSING });
    };

    /**
     * Indicates that content modification finished
     *
     * @param {string} requestId Request identifier
     */
    const onContentModificationFinished = (requestId) => {
        update(requestId, { contentModifyingState: States.DONE });
        remove(requestId);
    };

    // Expose
    adguard.requestContextStorage = {
        get,
        record,
        recordEmulated,
        update,
        bindContentRule,
        onRequestCompleted,
        onContentModificationStarted,
        onContentModificationFinished,
    }

})(adguard);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (adguard, api) {
    const stringUtils = adguard.utils.strings;
    /**
     * AdGuard scriptlet mask
     */
    // eslint-disable-next-line no-template-curly-in-string
    const ADGUARD_SCRIPTLET_MASK = '${domains}#%#//scriptlet(${args})';

    /**
     * AdGuard scriptlet exception mask
     */
    // eslint-disable-next-line no-template-curly-in-string
    const ADGUARD_SCRIPTLET_EXCEPTION_MASK = '${domains}#@%#//scriptlet(${args})';

    /**
     * uBlock scriptlet rule mask
     */
    const UBO_SCRIPTLET_MASK_REG = /#@?#script:inject|#@?#\s*\+js/;
    const UBO_SCRIPTLET_MASK_1 = '##+js';
    const UBO_SCRIPTLET_MASK_2 = '##script:inject';
    const UBO_SCRIPTLET_EXCEPTION_MASK_1 = '#@#+js';
    const UBO_SCRIPTLET_EXCEPTION_MASK_2 = '#@#script:inject';
    const UBO_SCRIPT_TAG_MASK = '##^script';
    /**
     * AdGuard max-length tag for uBlock scripts conversion
     */
    const ADGUARD_SCRIPT_MAX_LENGTH = '[max-length="262144"]';
    /**
     * AdBlock Plus snippet rule mask
     */
    const ABP_SCRIPTLET_MASK = '#$#';
    const ABP_SCRIPTLET_EXCEPTION_MASK = '#@$#';

    /**
     * AdGuard CSS rule mask
     */
    const ADG_CSS_MASK_REG = /#@?\$#.+?\s*\{.*\}\s*$/g;

    /**
     * Return array of strings separated by space which not in quotes
     * @param {string} str
     */
    function getSentences(str) {
        const reg = /'.*?'|".*?"|\S+/g;
        return str.match(reg);
    }

    /**
     * Returns substring enclosed in the widest braces
     * @param {string} str
     */
    function getStringInBraces(str) {
        const firstIndex = str.indexOf('(');
        const lastIndex = str.lastIndexOf(')');
        return str.substring(firstIndex + 1, lastIndex);
    }

    /**
     * Wrap str in double qoutes and replaces single quotes if need
     * @param {string} str
     */
    function wrapInDoubleQuotes(str) {
        if (str[0] === '\'' && str[str.length - 1] === '\'') {
            str = str.substring(1, str.length - 1);
            str = str.replace(/\"/g, '\\"');
        } else if (str[0] === '"' && str[str.length - 1] === '"') {
            str = str.substring(1, str.length - 1);
            str = str.replace(/\'/g, '\\\'');
        }
        return `"${str}"`;
    }


    /**
     * Replace string with data by placeholders
     * @param {string} str
     * @param {Object} data where keys is placeholdes names
     */
    function replacePlaceholders(str, data) {
        return Object.keys(data).reduce((acc, key) => {
            const reg = new RegExp(`\\$\\{${key}\\}`, 'g');
            acc = acc.replace(reg, data[key]);
            return acc;
        }, str);
    }

    /**
     * Convert string of UBO scriptlet rule to AdGuard scritlet rule
     * @param {string} rule UBO scriptlet rule
     */
    function convertUboScriptletRule(rule) {
        const domains = stringUtils.getBeforeRegExp(rule, UBO_SCRIPTLET_MASK_REG);
        const mask = rule.match(UBO_SCRIPTLET_MASK_REG)[0];
        let template;
        if (mask.indexOf('@') > -1) {
            template = ADGUARD_SCRIPTLET_EXCEPTION_MASK;
        } else {
            template = ADGUARD_SCRIPTLET_MASK;
        }
        const args = getStringInBraces(rule)
            .split(/, /g)
            .map((arg, index) => (index === 0 ? `ubo-${arg}` : arg))
            .map(arg => wrapInDoubleQuotes(arg))
            .join(', ');

        return replacePlaceholders(
            template,
            { domains, args }
        );
    }

    /**
     * Convert string of ABP scriptlet rule to AdGuard scritlet rule
     * @param {string} rule UBO scriptlet rule
     */
    function convertAbpSnippetRule(rule) {
        const SEMICOLON_DIVIDER = /;(?=(?:(?:[^"]*"){2})*[^"]*$)/g;
        const mask = rule.indexOf(ABP_SCRIPTLET_MASK) > -1
            ? ABP_SCRIPTLET_MASK
            : ABP_SCRIPTLET_EXCEPTION_MASK;
        const template = mask === ABP_SCRIPTLET_MASK
            ? ADGUARD_SCRIPTLET_MASK
            : ADGUARD_SCRIPTLET_EXCEPTION_MASK;
        const domains = stringUtils.substringBefore(rule, mask);
        const args = stringUtils.substringAfter(rule, mask);
        return args.split(SEMICOLON_DIVIDER)
            .map(args => getSentences(args)
                .filter(arg => arg)
                .map((arg, index) => (index === 0 ? `abp-${arg}` : arg))
                .map(arg => wrapInDoubleQuotes(arg))
                .join(', '))
            .map(args => replacePlaceholders(template, { domains, args }));
    }

    /**
     * Check is uBO scriptlet rule
     * @param {string} rule rule text
     */
    function isUboScriptletRule(rule) {
        return (
            rule.indexOf(UBO_SCRIPTLET_MASK_1) > -1
            || rule.indexOf(UBO_SCRIPTLET_MASK_2) > -1
            || rule.indexOf(UBO_SCRIPTLET_EXCEPTION_MASK_1) > -1
            || rule.indexOf(UBO_SCRIPTLET_EXCEPTION_MASK_2) > -1
        )
            && UBO_SCRIPTLET_MASK_REG.test(rule);
    }

    /**
     * Check is AdBlock Plus snippet
     * @param {string} rule rule text
     */
    function isAbpSnippetRule(rule) {
        return (
            rule.indexOf(ABP_SCRIPTLET_MASK) > -1
            || rule.indexOf(ABP_SCRIPTLET_EXCEPTION_MASK) > -1
        ) && rule.search(ADG_CSS_MASK_REG) === -1;
    }

    /**
     * Converts UBO Script rule
     * @param {string} ruleText rule text
     * @returns {string} converted rule
     */
    function convertUboScriptTagRule(ruleText) {
        if (ruleText.indexOf(UBO_SCRIPT_TAG_MASK) === -1) {
            return null;
        }

        // We convert only one case ##^script:has-text at now
        const uboHasTextRule = ':has-text';
        const adgScriptTag = '$$script';
        const uboScriptTag = '##^script';

        const isRegExp = str => str[0] === '/' && str[str.length - 1] === '/';

        const match = ruleText.split(uboHasTextRule);
        if (match.length === 1) {
            return null;
        }

        const domains = match[0].replace(uboScriptTag, '');
        const rules = [];
        for (let i = 1; i < match.length; i += 1) {
            const attr = match[i].slice(1, -1);
            if (isRegExp(attr)) {
                rules.push(`${domains}${uboScriptTag}${uboHasTextRule}(${attr})`);
            } else {
                rules.push(`${domains}${adgScriptTag}[tag-content="${attr}"]${ADGUARD_SCRIPT_MAX_LENGTH}`);
            }
        }

        return rules;
    }

    /**
     * Returns false or converted rule
     *
     * Example:
     * "example.com##h1:style(background-color: blue !important)"
     * -> "example.com##h1 {background-color: blue !important}"
     *
     * @param {string} ruleText - rule text to check if should be checked and if necessary converted
     * @return {string|boolean} - converted rule text or false
     */
    function convertUboCssStyleRule(ruleText) {
        const UBO_CSS_RULE_MARKERS = {
            MASK_CSS_RULE: '##',
            MASK_CSS_EXCEPTION_RULE: '#@#',
            MASK_CSS_EXTENDED_CSS_RULE: '#?#',
            MASK_CSS_EXCEPTION_EXTENDED_CSS_RULE: '#@?#',
        };

        const CSS_TO_INJECT_PAIRS = {
            [UBO_CSS_RULE_MARKERS.MASK_CSS_RULE]: '#$#',
            [UBO_CSS_RULE_MARKERS.MASK_CSS_EXCEPTION_RULE]: '#@$#',
            [UBO_CSS_RULE_MARKERS.MASK_CSS_EXTENDED_CSS_RULE]: '#$?#',
            [UBO_CSS_RULE_MARKERS.MASK_CSS_EXCEPTION_EXTENDED_CSS_RULE]: '#@$?#',
        };

        const RULE_MARKER_FIRST_CHAR = '#';

        const UBO_CSS_STYLE_PSEUDO_CLASS = ':style(';

        const uboMarkers = Object.keys(UBO_CSS_RULE_MARKERS).map(key => UBO_CSS_RULE_MARKERS[key]);

        const mask = api.FilterRule.findRuleMarker(
            ruleText,
            uboMarkers,
            RULE_MARKER_FIRST_CHAR
        );
        if (!mask) {
            return null;
        }
        const maskIndex = ruleText.indexOf(mask);
        const cssContent = ruleText.substring(maskIndex + mask.length);
        const shouldConvert = cssContent.indexOf(UBO_CSS_STYLE_PSEUDO_CLASS) > -1;
        if (!shouldConvert) {
            return null;
        }

        const domainsPart = ruleText.substring(0, maskIndex);
        const regex = /:style\s*\(\s*(\S+.*\S)\s*\)/;
        const subst = ' { $1 }';
        const convertedCssContent = cssContent.replace(regex, subst);
        if (convertedCssContent === cssContent) {
            throw new Error(`Empty :style pseudo class: ${cssContent}`);
        }
        return domainsPart + CSS_TO_INJECT_PAIRS[mask] + convertedCssContent;
    }

    /**
     * Converts abp rule into ag rule
     * e.g.
     * from:    "||example.org^$rewrite=abp-resource:blank-mp3"
     * to:      "||example.org^$redirect:blank-mp3"
     * @param {string} rule
     * @returns {string|null}
     */
    function convertAbpRedirectRule(rule) {
        const ABP_REDIRECT_KEYWORD = 'rewrite=abp-resource:';
        const AG_REDIRECT_KEYWORD = 'redirect=';
        if (!rule.includes(ABP_REDIRECT_KEYWORD)) {
            return null;
        }
        return rule.replace(ABP_REDIRECT_KEYWORD, AG_REDIRECT_KEYWORD);
    }

    function convertOptions(rule) {
        const OPTIONS_DELIMITER = '$';
        const ESCAPE_CHARACTER = '\\';
        const NAME_VALUE_SPLITTER = '=';
        const EMPTY_OPTION = 'empty';
        const MP4_OPTION = 'mp4';
        const CSP_OPTION = 'csp';
        const INLINE_SCRIPT_OPTION = 'inline-script';
        const INLINE_FONT_OPTION = 'inline-font';
        const MEDIA_OPTION = 'media';
        const ALL_OPTION = 'all';
        const POPUP_OPTION = 'popup';
        const DOCUMENT_OPTION = 'document';
        const GENERICHIDE_OPTION = 'generichide';
        const ELEMHIDE_OPTION = 'elemhide';

        /* eslint-disable max-len */
        const conversionMap = {
            [EMPTY_OPTION]: 'redirect=nooptext',
            [MP4_OPTION]: 'redirect=noopmp4-1s',
            [INLINE_SCRIPT_OPTION]: `${CSP_OPTION}=script-src 'self' 'unsafe-eval' http: https: data: blob: mediastream: filesystem:`,
            [INLINE_FONT_OPTION]: `${CSP_OPTION}=font-src 'self' 'unsafe-eval' http: https: data: blob: mediastream: filesystem:`,
            ['ghide']: GENERICHIDE_OPTION,
            ['ehide']: ELEMHIDE_OPTION,
        };
        /* eslint-enable max-len */

        let options;
        let domainPart;

        // Start looking from the prev to the last symbol
        // If dollar sign is the last symbol - we simply ignore it.
        for (let i = (rule.length - 2); i >= 0; i -= 1) {
            const currChar = rule.charAt(i);
            if (currChar !== OPTIONS_DELIMITER) {
                continue;
            }
            if (i > 0 && rule.charAt(i - 1) !== ESCAPE_CHARACTER) {
                domainPart = rule.substring(0, i);
                options = rule.substring(i + 1);
                // Options delimiter was found, doing nothing
                break;
            }
        }
        if (!options) {
            return null;
        }
        const optionsParts = options.split(',');
        let optionsConverted = false;

        let updatedOptionsParts = optionsParts.map((optionsPart) => {
            let convertedOptionsPart = conversionMap[optionsPart];

            // if option is $mp4, than it should go with $media option together
            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1452
            if (optionsPart === MP4_OPTION) {
                // check if media is not already among options
                if (!optionsParts.some(option => option === MEDIA_OPTION)) {
                    convertedOptionsPart = `${convertedOptionsPart},media`;
                }
            }

            if (convertedOptionsPart) {
                optionsConverted = true;
                return convertedOptionsPart;
            }

            return optionsPart;
        });

        // if has more than one csp modifiers, we merge them into one;
        const cspParts = updatedOptionsParts.filter(optionsPart => stringUtils.startWith(optionsPart, CSP_OPTION));

        if (cspParts.length > 1) {
            const allButCsp = updatedOptionsParts
                .filter(optionsPart => !stringUtils.startWith(optionsPart, CSP_OPTION));

            const cspValues = cspParts.map((cspPart) => {
                // eslint-disable-next-line no-unused-vars
                const [_, value] = cspPart.split(NAME_VALUE_SPLITTER);
                return value;
            });

            const updatedCspOption = `${CSP_OPTION}${NAME_VALUE_SPLITTER}${cspValues.join('; ')}`;
            updatedOptionsParts = allButCsp.concat(updatedCspOption);
        }

        // options without all modifier
        const hasAllOption = updatedOptionsParts.indexOf(ALL_OPTION) > -1;

        if (hasAllOption) {
            // $all modifier should be converted in 4 rules
            // ||example.org^$document,popup
            // ||example.org^
            // ||example.org^$inline-font
            // ||example.org^$inline-script
            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1506
            const allOptionReplacers = [
                [DOCUMENT_OPTION, POPUP_OPTION],
                [INLINE_SCRIPT_OPTION],
                [INLINE_FONT_OPTION],
                [''], //
            ];
            return allOptionReplacers.map((replacers) => {
                // remove replacer and all option from the list
                const optionsButAllAndReplacer = updatedOptionsParts
                    .filter(option => !(replacers.includes(option) || option === ALL_OPTION));

                // try get converted values, used for INLINE_SCRIPT_OPTION, INLINE_FONT_OPTION
                const convertedReplacers = replacers.map(replacer => conversionMap[replacer] || replacer);

                // add replacer to the list of options
                const updatedOptionsString = [...convertedReplacers, ...optionsButAllAndReplacer]
                    .filter(entity => entity)
                    .join(',');

                // create a new rule
                return updatedOptionsString.length < 1 ? domainPart : `${domainPart}\$${updatedOptionsString}`;
            });
        }

        if (optionsConverted) {
            const updatedOptions = updatedOptionsParts.join(',');
            return `${domainPart}\$${updatedOptions}`;
        }

        return null;
    }

    /**
     * Checks if rule text is comment e.g. !!example.org##+js(set-constant.js, test, false)
     * @param {string} rule
     * @return {boolean}
     */
    const isComment = rule => stringUtils.startWith(rule, api.FilterRule.COMMENT);

    /**
     * Convert external scriptlet rule to AdGuard scriptlet syntax
     * @param {string} rule convert rule
     */
    function convertRule(rule) {
        if (isComment(rule)) {
            return rule;
        }
        if (isUboScriptletRule(rule)) {
            return convertUboScriptletRule(rule);
        }
        if (isAbpSnippetRule(rule)) {
            return convertAbpSnippetRule(rule);
        }

        const uboScriptRule = convertUboScriptTagRule(rule);
        if (uboScriptRule) {
            return uboScriptRule;
        }

        const uboCssStyleRule = convertUboCssStyleRule(rule);
        if (uboCssStyleRule) {
            return uboCssStyleRule;
        }

        // Convert abp redirect rule
        const abpRedirectRule = convertAbpRedirectRule(rule);
        if (abpRedirectRule) {
            return abpRedirectRule;
        }

        // Convert options
        const ruleWithConvertedOptions = convertOptions(rule);
        if (ruleWithConvertedOptions) {
            return ruleWithConvertedOptions;
        }

        return rule;
    }

    api.ruleConverter = { convertRule };
})(adguard, adguard.rules);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 *  Initialize Content => BackgroundPage messaging
 */
(function (adguard) {

    'use strict';

    /**
     * Contains event listeners from content pages
     */
    var eventListeners = Object.create(null);

    /**
     * Adds event listener from content page
     * @param message
     * @param sender
     */
    function processAddEventListener(message, sender) {
        var listenerId = adguard.listeners.addSpecifiedListener(message.events, function () {
            var sender = eventListeners[listenerId];
            if (sender) {
                adguard.tabs.sendMessage(sender.tab.tabId, {
                    type: 'notifyListeners',
                    args: Array.prototype.slice.call(arguments)
                });
            }
        });
        eventListeners[listenerId] = sender;
        return { listenerId: listenerId };
    }

    /**
     * Constructs objects that uses on extension pages, like: options.html, thankyou.html etc
     */
    function processInitializeFrameScriptRequest() {

        var enabledFilters = Object.create(null);

        var AntiBannerFiltersId = adguard.utils.filters.ids;

        for (var key in AntiBannerFiltersId) {
            if (AntiBannerFiltersId.hasOwnProperty(key)) {
                var filterId = AntiBannerFiltersId[key];
                var enabled = adguard.filters.isFilterEnabled(filterId);
                if (enabled) {
                    enabledFilters[filterId] = true;
                }
            }
        }

        return {
            userSettings: adguard.settings.getAllSettings(),
            enabledFilters: enabledFilters,
            filtersMetadata: adguard.subscriptions.getFilters(),
            requestFilterInfo: adguard.requestFilter.getRequestFilterInfo(),
            environmentOptions: {
                isMacOs: adguard.utils.browser.isMacOs(),
                canBlockWebRTC: adguard.stealthService.canBlockWebRTC(),
                isChrome: adguard.utils.browser.isChromeBrowser(),
                Prefs: {
                    locale: adguard.app.getLocale(),
                    mobile: adguard.prefs.mobile || false,
                },
                appVersion: adguard.app.getVersion(),
            },
            constants: {
                AntiBannerFiltersId: adguard.utils.filters.ids,
                EventNotifierTypes: adguard.listeners.events,
            },
        };
    }

    /**
     * Saves css hits from content-script.
     * Message includes stats field. [{filterId: 1, ruleText: 'rule1'}, {filterId: 2, ruleText: 'rule2'}...]
     * @param tab
     * @param stats
     */
    function processSaveCssHitStats(tab, stats) {
        if (!adguard.webRequestService.isCollectingCosmeticRulesHits(tab)) {
            return;
        }
        var frameUrl = adguard.frames.getMainFrameUrl(tab);
        for (let i = 0; i < stats.length; i += 1) {
            const stat = stats[i];
            const rule = adguard.rules.builder.createRule(stat.ruleText, stat.filterId);
            adguard.webRequestService.recordRuleHit(tab, rule, frameUrl);
            adguard.filteringLog.addCosmeticEvent(tab, stat.element, tab.url, adguard.RequestTypes.DOCUMENT, rule);
        }
    }


    /**
     * Main function for processing messages from content-scripts
     *
     * @param message
     * @param sender
     * @param callback
     * @returns {*}
     */
    function handleMessage(message, sender, callback) {
        switch (message.type) {
            case 'unWhiteListFrame':
                adguard.userrules.unWhiteListFrame(message.frameInfo);
                break;
            case 'addEventListener':
                return processAddEventListener(message, sender);
            case 'removeListener':
                var listenerId = message.listenerId;
                adguard.listeners.removeListener(listenerId);
                delete eventListeners[listenerId];
                break;
            case 'initializeFrameScript':
                return processInitializeFrameScriptRequest();
            case 'changeUserSetting':
                adguard.settings.setProperty(message.key, message.value);
                break;
            case 'checkRequestFilterReady':
                return { ready: adguard.requestFilter.isReady() };
            case 'addAndEnableFilter':
                adguard.filters.addAndEnableFilters([message.filterId]);
                break;
            case 'disableAntiBannerFilter':
                if (message.remove) {
                    adguard.filters.uninstallFilters([message.filterId]);
                } else {
                    adguard.filters.disableFilters([message.filterId]);
                }
                break;
            case 'removeAntiBannerFilter':
                adguard.filters.removeFilter(message.filterId);
                break;
            case 'enableFiltersGroup':
                adguard.categories.enableFiltersGroup(message.groupId);
                break;
            case 'disableFiltersGroup':
                adguard.categories.disableFiltersGroup(message.groupId);
                break;
            case 'changeDefaultWhiteListMode':
                adguard.whitelist.changeDefaultWhiteListMode(message.enabled);
                break;
            case 'getWhiteListDomains': {
                const whiteListDomains = adguard.whitelist.getWhiteListDomains();
                const appVersion = adguard.app.getVersion();
                callback({ content: whiteListDomains.join('\r\n'), appVersion });
                break;
            }
            case 'saveWhiteListDomains': {
                const domains = message.content.split(/[\r\n]+/)
                    .map(string => string.trim())
                    .filter(string => string.length > 0);
                adguard.whitelist.updateWhiteListDomains(domains);
                break;
            }
            case 'getUserRules':
                adguard.userrules.getUserRulesText((content) => {
                    const appVersion = adguard.app.getVersion();
                    callback({ content, appVersion });
                });
                return true;
            case 'saveUserRules':
                adguard.userrules.updateUserRulesText(message.content);
                break;
            case 'addUserRule':
                adguard.userrules.addRules([message.ruleText]);
                break;
            case 'removeUserRule':
                adguard.userrules.removeRule(message.ruleText);
                break;
            case 'checkAntiBannerFiltersUpdate':
                adguard.ui.checkFiltersUpdates();
                break;
            case 'loadCustomFilterInfo':
                adguard.filters.loadCustomFilterInfo(message.url, { title: message.title }, (filter) => {
                    callback({ filter });
                }, (error) => {
                    callback({ error });
                });
                return true;
            case 'subscribeToCustomFilter': {
                const { url, title, trusted } = message;
                adguard.filters.loadCustomFilter(url, { title, trusted }, (filter) => {
                    adguard.filters.addAndEnableFilters([filter.filterId], () => {
                        callback(filter);
                    });
                }, () => {
                    callback();
                });
                return true;
            }
            case 'getFiltersMetadata':
                return adguard.categories.getFiltersMetadata();
            case 'setFiltersUpdatePeriod':
                adguard.settings.setFiltersUpdatePeriod(message.updatePeriod);
                break;
            case 'openThankYouPage':
                adguard.ui.openThankYouPage();
                break;
            case 'openExtensionStore':
                adguard.ui.openExtensionStore();
                break;
            case 'openFilteringLog':
                adguard.ui.openFilteringLog(message.tabId);
                break;
            case 'openExportRulesTab':
                adguard.ui.openExportRulesTab(message.hash);
                break;
            case 'openSafebrowsingTrusted':
                adguard.safebrowsing.addToSafebrowsingTrusted(message.url);
                adguard.tabs.getActive(function (tab) {
                    adguard.tabs.reload(tab.tabId, message.url);
                });
                break;
            case 'openTab':
                adguard.ui.openTab(message.url, message.options);
                break;
            case 'resetBlockedAdsCount':
                adguard.frames.resetBlockedAdsCount();
                break;
            case 'getSelectorsAndScripts': {
                let urlForSelectors;
                // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1498
                // when document url for iframe is about:blank then we use tab url
                if (!adguard.utils.url.isHttpOrWsRequest(message.documentUrl) && sender.frameId !== 0) {
                    urlForSelectors = sender.tab.url;
                } else {
                    urlForSelectors = message.documentUrl;
                }
                return adguard.webRequestService.processGetSelectorsAndScripts(sender.tab, urlForSelectors) || {};
            }
            case 'checkPageScriptWrapperRequest':
                var block = adguard.webRequestService.checkPageScriptWrapperRequest(sender.tab, message.elementUrl, message.documentUrl, message.requestType);
                return { block: block, requestId: message.requestId };
            case 'processShouldCollapse':
                var collapse = adguard.webRequestService.processShouldCollapse(sender.tab, message.elementUrl, message.documentUrl, message.requestType);
                return { collapse: collapse, requestId: message.requestId };
            case 'processShouldCollapseMany':
                var requests = adguard.webRequestService.processShouldCollapseMany(sender.tab, message.documentUrl, message.requests);
                return { requests: requests };
            case 'onOpenFilteringLogPage':
                adguard.filteringLog.onOpenFilteringLogPage();
                break;
            case 'onCloseFilteringLogPage':
                adguard.filteringLog.onCloseFilteringLogPage();
                break;
            case 'reloadTabById':
                if (!message.preserveLogEnabled) {
                    adguard.filteringLog.clearEventsByTabId(message.tabId);
                }
                adguard.tabs.reload(message.tabId);
                break;
            case 'clearEventsByTabId':
                adguard.filteringLog.clearEventsByTabId(message.tabId);
                break;
            case 'getTabFrameInfoById':
                if (message.tabId) {
                    var frameInfo = adguard.frames.getFrameInfo({ tabId: message.tabId });
                    return { frameInfo: frameInfo };
                } else {
                    adguard.tabs.getActive(function (tab) {
                        var frameInfo = adguard.frames.getFrameInfo(tab);
                        callback({ frameInfo: frameInfo });
                    });
                    return true; // Async
                }
            case 'getFilteringInfoByTabId':
                var filteringInfo = adguard.filteringLog.getFilteringInfoByTabId(message.tabId);
                return { filteringInfo: filteringInfo };
            case 'synchronizeOpenTabs':
                adguard.filteringLog.synchronizeOpenTabs(function (tabs) {
                    callback({ tabs: tabs });
                });
                return true; // Async
            case 'addFilterSubscription': {
                const { url, title } = message;
                const hashOptions = {
                    action: 'add_filter_subscription',
                    title,
                    url,
                };
                adguard.ui.openSettingsTab('antibanner0', hashOptions);
                break;
            }
            case 'showAlertMessagePopup':
                adguard.ui.showAlertMessagePopup(message.title, message.text);
                break;
            // Popup methods
            case 'addWhiteListDomainPopup':
                adguard.tabs.getActive(function (tab) {
                    adguard.ui.whiteListTab(tab);
                });
                break;
            case 'removeWhiteListDomainPopup':
                adguard.tabs.getActive(function (tab) {
                    adguard.ui.unWhiteListTab(tab);
                });
                break;
            case 'changeApplicationFilteringDisabled':
                adguard.ui.changeApplicationFilteringDisabled(message.disabled);
                break;
            case 'openSiteReportTab':
                adguard.ui.openSiteReportTab(message.url);
                break;
            case 'openAbuseTab':
                adguard.ui.openAbuseTab(message.url);
                break;
            case 'openSettingsTab':
                adguard.ui.openSettingsTab();
                break;
            case 'openAssistant':
                adguard.ui.openAssistant();
                break;
            case 'getTabInfoForPopup':
                adguard.tabs.getActive((tab) => {
                    const frameInfo = adguard.frames.getFrameInfo(tab);
                    callback({
                        frameInfo,
                        options: {
                            showStatsSupported: true,
                            isFirefoxBrowser: adguard.utils.browser.isFirefoxBrowser(),
                            showInfoAboutFullVersion: adguard.settings.isShowInfoAboutAdguardFullVersion(),
                            isMacOs: adguard.utils.browser.isMacOs(),
                            isEdgeBrowser: adguard.utils.browser.isEdgeBrowser()
                                || adguard.utils.browser.isEdgeChromiumBrowser(),
                            notification: adguard.notifications.getCurrentNotification(frameInfo),
                            isDisableShowAdguardPromoInfo: adguard.settings.isDisableShowAdguardPromoInfo(),
                        },
                    });
                });
                return true; // Async
            case 'setNotificationViewed':
                adguard.notifications.setNotificationViewed(message.withDelay);
                break;
            case 'getStatisticsData':
                // There can't be data till localstorage is initialized
                if (!adguard.localStorage.isInitialized()) {
                    return {};
                }
                callback({
                    stats: adguard.pageStats.getStatisticsData(),
                });
                return true;
            case 'resizePanelPopup':
                adguard.browserAction.resize(message.width, message.height);
                break;
            case 'closePanelPopup':
                adguard.browserAction.close();
                break;
            case 'sendFeedback':
                adguard.backend.sendUrlReport(message.url, message.topic, message.comment);
                break;
            case 'saveCssHitStats':
                processSaveCssHitStats(sender.tab, message.stats);
                break;
            case 'loadSettingsJson': {
                const appVersion = adguard.app.getVersion();
                const settingsCb = (json) => {
                    callback({ content: json, appVersion });
                };
                adguard.sync.settingsProvider.loadSettingsBackup(settingsCb);
                return true; // Async
            }
            case 'applySettingsJson':
                adguard.sync.settingsProvider.applySettingsBackup(message.json);
                break;
            case 'disableGetPremiumNotification':
                adguard.settings.disableShowAdguardPromoInfo();
                break;
            default:
                // Unhandled message
                return true;
        }
    }

    // Add event listener from content-script messages
    adguard.runtime.onMessage.addListener(handleMessage);

    /**
     * There is no messaging in Safari popover context,
     * so we have to expose this method to keep the message-like style that is used in other browsers for communication between popup and background page.
     */
    adguard.runtime.onMessageHandler = handleMessage;

})(adguard);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/* global adguard */

adguard.stealthService = (function (adguard) {

    'use strict';

    /**
     * Search engines regexps
     *
     * @type {Array.<string>}
     */
    const SEARCH_ENGINES = [
        /https?:\/\/(www\.)?google\./i,
        /https?:\/\/(www\.)?yandex\./i,
        /https?:\/\/(www\.)?bing\./i,
        /https?:\/\/(www\.)?yahoo\./i,
        /https?:\/\/(www\.)?go\.mail\.ru/i,
        /https?:\/\/(www\.)?ask\.com/i,
        /https?:\/\/(www\.)?aol\.com/i,
        /https?:\/\/(www\.)?baidu\.com/i,
        /https?:\/\/(www\.)?seznam\.cz/i
    ];

    /**
     * Headers
     */
    const HEADERS = {
        REFERRER: 'Referer',
        X_CLIENT_DATA: 'X-Client-Data',
        DO_NOT_TRACK: 'DNT',
    };

    /**
     * Header values
     */
    const HEADER_VALUES = {
        DO_NOT_TRACK: {
            name: 'DNT',
            value: '1'
        },
    };

    const STEALTH_ACTIONS = {
        HIDE_REFERRER: 1 << 0,
        HIDE_SEARCH_QUERIES: 1 << 1,
        BLOCK_CHROME_CLIENT_DATA: 1 << 2,
        SEND_DO_NOT_TRACK: 1 << 3,
        STRIPPED_TRACKING_URL: 1 << 4,
        FIRST_PARTY_COOKIES: 1 << 5,
        THIRD_PARTY_COOKIES: 1 << 6,
    };

    /**
     * Is url search engine
     *
     * @param {string} url
     * @returns {boolean}
     */
    const isSearchEngine = function (url) {
        if (!url) {
            return false;
        }

        for (let i = 0; i < SEARCH_ENGINES.length; i++) {
            if (SEARCH_ENGINES[i].test(url)) {
                return true;
            }
        }

        return false;
    };

    /**
     * Crops url path
     * @param url URL
     * @return {string} URL without path
     */
    const getHiddenRefHeaderUrl = (url) => {
        const host = adguard.utils.url.getHost(url);
        return (url.indexOf('https') === 0 ? 'https://' : 'http://') + host + '/';
    };

    /**
     * Generates rule removing cookies
     *
     * @param {number} maxAgeMinutes Cookie maxAge in minutes
     * @param {number} stealthActions stealth actions to add to the rule
     */
    const generateRemoveRule = function (maxAgeMinutes, stealthActions) {
        const maxAgeOption = maxAgeMinutes > 0 ? `;maxAge=${maxAgeMinutes * 60}` : '';
        const rule = new adguard.rules.UrlFilterRule(`$cookie=/.+/${maxAgeOption}`);
        rule.addStealthActions(stealthActions);
        return rule;
    };

    /**
     * Checks if stealth mode is disabled
     * @returns {boolean}
     */
    const isStealthModeDisabled = () => {
        return adguard.settings.getProperty(adguard.settings.DISABLE_STEALTH_MODE)
            || adguard.settings.isFilteringDisabled();
    };

    /**
     * Returns stealth setting current value, considering if global stealth setting is enabled
     * @param stealthSettingName
     * @returns {boolean}
     */
    const getStealthSettingValue = (stealthSettingName) => {
        if (isStealthModeDisabled()) {
            return false;
        }
        return adguard.settings.getProperty(stealthSettingName);
    };

    /**
     * Processes request headers
     *
     * @param {string} requestId Request identifier
     * @param {Array} requestHeaders Request headers
     * @return {boolean} True if headers were modified
     */
    const processRequestHeaders = function (requestId, requestHeaders) {
        // If stealth mode is disabled do not process headers
        if (isStealthModeDisabled()) {
            return false;
        }

        const context = adguard.requestContextStorage.get(requestId);
        if (!context) {
            return false;
        }

        const tab = context.tab;
        const requestUrl = context.requestUrl;
        const requestType = context.requestType;

        adguard.console.debug('Stealth service processing request headers for {0}', requestUrl);

        if (adguard.frames.shouldStopRequestProcess(tab)) {
            adguard.console.debug('Tab whitelisted or protection disabled');
            return false;
        }

        let mainFrameUrl = adguard.frames.getMainFrameUrl(tab);
        if (!mainFrameUrl) {
            // frame wasn't recorded in onBeforeRequest event
            adguard.console.debug('Frame was not recorded in onBeforeRequest event');
            return false;
        }

        const whiteListRule = adguard.requestFilter.findWhiteListRule(requestUrl, mainFrameUrl, requestType);
        if (whiteListRule && whiteListRule.isDocumentWhiteList()) {
            adguard.console.debug('Whitelist rule found');
            return false;
        }

        const stealthWhiteListRule = findStealthWhitelistRule(requestUrl, mainFrameUrl, requestType);
        if (stealthWhiteListRule) {
            adguard.console.debug('Whitelist stealth rule found');
            adguard.requestContextStorage.update(requestId, { requestRule: stealthWhiteListRule });
            return false;
        }

        let stealthActions = 0;

        // Remove referrer for third-party requests
        const hideReferrer = getStealthSettingValue(adguard.settings.HIDE_REFERRER);
        if (hideReferrer) {
            adguard.console.debug('Remove referrer for third-party requests');
            const refHeader = adguard.utils.browser.findHeaderByName(requestHeaders, HEADERS.REFERRER);
            if (refHeader &&
                adguard.utils.url.isThirdPartyRequest(requestUrl, refHeader.value)) {

                refHeader.value = getHiddenRefHeaderUrl(requestUrl);
                stealthActions |= STEALTH_ACTIONS.HIDE_REFERRER;
            }
        }

        // Hide referrer in case of search engine is referrer
        const isMainFrame = requestType === adguard.RequestTypes.DOCUMENT;
        const hideSearchQueries = getStealthSettingValue(adguard.settings.HIDE_SEARCH_QUERIES);
        if (hideSearchQueries && isMainFrame) {
            adguard.console.debug('Hide referrer in case of search engine is referrer');
            const refHeader = adguard.utils.browser.findHeaderByName(requestHeaders, HEADERS.REFERRER);
            if (refHeader &&
                isSearchEngine(refHeader.value) &&
                adguard.utils.url.isThirdPartyRequest(requestUrl, refHeader.value)) {

                refHeader.value = getHiddenRefHeaderUrl(requestUrl);
                stealthActions |= STEALTH_ACTIONS.HIDE_SEARCH_QUERIES;
            }
        }

        // Remove X-Client-Data header
        const blockChromeClientData = getStealthSettingValue(adguard.settings.BLOCK_CHROME_CLIENT_DATA);
        if (blockChromeClientData) {
            adguard.console.debug('Remove X-Client-Data header');
            if (adguard.utils.browser.removeHeader(requestHeaders, HEADERS.X_CLIENT_DATA)) {
                stealthActions |= STEALTH_ACTIONS.BLOCK_CHROME_CLIENT_DATA;
            }
        }

        // Adding Do-Not-Track (DNT) header
        const sendDoNotTrack = getStealthSettingValue(adguard.settings.SEND_DO_NOT_TRACK);
        if (sendDoNotTrack) {
            adguard.console.debug('Adding Do-Not-Track (DNT) header');
            requestHeaders.push(HEADER_VALUES.DO_NOT_TRACK);
            stealthActions |= STEALTH_ACTIONS.SEND_DO_NOT_TRACK;
        }

        if (stealthActions > 0) {
            adguard.requestContextStorage.update(requestId, { stealthActions });
        }

        adguard.console.debug('Stealth service processed request headers for {0}', requestUrl);

        return stealthActions > 0;
    };

    /**
     * Returns synthetic set of rules matching the specified request
     *
     * @param requestUrl
     * @param referrerUrl
     * @param requestType
     */
    const getCookieRules = function (requestUrl, referrerUrl, requestType) {
        // if stealth mode is disabled
        if (isStealthModeDisabled()) {
            return null;
        }

        const whiteListRule = adguard.requestFilter.findWhiteListRule(requestUrl, referrerUrl, requestType);
        if (whiteListRule && whiteListRule.isDocumentWhiteList()) {
            adguard.console.debug('Whitelist rule found');
            return false;
        }

        // If stealth is whitelisted
        const stealthWhiteListRule = findStealthWhitelistRule(requestUrl, referrerUrl, requestType);
        if (stealthWhiteListRule) {
            adguard.console.debug('Whitelist stealth rule found');
            return null;
        }

        const result = [];

        adguard.console.debug('Stealth service lookup cookie rules for {0}', requestUrl);

        // Remove cookie header for first-party requests
        const blockCookies = getStealthSettingValue(adguard.settings.SELF_DESTRUCT_FIRST_PARTY_COOKIES);
        if (blockCookies) {
            result.push(generateRemoveRule(adguard.settings.getProperty(adguard.settings.SELF_DESTRUCT_FIRST_PARTY_COOKIES_TIME), STEALTH_ACTIONS.FIRST_PARTY_COOKIES));
        }

        const blockThirdPartyCookies = getStealthSettingValue(adguard.settings.SELF_DESTRUCT_THIRD_PARTY_COOKIES);
        if (!blockThirdPartyCookies) {
            adguard.console.debug('Stealth service processed lookup cookie rules for {0}', requestUrl);
            return result;
        }

        // Marks requests without referrer as first-party.
        // It's important to prevent removing google auth cookies. (for requests in background tab)
        const thirdParty = referrerUrl && adguard.utils.url.isThirdPartyRequest(requestUrl, referrerUrl);
        const isMainFrame = requestType === adguard.RequestTypes.DOCUMENT;

        // Remove cookie header for third-party requests
        if (thirdParty && !isMainFrame) {
            result.push(generateRemoveRule(adguard.settings.getProperty(adguard.settings.SELF_DESTRUCT_THIRD_PARTY_COOKIES_TIME), STEALTH_ACTIONS.THIRD_PARTY_COOKIES));
        }

        adguard.console.debug('Stealth service processed lookup cookie rules for {0}', requestUrl);

        return result;
    };

    /**
     * Checks if tab is whitelisted for stealth
     *
     * @param requestUrl
     * @param referrerUrl
     * @param requestType
     * @returns whitelist rule if found
     */
    const findStealthWhitelistRule = function (requestUrl, referrerUrl, requestType) {
        const stealthDocumentWhitelistRule = adguard.requestFilter.findStealthWhiteListRule(referrerUrl, referrerUrl, requestType);
        if (stealthDocumentWhitelistRule && stealthDocumentWhitelistRule.isDocumentWhiteList()) {
            adguard.console.debug('Stealth document whitelist rule found.');
            return stealthDocumentWhitelistRule;
        }

        const stealthWhiteListRule = adguard.requestFilter.findStealthWhiteListRule(requestUrl, referrerUrl, requestType);
        if (stealthWhiteListRule) {
            adguard.console.debug('Stealth whitelist rule found.');
            return stealthWhiteListRule;
        }

        return null;
    };

    /**
     * Updates browser privacy.network settings depending on blocking WebRTC or not
     */
    const handleBlockWebRTC = () => {
        // Edge doesn't support privacy api
        // https://developer.mozilla.org/en-US/docs/Mozilla/Add-ons/WebExtensions/API/privacy
        if (!browser.privacy) {
            return;
        }

        const resetLastError = () => {
            const ex = browser.runtime.lastError;
            if (ex) {
                adguard.console.error('Error updating privacy.network settings: {0}', ex);
            }
        };

        const webRTCDisabled = getStealthSettingValue(adguard.settings.BLOCK_WEBRTC);

        // Deprecated since Chrome 48
        if (typeof browser.privacy.network.webRTCMultipleRoutesEnabled === 'object') {
            if (webRTCDisabled) {
                browser.privacy.network.webRTCMultipleRoutesEnabled.set({
                    value: false,
                    scope: 'regular',
                }, resetLastError);
            } else {
                browser.privacy.network.webRTCMultipleRoutesEnabled.clear({
                    scope: 'regular',
                }, resetLastError);
            }
        }

        // Since chromium 48
        if (typeof browser.privacy.network.webRTCIPHandlingPolicy === 'object') {
            if (webRTCDisabled) {
                browser.privacy.network.webRTCIPHandlingPolicy.set({
                    value: 'disable_non_proxied_udp',
                    scope: 'regular',
                }, resetLastError);
            } else {
                browser.privacy.network.webRTCIPHandlingPolicy.clear({
                    scope: 'regular',
                }, resetLastError);
            }
        }

        if (typeof browser.privacy.network.peerConnectionEnabled === 'object') {
            if (webRTCDisabled) {
                browser.privacy.network.peerConnectionEnabled.set({
                    value: false,
                    scope: 'regular',
                }, resetLastError);
            } else {
                browser.privacy.network.peerConnectionEnabled.clear({
                    scope: 'regular',
                }, resetLastError);
            }
        }
    };

    /**
     * Strips out the tracking codes/parameters from a URL and return the cleansed URL
     *
     * @param requestId
     */
    const removeTrackersFromUrl = (requestId) => {

        if (!getStealthSettingValue(adguard.settings.STRIP_TRACKING_PARAMETERS)) {
            return null;
        }

        const context = adguard.requestContextStorage.get(requestId);
        if (!context || context.requestType !== adguard.RequestTypes.DOCUMENT) {
            return null;
        }

        const { requestUrl, requestType, tab } = context;

        adguard.console.debug('Stealth service processing request url for {0}', requestUrl);

        if (adguard.frames.shouldStopRequestProcess(tab)) {
            adguard.console.debug('Tab whitelisted or protection disabled');
            return null;
        }

        const mainFrameUrl = adguard.frames.getMainFrameUrl(tab);
        if (!mainFrameUrl) {
            // frame wasn't recorded in onBeforeRequest event
            adguard.console.debug('Frame was not recorded in onBeforeRequest event');
            return null;
        }

        const whiteListRule = adguard.requestFilter.findWhiteListRule(requestUrl, mainFrameUrl, requestType);
        if (whiteListRule && whiteListRule.isDocumentWhiteList()) {
            adguard.console.debug('Whitelist rule found');
            return null;
        }

        const stealthWhiteListRule = findStealthWhitelistRule(requestUrl, mainFrameUrl, requestType);
        if (stealthWhiteListRule) {
            adguard.console.debug('Whitelist stealth rule found');
            adguard.filteringLog.addHttpRequestEvent(tab, requestUrl, mainFrameUrl, requestType, stealthWhiteListRule);
            return null;
        }

        const urlPieces = requestUrl.split('?');

        // If no params, nothing to modify
        if (urlPieces.length === 1) {
            return null;
        }

        const trackingParameters = adguard.settings.getProperty(adguard.settings.TRACKING_PARAMETERS)
            .trim()
            .split(',')
            .map(x => x.replace('=', '').replace(/\*/g, '[^&#=]*').trim())
            .filter(x => x);
        const trackingParametersRegExp = new RegExp("((^|&)(" + trackingParameters.join('|') + ")=[^&#]*)", "ig");
        urlPieces[1] = urlPieces[1].replace(trackingParametersRegExp, '');

        // If we've collapsed the URL to the point where there's an '&' against the '?'
        // then we need to get rid of that.
        while (urlPieces[1].charAt(0) === '&') {
            urlPieces[1] = urlPieces[1].substr(1);
        }

        const result = urlPieces[1] ? urlPieces.join('?') : urlPieces[0];

        if (result !== requestUrl) {
            adguard.console.debug('Stealth stripped tracking parameters for url: ' + requestUrl);
            adguard.filteringLog.bindStealthActionsToHttpRequestEvent(tab, STEALTH_ACTIONS.STRIPPED_TRACKING_URL, context.eventId);

            return result;
        }

        return null;
    };

    const handleWebRTCEnabling = () => {
        adguard.utils.browser.containsPermissions(['privacy'])
            .then(result => {
                if (result) {
                    return true;
                }
                return adguard.utils.browser.requestPermissions(['privacy']);
            })
            .then(granted => {
                if (granted) {
                    handleBlockWebRTC();
                } else {
                    // If privacy permission is not granted set block webrtc value to false
                    adguard.settings.setProperty(adguard.settings.BLOCK_WEBRTC, false);
                }
            })
            .catch(error => {
                adguard.console.error(error);
            });
    };

    const handleWebRTCDisabling = () => {
        adguard.utils.browser.containsPermissions(['privacy'])
            .then(result => {
                if (result) {
                    handleBlockWebRTC();
                    return adguard.utils.browser.removePermission(['privacy']);
                }
                return true;
            });
    };

    const handlePrivacyPermissions = () => {
        const webRTCEnabled = getStealthSettingValue(adguard.settings.BLOCK_WEBRTC);
        if (webRTCEnabled) {
            handleWebRTCEnabling();
        } else {
            handleWebRTCDisabling();
        }
    };

    /**
     * Browsers api doesn't allow to get optional permissions
     * via chrome.permissions.getAll and we can't check privacy
     * availability via `browser.privacy !== undefined` till permission
     * isn't enabled by the user
     *
     * That's why use edge browser detection
     * Privacy methods are not working at all in the Edge
     * @returns {boolean}
     */
    const canBlockWebRTC = () => {
        return !adguard.utils.browser.isEdgeBrowser();
    };

    /**
     * We handle privacy permission only for chromium browsers
     * In the Firefox privacy permission is available by default
     * because they can't be optional there
     * @returns {boolean}
     */
    const shouldHandlePrivacyPermission = () => {
        return adguard.utils.browser.isChromium();
    };

    if (canBlockWebRTC()) {
        adguard.settings.onUpdated.addListener(function (setting) {
            if (setting === adguard.settings.BLOCK_WEBRTC
                || setting === adguard.settings.DISABLE_STEALTH_MODE) {
                if (shouldHandlePrivacyPermission()) {
                    handlePrivacyPermissions();
                } else {
                    handleBlockWebRTC();
                }
            }
        });

        adguard.listeners.addListener(function (event) {
            switch (event) {
                case adguard.listeners.APPLICATION_INITIALIZED:
                    adguard.utils.browser.containsPermissions(['privacy'])
                        .then(result => {
                            if (result) {
                                handleBlockWebRTC();
                            }
                        });
                    break;
                default:
                    break;
            }
        });
    }


    return {
        processRequestHeaders: processRequestHeaders,
        getCookieRules: getCookieRules,
        removeTrackersFromUrl: removeTrackersFromUrl,
        canBlockWebRTC: canBlockWebRTC,
        STEALTH_ACTIONS,
    };

})(adguard);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

(function (adguard) {
    'use strict';

    const CSP_HEADER_NAME = 'Content-Security-Policy';

    /**
     * In the case of the tabs.insertCSS API support we're trying to collapse a blocked element from the background page.
     * In order to do it we need to have a mapping requestType<->tagNames.
     */
    const REQUEST_TYPE_COLLAPSE_TAG_NAMES = {
        [adguard.RequestTypes.SUBDOCUMENT]: ['frame', 'iframe'],
        [adguard.RequestTypes.IMAGE]: ['img'],
    };

    /**
     * In the newer versions of Firefox and Chromium we're able to inject CSS and scripts
     * using a better approach -- `browser.tabs.insertCSS` and `browser.tabs.executeScript`
     * instead of the traditional one (messaging to the content script).
     */
    const shouldUseInsertCSSAndExecuteScript = adguard.prefs.features.canUseInsertCSSAndExecuteScript;

    /**
     * Retrieve referrer url from request details.
     * Extract referrer by priority:
     * 1. referrerUrl in requestDetails
     * 2. url of frame where request was created
     * 3. url of main frame
     *
     * @param requestDetails
     * @returns {*|Frame}
     */
    function getReferrerUrl(requestDetails) {
        return requestDetails.referrerUrl
            || adguard.frames.getFrameUrl(requestDetails.tab, requestDetails.requestFrameId)
            || adguard.frames.getMainFrameUrl(requestDetails.tab);
    }

    /**
     * Process request
     *
     * @param {RequestDetails} requestDetails
     * @returns {boolean|{Object}} False if request must be blocked, object if url was redirected
     */
    function onBeforeRequest(requestDetails) {
        if (adguard.app.isOwnRequest(requestDetails.referrerUrl)) {
            return;
        }

        const {
            tab,
            requestId,
            originUrl,
            requestType,
            frameId,
            requestFrameId = 0,
        } = requestDetails;

        const { tabId } = tab;
        let { requestUrl } = requestDetails;

        if (requestType === adguard.RequestTypes.DOCUMENT || requestType === adguard.RequestTypes.SUBDOCUMENT) {
            adguard.frames.recordFrame(tab, frameId, requestUrl, requestType);
        }

        if (requestType === adguard.RequestTypes.DOCUMENT) {
            // Reset tab button state
            adguard.listeners.notifyListeners(adguard.listeners.UPDATE_TAB_BUTTON_STATE, tab, true);

            // Record request context for the main frame
            adguard.requestContextStorage.record(requestId, requestUrl, requestUrl, originUrl, requestType, tab);

            // Strip tracking parameters
            const cleansedUrl = adguard.stealthService.removeTrackersFromUrl(requestId);
            if (cleansedUrl) {
                return { redirectUrl: cleansedUrl };
            }

            /**
             * Just to remember!
             * In the case of the "about:newtab" pages we don't receive onResponseReceived event for the main_frame
             * Also if chrome://newtab is overwritten, we won't receive any webRequest events for the main_frame
             * Unfortunately, we can't do anything in this case and just must remember about it
             */

            /**
             * Binds rule to the main_frame request
             * In integration mode, rule from the headers will override this value
             */
            const tabRequestRule = adguard.frames.getFrameWhiteListRule(tab);
            if (tabRequestRule) {
                adguard.requestContextStorage.update(requestId, { requestRule: tabRequestRule });
            }
        }

        if (!adguard.utils.url.isHttpOrWsRequest(requestUrl)) {
            // Do not mess with other extensions
            return;
        }

        const referrerUrl = getReferrerUrl(requestDetails);

        // truncate too long urls
        // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1493
        const MAX_URL_LENGTH = 1024 * 16;
        if (requestUrl.length > MAX_URL_LENGTH) {
            requestUrl = requestUrl.slice(0, MAX_URL_LENGTH);
        }

        // Record request for other types
        adguard.requestContextStorage.record(requestId, requestUrl, referrerUrl, originUrl, requestType, tab);

        // Strip tracking parameters
        const cleansedUrl = adguard.stealthService.removeTrackersFromUrl(requestId);
        if (cleansedUrl) {
            return { redirectUrl: cleansedUrl };
        }

        let requestRule = adguard.webRequestService.getRuleForRequest(
            tab,
            requestUrl,
            referrerUrl,
            requestType
        );

        requestRule = adguard.webRequestService.postProcessRequest(
            tab,
            requestUrl,
            referrerUrl,
            requestType,
            requestRule
        );

        if (requestRule) {
            adguard.requestContextStorage.update(requestId, { requestRule });
        }

        const response = adguard.webRequestService.getBlockedResponseByRule(
            requestRule,
            requestType,
            requestUrl
        );

        if (requestRule
            && !requestRule.whiteListRule
            && requestRule.isBlockPopups()
            && requestType === adguard.RequestTypes.DOCUMENT) {
            const isNewTab = adguard.tabs.isNewPopupTab(tabId);
            if (isNewTab) {
                adguard.tabs.remove(tabId);
                return { cancel: true };
            }
        }

        if (response && response.documentBlockedPage) {
            // Here we do not use redirectUrl because it is not working in firefox without specifying it
            // as the web_accessible_resources.
            adguard.rules.documentFilterService.showDocumentBlockPage(tabId, response.documentBlockedPage);
            return { cancel: true };
        }

        if (response && response.cancel) {
            collapseElement(tabId, requestFrameId, requestUrl, referrerUrl, requestType);
        }

        return response;
    }

    /**
     * Tries to collapse a blocked element using tabs.insertCSS.
     *
     * This method of collapsing has numerous advantages over the traditional one.
     * First of all, it prevents blocked elements flickering as it occurs earlier.
     * Second, it is harder to detect as there's no custom <style> node required.
     *
     * However, we're still keeping the old approach intact - we have not enough information
     * here to properly collapse elements that use relative URLs (<img src='../path_to_element'>).
     *
     * @param {number} tabId Tab id
     * @param {number} requestFrameId Id of a frame request was sent from
     * @param {string} requestUrl Request URL
     * @param {string} referrerUrl Referrer URL
     * @param {string} requestType A member of adguard.RequestTypes
     */
    function collapseElement(tabId, requestFrameId, requestUrl, referrerUrl, requestType) {
        if (!shouldUseInsertCSSAndExecuteScript) {
            return;
        }

        const tagNames = REQUEST_TYPE_COLLAPSE_TAG_NAMES[requestType];
        if (!tagNames) {
            // Collapsing is not supported for this request type
            return;
        }

        // Collapsing is not supported for the requests which happen out of the tabs, e.g. other extensions
        if (tabId === -1) {
            return;
        }

        // Strip the protocol and host name (for first-party requests) from the selector
        const thirdParty = adguard.utils.url.isThirdPartyRequest(requestUrl, referrerUrl);
        let srcUrlStartIndex = requestUrl.indexOf('//');
        if (!thirdParty) {
            srcUrlStartIndex = requestUrl.indexOf('/', srcUrlStartIndex + 2);
        }
        const srcUrl = requestUrl.substring(srcUrlStartIndex);

        const collapseStyle = '{ display: none!important; visibility: hidden!important; height: 0px!important; min-height: 0px!important; }';
        let css = '';
        let iTagNames = tagNames.length;

        while (iTagNames--) {
            css += `${tagNames[iTagNames]}[src$="${srcUrl}"] ${collapseStyle}\n`;
        }

        adguard.tabs.insertCssCode(tabId, requestFrameId, css);
    }

    /**
     * Called before request is sent to the remote endpoint.
     * This method is used to modify headers for stealth service
     * and also to record referrer header in frame data.
     *
     * @param requestDetails Request details
     * @returns {*} headers to send
     */
    function onBeforeSendHeaders(requestDetails) {
        const {
            tab,
            requestId,
            requestType,
            requestHeaders,
        } = requestDetails;

        adguard.requestContextStorage.update(requestId, { requestHeaders });

        let requestHeadersModified = false;

        if (requestType === adguard.RequestTypes.DOCUMENT) {
            // Save ref header
            const refHeader = adguard.utils.browser.findHeaderByName(requestHeaders, 'Referer');
            if (refHeader) {
                adguard.frames.recordFrameReferrerHeader(tab, refHeader.value);
            }
        }

        if (adguard.cookieFiltering.filterRequestHeaders(requestId, requestHeaders)) {
            requestHeadersModified = true;
        }

        if (adguard.stealthService.processRequestHeaders(requestId, requestHeaders)) {
            requestHeadersModified = true;
        }

        if (requestHeadersModified) {
            adguard.requestContextStorage.update(requestId, { modifiedRequestHeaders: requestHeaders });
            return { requestHeaders };
        }

        return {};
    }

    /**
     * On headers received callback function.
     * We do check request for safebrowsing
     * and check if websocket connections should be blocked.
     *
     * @param requestDetails Request details
     * @returns {{responseHeaders: *}} Headers to send
     */
    function onHeadersReceived(requestDetails) {
        const { tab } = requestDetails;
        const { requestUrl } = requestDetails;
        let responseHeaders = requestDetails.responseHeaders || [];
        const { requestType } = requestDetails;
        const referrerUrl = getReferrerUrl(requestDetails);
        const { requestId } = requestDetails;
        const { statusCode } = requestDetails;
        const { method } = requestDetails;

        adguard.requestContextStorage.update(requestId, { responseHeaders });

        adguard.webRequestService.processRequestResponse(tab, requestUrl, referrerUrl, requestType, responseHeaders);

        // Safebrowsing check
        if (requestType === adguard.RequestTypes.DOCUMENT
            // Don't apply safebrowsing filter in case of redirect
            // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/995
            && statusCode !== 301 && statusCode !== 302) {
            filterSafebrowsing(tab, requestUrl);
        }

        if (adguard.contentFiltering) {
            const contentType = adguard.utils.browser.getHeaderValueByName(responseHeaders, 'content-type');
            adguard.contentFiltering.apply(tab, requestUrl, referrerUrl, requestType, requestId, statusCode, method, contentType);
        }

        let responseHeadersModified = false;

        if (requestType === adguard.RequestTypes.DOCUMENT || requestType === adguard.RequestTypes.SUBDOCUMENT) {
            const cspHeaders = getCSPHeaders(requestDetails);
            if (cspHeaders && cspHeaders.length > 0) {
                responseHeaders = responseHeaders.concat(cspHeaders);
                responseHeadersModified = true;
            }
        }

        if (adguard.cookieFiltering.filterResponseHeaders(requestId, responseHeaders)) {
            responseHeadersModified = true;
        }

        if (responseHeadersModified) {
            adguard.requestContextStorage.update(requestId, { modifiedResponseHeaders: responseHeaders });
            return { responseHeaders };
        }
    }

    /**
     * Modify CSP header to block WebSocket, prohibit data: and blob: frames and WebWorkers
     * @param requestDetails
     * @returns {{responseHeaders: *}} CSP headers
     */
    function getCSPHeaders(requestDetails) {
        // Please note, that we do not modify response headers in Edge before Creators update:
        // https://github.com/AdguardTeam/AdguardBrowserExtension/issues/401
        // https://developer.microsoft.com/en-us/microsoft-edge/platform/issues/8796739/
        if (adguard.utils.browser.isEdgeBeforeCreatorsUpdate()) {
            return;
        }

        const { tab } = requestDetails;
        const { requestId } = requestDetails;
        const { requestUrl } = requestDetails;
        const { requestType } = requestDetails;
        const frameUrl = adguard.frames.getFrameUrl(tab, requestDetails.frameId);

        const cspHeaders = [];

        /**
         * Retrieve $CSP rules specific for the request
         * https://github.com/adguardteam/adguardbrowserextension/issues/685
         */
        const cspRules = adguard.webRequestService.getCspRules(tab, requestUrl, frameUrl, requestType);
        if (cspRules) {
            for (let i = 0; i < cspRules.length; i += 1) {
                const rule = cspRules[i];
                // Don't forget: getCspRules returns all $csp rules, we must directly check that the rule is blocking.
                if (adguard.webRequestService.isRequestBlockedByRule(rule)) {
                    cspHeaders.push({
                        name: CSP_HEADER_NAME,
                        value: rule.cspDirective,
                    });
                }
            }
            if (cspRules.length > 0) {
                adguard.requestContextStorage.update(requestId, { cspRules });
            }
        }

        /**
         * Websocket connection is blocked by connect-src directive
         * https://www.w3.org/TR/CSP2/#directive-connect-src
         *
         * Web Workers is blocked by child-src directive
         * https://www.w3.org/TR/CSP2/#directive-child-src
         * https://www.w3.org/TR/CSP3/#directive-worker-src
         * We have to use child-src as fallback for worker-src, because it isn't supported
         * https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/worker-src#Browser_compatibility
         *
         * We also need the frame-src restriction since CSPs are not inherited from the parent for documents with data: and blob: URLs
         * https://bugs.chromium.org/p/chromium/issues/detail?id=513860
         */
        return cspHeaders;
    }

    /**
     * Safebrowsing check
     *
     * @param tab
     * @param mainFrameUrl
     */
    function filterSafebrowsing(tab, mainFrameUrl) {
        if (adguard.frames.isTabProtectionDisabled(tab)
            || adguard.frames.isTabWhiteListedForSafebrowsing(tab)) {
            return;
        }

        const referrerUrl = adguard.utils.browser.getSafebrowsingBackUrl(tab);
        const incognitoTab = adguard.frames.isIncognitoTab(tab);

        adguard.safebrowsing.checkSafebrowsingFilter(mainFrameUrl, referrerUrl, (safebrowsingUrl) => {
            // Chrome doesn't allow open extension url in incognito mode
            // So close current tab and open new
            if (adguard.utils.browser.isChromium() && incognitoTab) {
                // Closing tab before opening a new one may lead to browser crash (Chromium)
                adguard.ui.openTab(safebrowsingUrl, {}, () => {
                    adguard.tabs.remove(tab.tabId);
                });
            } else {
                adguard.tabs.reload(tab.tabId, safebrowsingUrl);
            }
        });
    }

    /**
     * Add listeners described above.
     */
    adguard.webRequest.onBeforeRequest.addListener(onBeforeRequest, ['<all_urls>']);
    adguard.webRequest.onBeforeSendHeaders.addListener(onBeforeSendHeaders, ['<all_urls>']);
    adguard.webRequest.onHeadersReceived.addListener(onHeadersReceived, ['<all_urls>']);

    /**
     * If page uses service worker then it can do not fire main DOCUMENT request, that's why we check
     * frame data before scripts are injected
     * This listener should be added before any other listener of onCommitted event
     * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1459
     * @param details
     */
    const onCommittedCheckFrameUrl = (details) => {
        const {
            tab,
            requestType,
            frameId,
            requestUrl,
        } = details;

        if (requestType !== adguard.RequestTypes.DOCUMENT
            || tab.tabId === adguard.BACKGROUND_TAB_ID) {
            return;
        }

        adguard.frames.checkAndRecordMainFrame(tab, frameId, requestUrl, requestType);
    };

    adguard.webNavigation.onCommitted.addListener(onCommittedCheckFrameUrl);

    let handlerBehaviorTimeout = null;
    adguard.listeners.addListener((event) => {
        switch (event) {
            case adguard.listeners.ADD_RULES:
            case adguard.listeners.REMOVE_RULE:
            case adguard.listeners.UPDATE_FILTER_RULES:
            case adguard.listeners.UPDATE_WHITELIST_FILTER_RULES:
            case adguard.listeners.FILTER_ENABLE_DISABLE:
                if (handlerBehaviorTimeout !== null) {
                    clearTimeout(handlerBehaviorTimeout);
                }
                handlerBehaviorTimeout = setTimeout(() => {
                    handlerBehaviorTimeout = null;
                    adguard.webRequest.handlerBehaviorChanged();
                }, 3000);
        }
    });

    if (shouldUseInsertCSSAndExecuteScript) {
        /**
         * Applying CSS/JS rules from the background page.
         * This function implements the algorithm suggested here: https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1029
         * For faster script injection, we prepare scriptText onHeadersReceived event (we can't use onBeforeRequest
         * event because we can't detect adguard application headers early in order to know should extension inject scripts or no),
         * save it and try to inject twice:
         * first time onResponseStarted event - this event fires early, but is not reliable
         * second time onCommitted event - this event fires on when part of document has been received, this event is reliable
         * Every time we try to inject script we check if script wasn't yet executed
         * We use browser.tabs.insertCSS and browser.tabs.executeScript functions to inject our CSS/JS rules.
         * This method can be used in modern Chrome and FF only.
         * Bellow are presented rough event flows in Chrome and Firefox
         * This flows are were tested for Chrome 67.0.3396.87 (64 bit) and Firefox 60.0.2 (64-bit)
         * FLOWS MAY BE MODIFIED IN THE FUTURE
         *
                                                Chrome flow description

                                            +--------------------------------+
                                            |                                |
                                            | webRequest.onHeadersReceived   |     Prepare injection
                                            |                                |
                                            +---------------+----------------+
                                                            |
                                            +---------------v--------------+
                                            |                              |
                                            | webRequest.onResponseStarted |     Try to inject JS
                                            |                              |
                                            +------------------------------+

            onCommitted event belongs to     +------------------------------+
            WebNavigation events and fires   |                              |
            independently from               | webNavigation.onCommitted    |     Inject JS and CSS
            onResponseStarted event.         |                              |     Remove injection
            Thats why we try to inject       +------------------------------+
            two times
                                            +------------------------------+
                                            |                              |
                                            | webRequest.onErrorOccured    |     Remove injections on error
                                            |                              |
                                            +------------------------------+


                                                Firefox flow description

            onCommitted event in Firefox for +------------------------------+
            sub_frames fires before          |                              |
            onHeadersReceived event          | webNavigation.onCommitted     |
            That's why we inject our code    |                              |
            on onCompletedEvent              +------------------------------+

                                            +--------------------------------+
                                            |                                |
                                            | webRequest.onHeadersReceived   |      Prepare injection
                                            |                                |
                                            +--------------+-----------------+
                                                           |
                                            +--------------v---------------+
                                            |                              |
                                            | webRequest.onResponseStarted |      Try to inject JS code
                                            |                              |
                                            +------------------------------+

                                            +------------------------------+
                                            |                              |
                                            | webNavigation.onCommitted     |      Inject JS and CSS for main_frame
                                            |                              |      Remove injection
                                            +------------------------------+

                                            +------------------------------+
                                            |                              |
                                            | webRequest.onCompleted       |      Inject JS and CSS for sub_frame
                                            |                              |      Remove injection
                                            +------------------------------+

                                            +------------------------------+
                                            |                              |
                                            | webRequest.onErrorOccured    |     Remove injections on error
                                            |                              |
                                            +------------------------------+
            On tab close we clear our injections for corresponding tab
            Also our injections removes old injections for iframes when user navigates to other page in the same tab

            In Firefox and Chrome if page has iframes without remote source we can not get rules for this iframe with usual methods,
            That's why we get rules for main frame and inject them.
                                            +- ----------------------------------+
                                            |                                    |     Get injection for main iframe
                                            |  webNavigation.onDOMContentLoaded  |     inject it in the frame without
                                            |                                    |     remote source
                                            +- ----------------------------------+
         */
        (function (adguard) {
            /**
             * This object is used:
             * 1. to save js and css texts when onHeadersReceived event fires
             * by key corresponding to tabId and frameId
             * 2. to get js and css texts for injection
             * After injection corresponding js and css texts are removed from the object
             */
            const injections = {
                /**
                 * @typedef Injection
                 * @property {Boolean} ready value depends on are css and js texts ready or not. If false we should retry get them later
                 * @property {String} [jsScriptText] prepared JS code text for injection
                 * @property {String} [cssText] prepared CSS code text for injection
                 */

                /**
                 * Saves css, js and ready flag in injection object
                 * @param tabId
                 * @param frameId
                 * @param {Injection} injection
                 */
                set(tabId, frameId, injection) {
                    if (frameId === 0) {
                        delete this[tabId];
                    }
                    if (!this[tabId]) {
                        this[tabId] = {};
                    }
                    this[tabId][frameId] = injection;
                },

                get(tabId, frameId) {
                    if (this[tabId]) {
                        return this[tabId][frameId];
                    }
                    return undefined;
                },

                /**
                 * Removes injection corresponding to tabId and frameId
                 * @param {Number} tabId
                 * @param {Number} frameId
                 */
                removeTabFrameInjection(tabId, frameId) {
                    if (this[tabId]) {
                        delete this[tabId][frameId];
                        if (Object.keys(this[tabId]).length === 0) {
                            delete this[tabId];
                        }
                    }
                },

                /**
                 * Removes all injections corresponding to tabId
                 * @param {Number} tabId
                 */
                removeTabInjection(tabId) {
                    delete this[tabId];
                },
            };
            /**
             * Taken from
             * {@link https://github.com/seanl-adg/InlineResourceLiteral/blob/master/index.js#L136}
             * {@link https://github.com/joliss/js-string-escape/blob/master/index.js}
             */
            const reJsEscape = /["'\\\n\r\u2028\u2029]/g;
            function escapeJs(match) {
                switch (match) {
                    case '"':
                    case "'":
                    case '\\':
                        return `\\${match}`;
                    case '\n':
                        return '\\n\\\n'; // Line continuation character for ease
                    // of reading inlined resource.
                    case '\r':
                        return '';        // Carriage returns won't have
                    // any semantic meaning in JS
                    case '\u2028':
                        return '\\u2028';
                    case '\u2029':
                        return '\\u2029';
                }
            }

            /**
             * We use changing variable name because global properties
             * can be modified across isolated worlds of extension content page and tab page
             * https://bugs.chromium.org/p/project-zero/issues/detail?id=1225&desc=6
             */
            const variableName = `scriptExecuted${Date.now()}`;

            function buildScriptText(scriptText) {
                if (!scriptText) {
                    return null;
                }
                /**
                 * Executes scripts in a scope of the page.
                 * In order to prevent multiple script execution checks if script was already executed
                 * Sometimes in Firefox when content-filtering is applied to the page race condition happens.
                 * This causes an issue when the page doesn't have its document.head or document.documentElement at the moment of
                 * injection. So script waits for them. But if a quantity of frame-requests reaches FRAME_REQUESTS_LIMIT then
                 * script stops waiting with the error.
                 * Description of the issue: https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1004
                 */
                const injectedScript = `(function() {\
                    if (window.${variableName}) {\
                        return;\
                    }\
                    var script = document.createElement("script");\
                    script.setAttribute("type", "text/javascript");\
                    script.textContent = "${scriptText.replace(reJsEscape, escapeJs)}";\
                    var FRAME_REQUESTS_LIMIT = 500;\
                    var frameRequests = 0;\
                    function waitParent () {\
                        frameRequests += 1;\
                        var parent = document.head || document.documentElement;\
                        if (parent) {\
                            try {\
                                parent.appendChild(script);\
                                parent.removeChild(script);\
                            } catch (e) {\
                            } finally {\
                                window.${variableName} = true;\
                                return true;\
                            }\
                        }\
                        if(frameRequests < FRAME_REQUESTS_LIMIT) {\
                            requestAnimationFrame(waitParent);\
                        } else {\
                            console.log("AdGuard: document.head or document.documentElement were unavailable too long");\
                        }\
                    }\
                    waitParent();\
                })()`;

                return injectedScript;
            }

            /**
             * @param {SelectorsData} selectorsData Selectors data
             * @returns {string} CSS to be supplied to insertCSS or null if selectors data is empty
             */
            function buildCssText(selectorsData) {
                if (!selectorsData || !selectorsData.css) {
                    return null;
                }
                return selectorsData.css.join('\n');
            }

            /**
             * Checks requestType, tabId and event
             * We don't inject CSS or JS if request wasn't related to tab, or if request type
             * is not equal to DOCUMENT or SUBDOCUMENT.
             * @param {String} requestType
             * @param {Number} tabId
             * @param {String} eventName
             * @returns {Boolean}
             */
            function shouldSkipInjection(requestType, tabId, eventName) {
                /**
                 * onCompleted event is used only to inject code to the Firefox iframes
                 * because in current Firefox implementation webNavigation.onCommitted event for iframes
                 * occures early than webRequest.onHeadersReceived event
                 * if onCompleted event fired with requestType DOCUMENT then we skip it, because we
                 * use onCompleted event only for SUBDOCUMENTS
                 */
                if (eventName === 'onCompleted' && requestType === adguard.RequestTypes.DOCUMENT) {
                    return true;
                }
                if (tabId === adguard.BACKGROUND_TAB_ID) {
                    return true;
                }
                if (requestType !== adguard.RequestTypes.DOCUMENT && requestType !== adguard.RequestTypes.SUBDOCUMENT) {
                    return true;
                }
                return false;
            }

            const REQUEST_FILTER_READY_TIMEOUT = 100;
            /**
             * Prepares injection content (scripts and css) for a given frame.
             * @param {RequestDetails} details
             */
            function prepareInjection(details) {
                const { requestType } = details;
                const { tab } = details;
                const { tabId } = tab;
                if (shouldSkipInjection(requestType, tabId)) {
                    return;
                }
                const { frameId } = details;
                const url = details.requestUrl;
                const cssFilterOption = adguard.rules.CssFilter.RETRIEVE_TRADITIONAL_CSS;
                const retrieveScripts = true;
                const result = adguard.webRequestService.processGetSelectorsAndScripts(
                    { tabId },
                    url,
                    cssFilterOption,
                    retrieveScripts
                );

                if (result.requestFilterReady === false) {
                    injections.set(tabId, frameId, {
                        ready: false,
                    });
                } else {
                    injections.set(tabId, frameId, {
                        ready: true,
                        jsScriptText: buildScriptText(result.scripts),
                        cssText: buildCssText(result.selectors),
                        url,
                    });
                }
            }

            /**
             * Injects js code in the page on responseStarted event only if event was fired from the main_frame
             * @param {RequestDetails} details Details about the webrequest event
             */
            function tryInjectOnResponseStarted(details) {
                const { tab } = details;
                const { tabId } = tab;
                const { requestType } = details;
                const { frameId } = details;
                if (shouldSkipInjection(requestType, tabId)) {
                    return;
                }
                const injection = injections.get(tabId, frameId);
                if (injection && injection.jsScriptText) {
                    adguard.tabs.executeScriptCode(tabId, frameId, injection.jsScriptText);
                }
            }

            /**
             * Function checks if injection corresponds to url
             * This check could be useful when injections were prepared in the onBeforeRequest
             * or onHeadersReceived events and then there was redirection and document request
             * didn't fired in webRequest events
             * @param injection
             * @param url
             * @returns {boolean}
             */
            function isInjectionForUrl(injection, url) {
                return injection && injection.url === url;
            }

            /**
             * Injects necessary CSS and scripts into the web page.
             * @param {RequestDetails} details Details about the navigation event
             * @param {String} eventName Event name
             */
            function tryInject(details, eventName) {
                const { tab } = details;
                const { tabId } = tab;
                const { frameId } = details;
                const { requestType } = details;
                const frameUrl = details.requestUrl;
                if (shouldSkipInjection(requestType, tabId, eventName)) {
                    return;
                }

                const injection = injections.get(tabId, frameId);

                if (injection && !injection.ready) {
                    /**
                     * If injection is not ready yet, we call prepareScripts and tryInject functions again
                     * setTimeout callback lambda function accepts onCommitted details and eventName
                     */
                    setTimeout((details, eventName) => {
                        prepareInjection(details);
                        tryInject(details, eventName);
                    }, REQUEST_FILTER_READY_TIMEOUT, details, eventName);
                    injections.removeTabFrameInjection(tabId, frameId);
                    return;
                }

                /**
                 * webRequest api doesn't see requests served from service worker like they are served from the cache
                 * https://bugs.chromium.org/p/chromium/issues/detail?id=766433
                 * that's why we can't prepare injections when webRequest events fire
                 * also we should check if injection url is correct
                 * so we try to prepare this injection in the onCommit event again
                 */
                if (requestType === adguard.RequestTypes.DOCUMENT
                    && (!injection || !isInjectionForUrl(injection, frameUrl))) {
                    prepareInjection(details);
                    tryInject(details, eventName);
                    return;
                }

                /**
                 * Sometimes it can happen that onCommitted event fires earlier than onHeadersReceived
                 * for example onCommitted event for iframes in Firefox
                 */
                if (!injection) {
                    return;
                }

                if (injection.jsScriptText) {
                    adguard.tabs.executeScriptCode(tabId, frameId, injection.jsScriptText);
                }
                if (injection.cssText) {
                    adguard.tabs.insertCssCode(tabId, frameId, injection.cssText);
                }

                const mainFrameUrl = adguard.frames.getMainFrameUrl({ tabId });
                if (isIframeWithoutSrc(frameUrl, frameId, mainFrameUrl)) {
                    adguard.console.warn('Unexpected onCommitted event from this frame - frameId: {0}, frameUrl: {1}. See https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1046', frameId, frameUrl);
                }

                injections.removeTabFrameInjection(tabId, frameId);
            }

            /**
             * Removes injection if onErrorOccured event fires for corresponding tabId and frameId
             * @param {RequestDetails} details
             */
            function removeInjection(details) {
                const { requestType } = details;
                const { tab } = details;
                const { tabId } = tab;
                if (shouldSkipInjection(requestType, tabId)) {
                    return;
                }
                const { frameId } = details;
                injections.removeTabFrameInjection(tabId, frameId);
            }

            /**
             * Checks if iframe does not have a remote source
             * or is src is about:blank, javascript:'', etc
             * We don't include iframes with 'src=data:' because chrome and firefox don't allow to inject
             * in iframes with this type of src, this bug is reported here
             * https://bugs.chromium.org/p/chromium/issues/detail?id=55084
             * @param {string} frameUrl url
             * @param {number} frameId unique id of frame in the tab
             * @param {string} mainFrameUrl url of tab where iframe exists
             */
            function isIframeWithoutSrc(frameUrl, frameId, mainFrameUrl) {
                return (frameUrl === mainFrameUrl
                        || frameUrl === 'about:blank'
                        || frameUrl === 'about:srcdoc'
                        || frameUrl.indexOf('javascript:') > -1)
                    && frameId !== adguard.MAIN_FRAME_ID;
            }

            /**
             * This method injects css and js code in iframes without remote source
             * Usual webRequest callbacks don't fire for iframes without remote source
             * Also urls in these iframes may be "about:blank", "about:srcdoc", etc.
             * Due to this reason we prepare injections for them as for mainframe
             * and inject them only when onDOMContentLoaded fires
             * https://github.com/AdguardTeam/AdguardBrowserExtension/issues/1046
             * @param {{tabId: Number, url: String, processId: Number, frameId: Number, timeStamp: Number}} details
             */
            function tryInjectInIframesWithoutSrc(details) {
                const { frameId, tabId, url: frameUrl } = details;
                /**
                 * Get url of the tab where iframe exists
                 */
                const mainFrameUrl = adguard.frames.getMainFrameUrl({ tabId });
                if (mainFrameUrl && isIframeWithoutSrc(frameUrl, frameId, mainFrameUrl)) {
                    const cssFilterOption = adguard.rules.CssFilter.RETRIEVE_TRADITIONAL_CSS;
                    const retrieveScripts = true;
                    const result = adguard.webRequestService.processGetSelectorsAndScripts({ tabId }, mainFrameUrl, cssFilterOption, retrieveScripts);
                    if (result.requestFilterReady === false) {
                        setTimeout((details) => {
                            tryInjectInIframesWithoutSrc(details);
                        }, REQUEST_FILTER_READY_TIMEOUT, details);
                        return;
                    }
                    const jsScriptText = buildScriptText(result.scripts);
                    const cssText = buildCssText(result.selectors);
                    if (jsScriptText) {
                        adguard.tabs.executeScriptCode(tabId, frameId, jsScriptText);
                    }
                    if (cssText) {
                        adguard.tabs.insertCssCode(tabId, frameId, cssText);
                    }
                }
            }
            /**
             * https://developer.chrome.com/extensions/webRequest
             * https://developer.chrome.com/extensions/webNavigation
             */
            adguard.webRequest.onHeadersReceived.addListener(prepareInjection, ['<all_urls>']);
            adguard.webRequest.onResponseStarted.addListener(tryInjectOnResponseStarted, ['<all_urls>']);
            adguard.webNavigation.onCommitted.addListener(tryInject);
            adguard.webRequest.onErrorOccurred.addListener(removeInjection, ['<all_urls>']);
            adguard.webNavigation.onDOMContentLoaded.addListener(tryInjectInIframesWithoutSrc);
            // In the current Firefox version (60.0.2), the onCommitted even fires earlier than
            // onHeadersReceived for SUBDOCUMENT requests
            // This is true only for SUBDOCUMENTS i.e. iframes
            // so we inject code when onCompleted event fires
            if (adguard.utils.browser.isFirefoxBrowser()) {
                adguard.webRequest.onCompleted.addListener((details) => { tryInject(details, 'onCompleted'); }, ['<all_urls>']);
            }
            // Remove injections when tab is closed
            adguard.tabs.onRemoved.addListener(injections.removeTabInjection);
        })(adguard);
    }

    /**
     * Request context recording
     */
    adguard.webRequest.onCompleted.addListener(({ requestId }) => {
        adguard.cookieFiltering.modifyCookies(requestId);
        adguard.requestContextStorage.onRequestCompleted(requestId);
    }, ['<all_urls>']);

    adguard.webRequest.onErrorOccurred.addListener(({ requestId }) => {
        adguard.cookieFiltering.modifyCookies(requestId);
        adguard.requestContextStorage.onRequestCompleted(requestId);
    }, ['<all_urls>']);

    /**
     * Handles redirect separately:
     * If a request is redirected to a data:// URL, onBeforeRedirect is the last reported event.
     * https://developer.chrome.com/extensions/webRequest#life_cycle
     */
    adguard.webRequest.onBeforeRedirect.addListener(({ requestId, redirectUrl }) => {
        if (redirectUrl && redirectUrl.indexOf('data:') === 0) {
            adguard.requestContextStorage.onRequestCompleted(requestId);
        }
    }, ['<all_urls>']);

    // Subscribe script is executed when onCommitted event fires,
    // because this event is the most reliable
    /**
     * Subscribe script is executed when onCommitted event fires,
     * because this event is the most reliable
     */
    adguard.webNavigation.onCommitted.addListener((details) => {
        const { tab, requestType, frameId } = details;
        if ((requestType !== adguard.RequestTypes.DOCUMENT
            && requestType !== adguard.RequestTypes.SUBDOCUMENT)
            || tab.tabId === adguard.BACKGROUND_TAB_ID) {
            return;
        }
        // load subscribe script on dom content load
        adguard.tabs.executeScriptFile(tab.tabId, { file: '/lib/content-script/subscribe.js', frameId });
    });
})(adguard);

/**
 * This file is part of Adguard Browser Extension (https://github.com/AdguardTeam/AdguardBrowserExtension).
 *
 * Adguard Browser Extension is free software: you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation, either version 3 of the License, or
 * (at your option) any later version.
 *
 * Adguard Browser Extension is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with Adguard Browser Extension.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
 * Adguard simple api
 * @type {{start, stop, configure}}
 */
(function (adguard, global) {

    'use strict';

    function noOpFunc() {
    }

    /**
     * Validates configuration
     * @param configuration Configuration object
     */
    function validateConfiguration(configuration) {
        if (!configuration) {
            throw new Error('"configuration" parameter is required');
        }
        validateFiltersConfiguration(configuration.filters);
        validateDomains(configuration.whitelist, 'whitelist');
        validateDomains(configuration.blacklist, 'blacklist');
    }

    /**
     * Validates filters identifiers
     * @param filters Array
     */
    function validateFiltersConfiguration(filters) {
        if (!filters || filters.length === 0) {
            return;
        }
        for (var i = 0; i < filters.length; i++) {
            var filterId = filters[i];
            if (typeof filterId !== 'number') {
                throw new Error(filterId + ' is not a number');
            }
        }
    }

    /**
     * Validate domains
     * @param domains Array
     * @param prop Property name (whitelist or blacklist)
     */
    function validateDomains(domains, prop) {
        if (!domains || domains.length === 0) {
            return;
        }
        for (var i = 0; i < domains.length; i++) {
            var domain = domains[i];
            if (typeof domain !== 'string') {
                throw new Error('Domain ' + domain + ' at position ' + i + ' in ' + prop + ' is not a string');
            }
        }
    }

    /**
     * Configures white and black lists.
     * If blacklist is not null filtration will be in inverted mode, otherwise in default mode.
     * @param configuration Configuration object: {whitelist: [], blacklist: []}
     */
    function configureWhiteBlackLists(configuration) {

        if (!configuration.force && !configuration.blacklist && !configuration.whitelist) {
            return;
        }

        var domains;
        if (configuration.blacklist) {
            adguard.whitelist.changeDefaultWhiteListMode(false);
            domains = configuration.blacklist;
        } else {
            adguard.whitelist.changeDefaultWhiteListMode(true);
            domains = configuration.whitelist;
        }
        adguard.whitelist.updateWhiteListDomains(domains || []);
    }

    /**
     * Configures enabled filters
     * @param configuration Configuration object: {filters: [...]}
     * @param callback
     */
    function configureFilters(configuration, callback) {

        if (!configuration.force && !configuration.filters) {
            callback();
            return;
        }

        var filterIds = (configuration.filters || []).slice(0);
        for (var i = filterIds.length - 1; i >= 0; i--) {
            var filterId = filterIds[i];
            var filter = adguard.subscriptions.getFilter(filterId);
            if (!filter) {
                adguard.console.error('Filter with id {0} not found. Skip it...', filterId);
                filterIds.splice(i, 1);
            }
        }

        adguard.filters.addAndEnableFilters(filterIds, function () {
            var enabledFilters = adguard.filters.getEnabledFilters();
            for (var i = 0; i < enabledFilters.length; i++) {
                var filter = enabledFilters[i];
                if (filterIds.indexOf(filter.filterId) < 0) {
                    adguard.filters.disableFilters([filter.filterId]);
                }
            }

            var listernerId = adguard.listeners.addListener(function (event) {
                if (event === adguard.listeners.REQUEST_FILTER_UPDATED) {
                    adguard.listeners.removeListener(listernerId);
                    callback();
                }
            });
        });
    }

    /**
     * Configures custom (user) rules
     * @param configuration Configuration object: {rules: [...]}
     */
    function configureCustomRules(configuration) {

        if (!configuration.force && !configuration.rules) {
            return;
        }

        var content = (configuration.rules || []).join('\r\n');
        adguard.userrules.updateUserRulesText(content);
    }

    /**
     * Configures backend's URLs
     * @param configuration Configuration object: {filtersMetadataUrl: '...', filterRulesUrl: '...'}
     */
    function configureFiltersUrl(configuration) {
        if (!configuration.force && !configuration.filtersMetadataUrl && !configuration.filterRulesUrl) {
            return;
        }
        adguard.backend.configure({
            filtersMetadataUrl: configuration.filtersMetadataUrl,
            filterRulesUrl: configuration.filterRulesUrl
        });
    }

    /**
     * Start filtration.
     * Also perform installation on first run.
     * @param configuration Configuration object
     * @param callback Callback function
     */
    var start = function (configuration, callback) {

        validateConfiguration(configuration);

        callback = callback || noOpFunc;

        // Force apply all configuration fields
        configuration.force = true;

        adguard.rulesStorage.init(function () {
            adguard.localStorage.init(function () {
                adguard.filters.start({}, function () {
                    configure(configuration, callback);
                });
            });
        });
    };

    /**
     * Stop filtration
     * @param callback Callback function
     */
    var stop = function (callback) {
        adguard.filters.stop(callback || noOpFunc);
    };

    /**
     * Configure current filtration settings
     * @param configuration Filtration configuration: {filters: [], whitelist: [], blacklist: []}
     * @param callback
     */
    var configure = function (configuration, callback) {

        if (!adguard.filters.isInitialized()) {
            throw new Error('Applications is not initialized. Use \'start\' method.');
        }
        validateConfiguration(configuration);

        callback = callback || noOpFunc;

        configureFiltersUrl(configuration);
        configureWhiteBlackLists(configuration);
        configureCustomRules(configuration);
        configureFilters(configuration, callback);
    };

    var initAssistant = function (tabId) {
        var assistantOptions = {
            addRuleCallbackName: 'assistant-create-rule'
        };
        adguard.tabs.sendMessage(tabId, {
            type: 'initAssistant',
            options: assistantOptions
        });
    };

    /**
     * Opens assistant dialog in the specified tab
     * @param tabId Tab identifier
     */
    const openAssistant = (tabId) => {
        if (adguard.tabs.executeScriptFile) {
            // Load Assistant code to the activate tab immediately
            adguard.tabs.executeScriptFile(null, { file: '/adguard/assistant/assistant.js' }, () => {
                initAssistant(tabId);
            });
        } else {
            // Manually start assistant
            initAssistant(tabId);
        }
    };

    /**
     * Closes assistant dialog in the specified tab
     * @param tabId Tab identifier
     */
    var closeAssistant = function (tabId) {
        adguard.tabs.sendMessage(tabId, {
            type: 'destroyAssistant'
        });
    };

    adguard.backend.configure({
        localFiltersFolder: 'adguard',
        redirectSourcesFolder: 'adguard',
        localFilterIds: []
    });

    global.adguardApi = {
        start: start,
        stop: stop,
        configure: configure,
        /**
         *  Fired when a request is blocked
         *  var onBlocked = function (details) {console.log(details);};
         *  adguardApi.onRequestBlocked.addListener(onBlocked);
         *  adguardApi.onRequestBlocked.removeListener(onBlocked);
         *  details = {
         *      tabId: ...,
         *      requestUrl: "...",
         *      referrerUrl: "...",
         *      requestType: "...", see adguard.RequestTypes
         *      rule: "..." // Rule text
         *      filterId: ... // Filter identifier
         *   };
         */
        onRequestBlocked: adguard.webRequestService.onRequestBlocked,
        openAssistant: openAssistant,
        closeAssistant: closeAssistant
    };

})(adguard, window);
